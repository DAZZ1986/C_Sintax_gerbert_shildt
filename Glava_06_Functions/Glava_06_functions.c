#include <locale.h>
#include <stdio.h>



int main(void)
{
    char* locale = setlocale(LC_ALL, "");


    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/06/06.htm
    printf("\n\n\n/////////// Функции\n");
    /*
    Функции — это строительные элементы языка С и то место, в котором выполняется вся работа программы. В этой главе изучаются
    свойства функций, в том числе их аргументы, возвращаемые значения, прототипы, а также рекурсия.

    Содержание:
        Общий вид функции
        Что такое область действия функции
        Аргументы функции
        Аргументы функции main(): argv и argc
        Оператор return
        Что возвращает функция main()?
        Рекурсия
        Прототип функции
        Объявление списков параметров переменной длины
        Правило "неявного int"
        Старомодные и современные объявления параметров функций
        Ключевое слово inline
    */





    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/06/0601.htm
    printf("\n\n\n/////////// Общий вид функции\n");
    /*
    В общем виде функция выглядит следующим образом:

    возвр-тип имя-функции(список параметров)
    {
      тело функции
    }
    возвр-тип определяет тип данного, возвращаемого функцией[1]. Функция может возвращать любой тип данных, за исключением 
    массивов список параметров — это список, элементы которого отделяются друг от друга запятыми. Каждый такой элемент состоит
    из имени переменной и ее типа данных. При вызове функции параметры принимают значения аргументов. Функция может быть и без
    параметров, тогда их список будет пустым. Такой пустой список можно указать в явном виде, поместив для этого внутри скобок 
    ключевое слово void.

    В объявлениях (декларациях) переменных можно объявить (декларировать) несколько переменных одного и того же типа, используя
    для этого список одних только имен, элементы которого отделены друг от друга запятыми. А все параметры функций, наоборот, 
    должны объявляться отдельно, причем для каждого из них надо указывать и тип, и имя. То есть в общем виде список объявлений
    параметров должен выглядеть следующим образом:
    f(тип имя_переменной1, тип имя_переменной2,..., тип имя_переменнойN)

    Вот, например, два объявления параметров функций, первое из которых правильное, а второе — нет:
    f(int i, int k, int j) //правильное
    f(int i, k, float j)   //неправильное, у переменной k должен быть собственный спецификатор типа
    ----------

    [1]Данное, возвращаемое функцией, называется также результатом. Соответственно, возвращаемый тип часто называется также
    типом результата.
    */





    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/06/0602.htm
    printf("\n\n\n/////////// Что такое область действия функции\n");
    /*
    В языке правила работы с областями действия — это правила, которые определяют, известен ли фрагменту кода другой фрагмент
    кода или данных, или имеет ли он доступ к этому другому фрагменту. Об областях действия, определяемых в языке С, говорилось
    в главе 2. Здесь же мы более подробно рассмотрим одну специальную область действия — ту, которая определяется функцией.

    Каждая функция представляет собой конечный блок кода. Таким образом, она определяет область действия этого блока. Это 
    значит, что код функции является закрытым и недоступным ни для какого выражения из любой другой функции, если только не
    выполняется вызов содержащей его функции. (Например, нельзя перейти в середину другой функции с помощью goto.) Код, 
    который составляет тело функции, скрыт от остальной части программы, и если он не использует глобальных переменных, то
    не может воздействовать на другие части программы или, наоборот, подвергаться воздействию с их стороны. Иначе говоря, 
    код и данные, определенные внутри одной функции, без глобальных переменных не могут воздействовать на код и данные внутри
    другой функции, так как у любых двух разных функций разные области действия.

    Переменные, определенные внутри функции, являются локальными. Локальная переменная создается в начале выполнения функции,
    а при выходе из этой функции она уничтожается. Таким образом, локальная переменная не может сохранять свое значение в 
    промежутках между вызовами функции. Единственное исключение из этого правила — переменные, объявленные со спецификатором
    класса памяти static. Таким переменным память выделяется так же, как и глобальным переменным, которые используются для 
    хранения значений, но область действия таких переменных ограничена содержащими их функциями. (Дополнительная информация 
    о локальных и глобальных переменных приведена в главе 2.)

    Формальные параметры функции также находятся в ее области действия. Это значит, что параметр доступен внутри всей функции.
    Параметр создается в начале выполнения функции, и уничтожается при выходе из нее.

    Все функции имеют файл в качестве области действия (file scope). Таким образом, функцию нельзя определять внутри другой
    функции.(ЖЕНЯ) Поэтому С практически не является языком с блочной структурой.
    */






    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/06/0603.htm
    printf("\n\n\n/////////// Аргументы функции\n");
    /*
    Если функция должна принимать аргументы, то в ее объявлении следует декларировать параметры, которые примут значения этих 
    аргументов. Как видно из объявления следующей функции, объявления параметров стоят после имени функции.

    //Возвращает 1, если символ c входит в строку s, или возвращает 0 если не входит.
    int is_in(char* s, char c)
    {
        while (*s)
            if (*s == c) return 1;
            else s++;
        return 0;
    }
    Функция is_in() имеет два параметра: s и d. Если символ c входит в строку s, то эта функция возвращает 1, в противном 
    случае она возвращает 0.
    Хотя параметры выполняют специальную задачу, — принимают значения аргументов, передаваемых функции, — они все равно ведут
    себя так, как и другие локальные переменные. Формальным параметрам функции, например, можно присваивать какие-либо 
    значения или использовать эти параметры в каких-либо выражениях.
    
    
    
    
    
    ///////////Вызовы по значению и по ссылке
    В языках программирования имеется два способа передачи значений подпрограмме. Первый из них — вызов по значению. При его 
    применении в формальный параметр подпрограммы копируется значение аргумента. В таком случае изменения параметра на аргумент
    не влияют.
    Вторым способом передачи аргументов подпрограмме является вызов по ссылке. При его применении в параметр копируется адрес 
    аргумента. Это значит, что, в отличие от вызова по значению, изменения значения параметра приводят к точно таким же 
    изменениям значения аргумента.
    За небольшим количеством исключений, в языке С для передачи аргументов используется вызов по значению. Обычно это означает,
    что код, находящийся внутри функции, не может изменять значений аргументов, которые использовались при вызове функции.

    Проанализируйте следующую программу:
    #include <stdio.h>

    int sqr(int x);  //объявление функции

    int main(void)
    {
        int t = 10;

        printf("%d %d", sqr(t), t); //тут переменную t мы не изменили, тк из функции вернулась копия!

        return 0;
    }

    int sqr(int x)  //описание функции
    {
        x = x * x;
        return(x);
    }
    В этом примере в параметр х копируется 10 — значение аргумента для sqr(). Когда выполняется присваивание х = х * х, 
    модифицируется только локальная переменная х. А значение переменной t, использованной в качестве аргумента при вызове sqr(),
    по - прежнему остается равным 10. Поэтому выведено будет следующее: 100 10.
    Помните, что именно копия значения аргумента передается в функцию. А то, что происходит внутри функции, не влияет на 
    значение переменной, которая была использована при вызове в качестве аргумента.
    
    
    
    
    
    
    
    ///////////Вызов по ссылке
    Хотя в С для передачи параметров применяется вызов по значению, можно создать вызов и по ссылке, передавая не сам аргумент,
    а указатель на него[1]. Так как функции передается адрес аргумента, то ее внутренний код в состоянии изменить значение 
    этого аргумента, находящегося, между прочим, за пределами самой функции.

    Указатель передается функции так, как и любой другой аргумент. Конечно, в таком случае параметр следует декларировать как
    один из типов указателей. Это можно увидеть на примере функции swap(), которая меняет местами значения двух целых 
    переменных, на которые указывают аргументы этой функции:

    void swap(int* x, int* y)
    {
        int temp;

        temp = *x;  //сохранить значение по адресу x
        *x = *y;    //поместить y в x
        *y = temp;  //поместить x в y
    }
    Функция swap() может выполнять обмен значениями двух переменных, на которые указывают х и y, потому что передаются их 
    адреса, а не значения. Внутри функции, используя стандартные операции с указателями, можно получить доступ к содержимому 
    переменных и провести обмен их значений[2].
    Помните, что swap() (или любую другую функцию, в которой используются параметры в виде указателей) необходимо вызывать
    вместе с адресами аргументов[3].Следующая программа показывает, как надо правильно вызывать swap():

    #include <stdio.h>
    void swap(int* x, int* y);

    int main(void)
    {
        int i, j;

        i = 10;
        j = 20;

        printf("i и j перед обменом значениями: %d %d\n", i, j);
        swap(&i, &j); //передать адреса переменных i и j
        printf("i и j после обмена значениями: %d %d\n", i, j);

        return 0;
    }

    void swap(int* x, int* y)
    {
        int temp;

        temp = *x;  //сохранить значение по адресу x
        *x = *y;    //поместить y в x
        *y = temp;  //поместить x в y
    }
    И вот что вывела эта программа:
    i и j перед обменом значениями : 10 20
    i и j после обмена значениями : 20 10

    В программе переменной i присваивается значение 10, а переменной j — значение 20. Затем вызывается функция swap() с 
    адресами этих переменных. (Для получения адреса каждой из переменных используется унарный оператор &.) Поэтому в swap() 
    передаются адреса переменных i и j, а не их значения.

    На заметку: Язык C++ при помощи параметров-ссылок дает возможность полностью автоматизировать вызов по ссылке. А в 
    языке С параметры-ссылки не поддерживается. (ЖЕНЯ)







    ///////////Вызов функций с помощью массивов
    Подробно о массивах рассказывалось в главе 4. В настоящем же разделе рассказывается о передаче массивов функциям в 
    качестве аргументов. Этот вопрос рассматривается потому, что эта операция является исключением по отношению к обычной 
    передаче параметров, выполняемой путем вызова по значению[4].

    Когда в качестве аргумента функции используется массив, то функции передается его адрес. В этом и состоит исключение по 
    отношению к правилу, которое гласит, что при передаче параметров используется вызов по значению. В случае передачи массива
    функции ее внутренний код работает с реальным содержимым этого массива и может изменить это содержимое.
    Проанализируйте, например, функцию print_upper(), которая печатает свой строковый аргумент на верхнем регистре:
    #include <stdio.h>
    #include <ctype.h>

    void print_upper(char* string);

    int main(void)
    {
        char s[80];

        printf("Введите строку символов: ");
        gets(s);
        print_upper(s);
        printf("\ns теперь на верхнем регистре: %s", s);
        return 0;
    }

    //Печатать строку на верхнем регистре
    void print_upper(char* string)
    {
        register int t;

        for (t = 0; string[t]; ++t) {
            string[t] = toupper(string[t]);
            putchar(string[t]);
        }
    }

    Вот что будет выведено в случае фразы "This is a test." (это тест):
        Введите строку символов: This is a test.
        THIS IS A TEST.
        s теперь в верхнем регистре : THIS IS A TEST.

    Правда, эта программа не работает с символами кириллицы.
    После вызова print_upper() содержимое массива s в main() переводится в символы верхнего регистра. Если вам это не нужно, 
    программу можно написать следующим образом:
    #include <stdio.h>
    #include <ctype.h>

    void print_upper(char* string);

    int main(void)
    {
        char s[80];

        printf("Введите строку символов: ");
        gets(s);
        print_upper(s);
        printf("\ns не изменялась: %s", s);

        return 0;
    }

    void print_upper(char* string)
    {
        register int t;

        for (t = 0; string[t]; ++t)
            putchar(toupper(string[t]));
    }

    Вот какой на этот раз получится фраза "This is a test.":
        Введите строку символов: This is a test.
        THIS IS A TEST.
        s не изменилась : This is a test.

    На этот раз содержимое массива не изменилось, потому что внутри print_upper() не изменялись его значения.
    Классическим примером передачи массивов в функции является стандартная библиотечная функция gets(). Хотя gets(), которая 
    находится в вашей стандартной библиотеке, и более сложная, чем предлагаемая вам версия xgets(), но с помощью функции 
    xgets() вы сможете получить представление о том, как работает gets().

    //Упрощенная версия стандартной библиотечной функции gets()
    char* xgets(char* s)  //ЖЕНЯ, char*?? ЭТО ОЗНАЧСАЕТ ЧТО тип возвращающего значения должен быть указателем, как у нас 
                          //и происходит, это указатель return p.
    {
        char ch, *p;
        int t;

        p = s;  //xgets() возвращает указатель s

        for (t = 0; t < 80; ++t) {
            ch = getchar();  // ЖЕНЯ???

            switch (ch) {
            case '\n':
                s[t] = '\0'; //завершает строку
                return p;
            case '\b':
                if (t > 0) t--;
                break;
            default:
                s[t] = ch;
            }
        }
        s[79] = '\0';
        return p;
    }
    Функцию xgets() следует вызывать с указателем char*.(ЖЕНЯ) Им, конечно же, может быть имя символьного массива, которое по 
    определению является указателем char*. В самом начале программы xgets() выполняется цикл for от 0 до 80. Это не даст 
    вводить с клавиатуры строки, содержащие более 80 символов. При попытке ввода большего количества символов происходит 
    возврат из функции. (В настоящей функции gets() такого ограничения нет.) Так как в языке С нет встроенной проверки 
    границ, программист должен сам позаботиться, чтобы в любом массиве, используемом при вызове xgets(), помещалось не менее
    80 символов. Когда символы вводятся с клавиатуры, они сразу записываются в строку. Если пользователь нажимает клавишу 
    <Backspase>, то счетчик t уменьшается на 1, а из массива удаляется последний символ, введенный перед нажатием этой 
    клавиши. Когда пользователь нажмет <ENTER>, в конец строки запишется нуль, т.е. признак конца строки. Так как массив, 
    использованный для вызова xgets(), модифицируется, то при возврате из функции в нем будут находиться введенные 
    пользователем символы.


        ----------
        [1]Конечно, при передаче указателя будет применен вызов по значению, и сам указатель внутри функции вы изменить не 
        сможете.Однако для того объекта, на который указывает этот указатель, все произойдет так, будто этот объект был 
        передан по ссылке.В некоторых языках программирования(например, в Алголе - 60) имелись специальные средства, 
        позволяющие уточнить, как следует передавать аргументы : по ссылке или по значению.Благодаря наличию указателей 
        в С механизм передачи параметров удалось унифицировать.Параметры, не являющиеся массивами, в С всегда вызываются 
        только по значению, но все, что в других языках вы можете сделать с объектом, получив ссылку на него(т.е.его адрес),
        вы можете сделать, получив значение указателя на этот объект(т.е.опять же, его адрес).Так что в языке С благодаря 
        свойственной ему унификации передачи параметров никаких проблем не возникает.А вот в других языках трудности, 
        связанные с отсутствием эффективных средств работы с указателями, встречаются довольно часто.

        [2]Конечно, задача, решаемая этой программой, кажется тривиальной.Ну разве представляет трудность написать на
        каком - либо процедурном языке, например, на Алголе - 60, процедуру, которая обменивает значения своих параметров.
        Ведь так просто написать : procedure swap(x, y); integer х, y; begin integer t; t: = x; x: = y; y: = t end. Но эта
        процедура работает неправильно, хотя вызов значений здесь происходит по ссылке!Причем сразу найти тестовый пример, 
        демонстрирующий ошибочность этой процедуры, удается далеко не всем.Ведь в случае вызова swap(i, j) все работает 
        правильно!А что будет в случае вызова swap(i, a[i]) ? Да и можно ли на Алголе - 60 вообще написать требуемую процедуру?
        Если вы склоняетесь к отрицательному ответу, то это показывает, насколько все - таки необходимы указатели в развитых 
        языках программирования.Если все же вы знаете правильный ответ, то обратите внимание на то, что требуемая процедура,
        хотя и не длинная, но все же содержит своего рода программистский фокус!

        [3]Конечно, это просто программистский жаргон.На самом деле, конечно, аргументами являются именно адреса переменных,
        а не сами переменные.Просто в этом случае для краткости изложения программисты "делают вид", что вроде бы и в самом 
        деле происходит передача значений по ссылке.

        [4]Ведь при вызове по значению пришлось бы копировать весь массив!
    */





    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/06/0604.htm
    printf("\n\n\n/////////// Аргументы функции main(): argv и argc\n");
    /*
    Иногда при запуске программы бывает полезно передать ей какую-либо информацию. Обычно такая информация передается
    функции main() с помощью аргументов командной строки. Аргумент командной строки — это информация, которая вводится в
    командной строке операционной системы вслед за именем программы. Например, чтобы запустить компиляцию программы,
    необходимо в командной строке после подсказки набрать примерно следующее:
    cc имя_программы

    имя_программы представляет собой аргумент командной строки, он указывает имя той программы, которую вы собираетесь 
    компилировать.

    Чтобы принять аргументы командной строки, используются два специальных встроенных аргумента: argc и argv. 
    Параметр argc содержит количество аргументов в командной строке и является целым числом, причем он всегда не меньше 1,
    потому что первым аргументом считается имя программы.
    А параметр argv является указателем на массив указателей на строки. В этом массиве каждый элемент указывает на 
    какой-либо аргумент командной строки. Все аргументы командной строки являются строковыми, поэтому преобразование
    каких бы то ни было чисел в нужный двоичный формат должно быть предусмотрено в программе при ее разработке.

    Вот простой пример использования аргумента командной строки. На экран выводятся слово Привет и ваше имя, которое надо
    указать в виде аргумента командной строки.

    #include <stdio.h>
    #include <stdlib.h>

    int main(int argc, char *argv[])
    {
      if(argc!=2) {
        printf("Вы забыли ввести свое имя.\n");
        exit(1);
      }
      printf("Привет %s", argv[1]);

      return 0;
    }
    Если вы назвали эту программу name (имя) и ваше имя Том, то для запуска программы следует в командную строку ввести 
    name Том. В результате выполнения программы на экране появится сообщение Привет, Том.

    Во многих средах все аргументы командной строки необходимо отделять друг от друга пробелом или табуляцией. Запятые, 
    точки с запятой и тому подобные символы разделителями не считаются. Например,
    run Spot, run
    состоит из трех символьных строк, в то время как
    Эрик, Рик, Фред
    представляет собой одну символьную строку — запятые, как правило, разделителями не считаются.

    Если в строке имеются пробелы, то, чтобы из нее не получилось несколько аргументов, в некоторых средах эту строку можно
    заключать в двойные кавычки. В результате вся строка будет считаться одним аргументом. Чтобы подробнее узнать, как 
    в вашей операционной системе задаются параметры командной строки, изучите документацию этой системы.

    Очень важно правильно объявлять argv. Вот как это делают чаще всего:
    char *argv[];

    Пустые квадратные скобки указывают на то, что у массива неопределенная длина. Теперь получить доступ к отдельным 
    аргументам можно с помощью индексации массива argv. Например, argv[0] указывает на первую символьную строку, которой 
    всегда является имя программы; argv[1] указывает на первый аргумент и так далее.

    Другим небольшим примером использования аргументов командной строки является приведенная далее программа countdown 
    (счет в обратном порядке). Эта программа считает в обратном порядке, начиная с какого-либо значения (указанного в 
    командной строке), и подает звуковой сигнал, когда доходит до 0. Обратите внимание, что первый аргумент, содержащий 
    начальное значение, преобразуется в целое значение с помощью стандартной функции atoi(). Если вторым аргументом 
    командной строки (а если считать аргументом имя программы, то третьим) является строка "display" (вывод на экран), 
    то результат отсчета (в обратном порядке) будет выводиться на экран.

    //Программа счета в обратном порядке.
    #include <stdio.h>
    #include <stdlib.h>
    #include <ctype.h>
    #include <string.h>

    int main(int argc, char* argv[])
    {
        int disp, count;

        if (argc < 2) {
            printf("В командной строке необходимо ввести число,
                с которого\n");
                printf("начинается отсчет.  Попробуйте снова.\n");
            exit(1);
        }

        if (argc == 3 && !strcmp(argv[2], "display")) disp = 1;
        else disp = 0;

        for (count = atoi(argv[1]); count; --count)
            if (disp) printf("%d\n", count);

        putchar('\a');  //здесь подается звуковой сигнал
        printf("Счет закончен");

        return 0;
    }
    Обратите внимание, если аргументы командной строки не будут указаны, то будет выведено сообщение об ошибке. В 
    программах с аргументами командной строки часто делается следующее: в случае, когда пользователь запускает эти 
    программы без ввода нужной информации, выводятся инструкции о том, как правильно указывать аргументы.

    Чтобы получить доступ к отдельному символу одного из аргументов командной строки, введите в argv второй индекс. 
    Например, следующая программа посимвольно выводит все аргументы, с которыми ее вызвали:
    #include <stdio.h>

    int main(int argc, char* argv[])
    {
        int t, i;

        for (t = 0; t < argc; ++t) {
            i = 0;

            while (argv[t][i]) {
                putchar(argv[t][i]);
                ++i;
            }
            printf("\n");
        }

        return 0;
    }
    Помните, первый индекс argv обеспечивает доступ к строке, а второй индекс — доступ к ее отдельным символам.
    Обычно argc и argv используют для того, чтобы передать программе начальные команды, которые понадобятся ей при запуске.
    Например, аргументы командной строки часто указывают такие данные, как имя файла, параметр или альтернативное поведение.
    Использование аргументов командной строки придает вашей программе "профессиональный внешний вид" и облегчает ее 
    использование в пакетных файлах.

    Имена argc и argv являются традиционными, но не обязательными. Эти два параметра в функции main() вы можете назвать 
    как угодно. Кроме того, в некоторых компиляторах для main() могут поддерживаться - дополнительные аргументы, поэтому 
    обязательно изучите документацию к вашему компилятору.

    Когда для программы не требуются параметры командной строки, то чаще всего явно декларируют функцию main() как не 
    имеющую параметров. В таком случае в списке параметров этой функции используют ключевое слово void.
    */  






    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/06/0605.htm
    printf("\n\n\n/////////// Оператор return\n");
    /*
    Механизм использования return описан в главе 3. Как вы помните, там говорится, что этот оператор имеет два важных 
    применения. Во-первых, он обеспечивает немедленный выход из функции, т.е. заставляет выполняющуюся программу передать
    управление коду, вызвавшему функцию. Во-вторых, этот оператор можно использовать для того, чтобы возвратить значение. 
    В следующих разделах рассказывается, каким именно образом можно использовать оператор return.
    
    
    
    
    
    ///////////Возврат из функции
    Функция может завершать выполнение и осуществлять возврат в вызывающую программу двумя способами. Первый способ 
    используется тогда, когда после выполнения последнего оператора в функции встречается закрывающая фигурная скобка (}). 
    (Конечно, это просто жаргон, ведь в настоящем объектном коде фигурной скобки нет!) Например, функция pr_reverse() в
    приведенной ниже программе просто выводит на экран в обратном порядке строку "Мне нравится С", а затем возвращает 
    управление вызывающей программе.
    #include <string.h>
    #include <stdio.h>

    void pr_reverse(char *s);

    int main(void)
    {
      pr_reverse("Мне нравится C");

      return 0;
    }

    void pr_reverse(char *s)
    {
      register int t;

      for(t=strlen(s)-1; t>=0; t--) putchar(s[t]);
    }
    Как только строка выведена на экран, функции pr_reverse() "делать больше нечего", поэтому она возвращает управление
    туда, откуда она была вызвана.

    Но на практике не так уж много функций используют именно такой способ завершения выполнения. В большинстве функций 
    для завершения выполнения используется оператор return — или потому, что необходимо вернуть значение, или чтобы сделать
    код функции проще и эффективнее.

    В функции может быть несколько операторов return. Например, в следующей программе функция find_substr() возвращает 
    начальную позицию подстроки в строке или же возвращает —1, если подстрока, наоборот, не найдена. В этой функции для
    упрощения кодирования используются два оператора return.

    #include <stdio.h>

    int find_substr(char *s1, char *s2);

    int main(void)
    {
      if(find_substr("C - это забавно", "is") != -1)
        printf("Подстрока найдена.");

      return 0;
    }

    //Вернуть позицию первого, вхождения s2 в s1
    int find_substr(char* s1, char* s2)
    {
        register int t;
        char *p, *p2;

        for (t = 0; s1[t]; t++) {
            p = &s1[t];
            p2 = s2;

            while (*p2 && *p2 == *p) {
                p++;
                p2++;
            }
            if (!*p2) return t; //1-й оператор return
        }
        return -1; //2-й оператор return
    }






    ///////////Возврат значений
    Все функции, кроме тех, которые относятся к типу void, возвращают значение. Это значение указывается выражением в 
    операторе return. Стандарт С89 допускает выполнение оператора return без указания выражения внутри функции, тип которой
    отличен от void. В этом случае все равно происходит возврат какого-нибудь произвольного значения. Но такое положение 
    дел, мягко говоря, никуда не годится! Поэтому в Стандарте С99(да и в C++) предусмотрено, что в функции, тип которой 
    отличен от void, в операторе return необходимо обязательно указать возвращаемое значение. То есть, согласно С99, если
    для какой-либо функции указано, что она возвращает значение, то внутри этой функции у любого оператора return должно
    быть свое выражение. Однако если функция, тип которой отличен от void, выполняется до самого конца(то есть до 
    закрывающей ее фигурной скобки), то возвращается произвольное(непредсказуемое с точки зрения разработчика программы!)
    значение. Хотя здесь нет синтаксической ошибки, это является серьезным упущением и таких ситуаций необходимо избегать.

    Если функция не объявлена как имеющая тип void, она может использоваться как операнд в выражении!!! Поэтому каждое из 
    следующих выражений является правильным:
    x = power(y);
    if (max(x, y) > 100) printf("больше");
    for (ch = getchar(); isdigit(ch); ) ...;

    Общепринятое правило гласит, что вызов функции не может находиться в левой части оператора присваивания!!! Выражение
    swap(x, y) = 100; //неправильное выражение
    является неправильным. Если компилятор С в какой-либо программе найдет такое выражение, то пометит его как ошибочное 
    и программу компилировать не будет.

    В программе можно использовать функции трех видов:
    Первый вид — простые вычисления. Эти функции предназначены для выполнения операций над своими аргументами и 
    возвращают полученное в результате этих операций значение. Вычислительная функция является функцией "в чистом виде".
    В качестве примеров можно назвать стандартные библиотечные функции sqrt() и sin(), которые вычисляют квадратный корень
    и синус своего аргумента соответственно.

    Второй вид включает в себя функции, которые обрабатывают информацию и возвращают значение, которое показывает, успешно
    ли была выполнена эта обработка. Примером является библиотечная функция fclose(), которая закрывает файл. Если операция
    закрытия была завершена успешно, функция возвращает 0, а в случае ошибки она возвращает EOF.

    У функций последнего, третьего вида нет явно возвращаемых значений. В сущности, такие функции являются чисто процедурными
    и никаких значений выдавать не должны. Примером является exit(), которая прекращает выполнение программы. Все функции,
    которые не возвращают значение, должны объявляться как возвращающие значение типа void. Объявляя функцию как возвращающую
    значение типа void, вы запрещаете ее применение в выражениях, предотвращая таким образом случайное использование этой 
    функции не по назначению.

    Иногда функции, которые, казалось бы, фактически не выдают содержательный результат, все же возвращают какое-то 
    значение. Например, printf() возвращает количество выведенных символов. Если бы нашлась такая программа, которая на 
    самом деле проверяла бы это значение, то это было бы что - то необычное... Другими словами, хотя все функции, за 
    исключением относящихся к типу void, возвращают значения, вовсе не нужно стремиться использовать эти значения во что 
    бы то ни стало. Часто при обсуждении значений, возвращаемых функциями, возникает такой довольно распространенный 
    вопрос: "Неужели не обязательно присваивать возвращенное значение какой-либо переменной? Не повиснет ли оно где-нибудь 
    и не приведет ли это в дальнейшем к каким-либо неприятностям?" Отвечая на этот вопрос, повторим, что присваивание 
    отнюдь не является обязательным, причем отсутствие его не станет причиной каких - либо неприятностей. Если возвращаемое
    значение не входит ни в один из операторов присваивания, то это значение будет просто отброшено. Отметим также, что
    такое отбрасывание значения встречается очень часто. Проанализируйте следующую программу, в которой используется 
    функция mul():
    #include <stdio.h>

    int mul(int a, int b);

    int main(void)
    {
        int x, y, z;

        x = 10;   y = 20;
        z = mul(x, y);            //1
        printf("%d", mul(x, y));  //2
        mul(x, y);                //3

        return 0;
    }

    int mul(int a, int b)
    {
        return a * b;
    }
    В строке 1 значение, возвращаемое функцией mul(), присваивается переменной z. В строке 2 возвращаемое значение не 
    присваивается, но используется функцией printf(). И наконец, в строке 3 возвращаемое значение теряется, потому
    что не присваивается никакой из переменных и не используется как часть какого-либо выражения.






    ///////////Возвращаемые указатели
    Хотя с функциями, которые возвращают указатели, обращаются так же, как и с любыми другими функциями, все же будет 
    полезно познакомиться с некоторыми основными понятиями и рассмотреть соответствующий пример. Указатели не являются 
    ни целыми, ни целыми без знака. Они являются адресами в памяти и относятся к особому типу данных. Такая особенность 
    указателей определяется тем, что арифметика указателей(адресная арифметика) работает с учетом параметров базового типа.
    
    Например, если указателю на целое придать минимальное(ненулевое) приращение, то его текущее значение станет на четыре
    больше, чем предыдущее(при условии, что целые значения занимают 4 байта). Вообще говоря, каждый раз, когда значение 
    указателя увеличивается(уменьшается) на минимальную величину, то он указывает на последующий(предыдущий) элемент, 
    имеющий базовый тип указателя. Так как размеры разных типов данных могут быть разными, то компилятор должен знать
    тип данных, на которые может указывать указатель. Поэтому в объявлении функции, которая возвращает указатель, тип 
    возвращаемого указателя должен декларироваться явно. Например, нельзя объявлять возвращаемый тип как int*, если 
    возвращается указатель типа char* ! Иногда(правда, крайне редко) требуется, чтобы функция возвращала "универсальный" 
    указатель, т.е.указатель, который может указывать на данные любого типа. Тогда тип результата функции следует определить
    как void*.

    Чтобы функция могла возвратить указатель, она должна быть объявлена как возвращающая указатель на нужный тип. Например, 
    следующая функция возвращает указатель на первое вхождение символа, присвоенного переменной с, в строку s. Если этого 
    символа в строке нет, то возвращается указатель на символ конца строки('0').
    //Возвращает указатель на первое вхождение c в s
    char* match(char c, char* s)
    {
        while (c != *s && *s) s++;
        return(s);
    }

    Вот небольшая программа, в которой используется функция match():
    #include <stdio.h>

    char* match(char c, char* s);  //прототип

    int main(void)
    {
        char s[80], * p, ch;

        gets(s);
        ch = getchar();
        p = match(ch, s);

        if (*p)  //символ найден
            printf("%s ", p);
        else
            printf("Символа нет.");

        return 0;
    }
    Эта программа сначала считывает строку, а затем символ. Потом проводится поиск местонахождения символа в строке.
    При наличии символа в строке переменная p укажет на него, и программа выведет строку, начиная с найденного символа.
    Если символ в строке не найден, то p укажет на символ конца строки('0'), причем* p будет представлять логическое 
    значение ЛОЖЬ(false).В таком случае программа выведет сообщение Символа нет.
    
    
    
    
    
    
    ///////////Функция типа void
    Одним из применений ключевого слова void является явное объявление функций, которые не возвращают значений. Мы уже
    знаем, что такие функции не могут применяться в выражениях, и указание ключевого слова void предотвращает их случайное
    использование не по назначению. Например, функция print_vertical() выводит в боковой части экрана свой строчный аргумент
    по вертикали сверху вниз.

    Вот пример использования функции print_vertical():
    #include <stdio.h>

    void print_vertical(char* str);  //прототип


    int main(int argc, char* argv[])
    {
        if (argc > 1) print_vertical(argv[1]);

        return 0;
    }



    void print_vertical(char* str)
    {
        while (*str)
            printf("%c\n", *str++);
    }

    И еще одно замечание: в ранних версиях С ключевое слово void не определялось. Таким образом, в программах, написанных
    на этих версиях С, функции, которые не возвращали значений, просто имели по умолчанию тип int — и это несмотря на то, 
    что они не возвращали никаких значений!
    */    





    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/06/0606.htm
    printf("\n\n\n/////////// Что возвращает функция main()?\n");
    /*
    Функция main() возвращает целое число, которое принимает вызывающий процесс — обычно этим процессом является 
    операционная система. Возврат значения из main() эквивалентен вызову функции exit() с тем же самым значением. 
    Если main() нe возвращает значение явно, то вызывающий процесс получает формально неопределенное значение. На 
    практике же большинство компиляторов С автоматически возвращают 0, но если встает вопрос переносимости, то на 
    такой результат полагаться с уверенностью нельзя.
    */    






    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/06/0607.htm
    printf("\n\n\n/////////// Рекурсия\n");
    /*
    В языке С функция может вызывать сама себя. В этом случае такая функция называется рекурсивной. Рекурсия — это процесс
    определения чего-либо на основе самого себя, из-за чего рекурсию еще называют рекурсивным определением.

    Простым примером рекурсивной функции является factr(), которая вычисляет факториал целого неотрицательного числа. 
    Факториалом числа n (обозначается n!) называется произведение всех целых чисел, от 1 до n включительно (для 0, по
    определению, факториал равен 1.). Например, 3! — это 1×2×3, или 6. Здесь показаны factr() и эквивалентная ей функция,
    в которой используется итерация:

    //рекурсивная функция
    int factr(int n) {
        int answer;

        if (n == 1) return(1);
        answer = factr(n - 1) * n; //рекурсивный вызов
        return(answer);
    }

    //неркурсивная функция
    int fact(int n) {
        int t, answer;

        answer = 1;

        for (t = 1; t <= n; t++)
            answer = answer * (t);

        return(answer);
    }
    Нерекурсивное вычисление факториала, то есть вычисление с помощью fact(), выполняется достаточно просто. В этой функции
    в теле цикла, выполняющемся для t от 1 до n, вычисленное ранее произведение последовательно умножается на каждое из 
    этих чисел. (Значение факториала для 0 получается, конечно, с помощью оператора присваивания. Значение факториала для 
    1 также получается умножением не на ранее полученное произведение, а на заранее подготовленное число, тоже равное 1.)

    Работа же рекурсивной функции factr() чуть более сложная. Когда factr() вызывается с аргументом 0, то она сразу
    возвращает 1. Если же аргумент больше 0, то возвращается произведение factr(n - 1)* n. Чтобы вычислить значение этого
    выражения, factr() вызывается с аргументом n - 1. Это выполняется до тех пор, пока n не станет равным 0. Когда это 
    произойдет, вызовы функции начнут возвращать вычисленные ими значения факториалов.

    При вычислении 2! первый вызов factr() влечет за собой второй, теперь уже рекурсивный вызов с аргументом 1, который,
    в свою очередь, влечет третий, тоже рекурсивный вызов с аргументом 0. Этот вызов возвращает число 1, которое затем 
    умножается на 1, а потом на 2 (первоначальное значение n). Ответ в данном случае равен 2. Попробуйте самостоятельно 
    вычислить 3!. (Вам, возможно, захочется вставить в функцию factr() выражения printf(), чтобы видеть уровень каждого
    вывода, и то, какие будут промежуточные ответы.)

    Когда функция вызывает сама себя, новый набор локальных переменных и параметров размещается в памяти в стеке, а код 
    функции выполняется с самого своего начала, причем используются именно эти новые переменные.При рекурсивном вызове 
    функции новая копия ее кода не создается.Новыми являются только значения, которые использует данная функция. При 
    каждом возвращении из рекурсивного вызова старые локальные переменные и параметры извлекаются из стека, и сразу за 
    рекурсивным вызовом возобновляется работа функции.При использовании рекурсивных функций стек работает подобно 
    "телескопической" трубе, выдвигающейся вперед и складывающейся обратно.

    Хотя и кажется, что рекурсия предлагает более высокую эффективность, но на самом деле такое бывает достаточно редко.
    Использование рекурсии в программах зачастую не очень сильно уменьшают их размер кода и обычно только незначительно 
    увеличивает эффективность использования памяти.Кроме того, рекурсивные версии большинства программ могут выполняться
    несколько медленнее, чем их итеративные варианты, потому что при рекурсивных вызовах функций расходуются дополнительные
    ресурсы.Кроме того, большое количество рекурсивных вызовов функции может вызвать переполнение стека.Из - за того, что
    память для параметров функции и локальных переменных находится в стеке и при каждом новом вызове создается еще один
    набор этих переменных, то для переменных места в стеке может рано или поздно не хватить.Переполнение стека — вот
    обычная причина аварийного завершения программы, когда функция утрачивает контроль над рекурсивными обращениями.

    Главным преимуществом рекурсивных функций является то, что с их помощью упрощается реализация некоторых алгоритмов, 
    а программа становится понятнее. Например, алгоритм быстрой сортировки(описанный в части IV) трудно реализовать 
    итеративным способом. Кроме того, для некоторых проблем, особенно связанных с искусственным интеллектом, больше 
    подходят рекурсивные решения. И наконец, некоторым людям легче думать рекурсивными категориями, чем итеративными.

    В тексте рекурсивной функции обязательно должен быть выполнен условный оператор, например if, который при определенных 
    условиях вызовет завершение функции, т.е.возврат, а не выполнит очередной рекурсивный вызов. Если такого оператора нет,
    то после вызова функция никогда не сможет завершить работы. Распространенной ошибкой при написании рекурсивных функций
    как раз и является отсутствие в них условного оператора. При создании программ не отказывайтесь от функции printf(); 
    тогда вы сможете увидеть, что происходит на самом деле и сможете прервать выполнение, когда обнаружите ошибку.
    */ 






    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/06/0608.htm
    printf("\n\n\n/////////// Прототип функции\n");
    /*
    В современных, правильно написанных программах на языке С каждую функцию перед использованием необходимо объявлять. 
    Обычно это делается с помощью прототипа функции. В первоначальном варианте языка С прототипов не было; но они были 
    введены уже в Стандарт С89. Хотя прототипы формально не требуются, но их использование очень желательно. (Впрочем, 
    в C++ прототипы обязательны!) Во всех примерах этой книги имеются полные прототипы функций. Прототипы дают компилятору
    возможность тщательнее выполнять проверку типов, подобно тому, как это делается в таких языках как Pascal. Если 
    используются прототипы, то компилятор может обнаружить любые сомнительные преобразования типов аргументов, необходимые
    при вызове функции, если тип ее параметров отличается от типов аргументов. При этом будут выданы предупреждения обо 
    всех таких сомнительных преобразованиях. Компилятор также обнаружит различия в количестве аргументов, использованных 
    при вызове функции, и в количестве параметров функции.

    В общем виде прототип функции должен выглядеть таким образом:
    тип имя_функции(тип имя_парам1, тип имя_парам2, ..., имя_парамN);

    Использование имен параметров не обязательно. Однако они дают возможность компилятору при наличии ошибки указать 
    имена, для которых обнаружено несоответствие типов, так что не поленитесь указать этих имен — это позволит сэкономить
    время впоследствии.


    Следующая программа показывает, насколько ценными являются прототипы функций. В ней выводится сообщение об ошибке, 
    происходящей из-за того, что программа содержит попытку вызова sqr_it() с целым аргументом, в то время как требуется 
    указатель на целое.

    //В этой программе используется прототип функции чтобы обеспечить тщательную проверку типов.
    void sqr_it(int* i); //прототип

    int main(void)
    {
        int x;

        x = 10;
        sqr_it(x);  //несоответствие типов

        return 0;
    }

    void sqr_it(int* i)
    {
        *i = *i * *i;
    }

    В качестве прототипа функции может также служить ее определение, если оно находится в программе до первого вызова 
    этой функции. Вот, например, правильная программа:
    #include <stdio.h>

    //Это определение будет также служить и прототипом внутри этой программы
    void f(int a, int b)    //определение функции
    {
        printf("%d ", a % b);
    }

    int main(void)
    {
        f(10, 3);   //вызов функции

        return 0;
    }
    В этом примере специальный прототип не требуется; так как функция f() определена еще до того, как она начинает 
    использоваться в main(). Хотя определение функции и может служить ее прототипом в малых программах, но в больших такое
    встречается редко — особенно, когда используется несколько файлов. В программах, приведенных в качестве примеров в этой
    книге, для каждой функции автор старался приводить отдельный прототип потому, что именно так обычно и пишется код на 
    языке С.
    Единственная функция, для которой не требуется прототип — это main(), так как это первая функция, вызываемая в начале
    работы программы.



    Имеется небольшая, но важная разница в том, как именно в С и C++ обрабатывается прототип функции, не имеющей параметров.
    В C++ пустой список параметров указывается полным отсутствием в прототипе любых параметров. Например,
    int f(); //Прототип C++ для функции, не имеющей параметров

    Однако в С это выражение означает нечто другое. Из-за необходимости придерживаться совместимости с первоначальной 
    версией С пустой список параметров сообщает, что просто о параметрах не предоставлено никакой информации. Что касается
    компилятора, то для него эта функция может иметь несколько параметров, а может не иметь ни одного. (Такой оператор 
    называется старомодным объявлением функции, он описан в следующем разделе.)
    Если функция в языке С не имеет параметров, то в ее прототипе внутри списка параметров стоит только ключевое слово void.
    Вот, например, прототип функции f() в том виде, в каком он должен быть в программе на языке С:
    float f(void);

    Таким образом компилятор узнает, что у функции нет параметров, и любое обращение к ней, в котором имеются аргументы, 
    будет считаться ошибкой. В C++ использование ключевого слова void внутри пустого списка параметров также разрешено, но 
    считается излишним.

    Прототипы функций позволяют "отлавливать" ошибки еще до запуска программы. Кроме того, они запрещают вызов функций при 
    несовпадении типов(т.е.с неподходящими аргументами) и тем самым помогают проверять правильность программы.

    И напоследок хотелось бы сказать следующее: так как в ранних версиях С синтаксис прототипов в полном объеме не 
    поддерживался, то в С прототипы формально не обязательны. Такой подход необходим для совместимости с С-кодом, 
    созданным еще до появления прототипов. Но если старый С-код переносится в C++, то перед компиляцией этого кода в него 
    необходимо добавить полные прототипы функций. Помните, что хотя прототипы в С не обязательны, но они обязательны в C++.
    Это значит, что каждая функция в программе на языке C++ должна иметь полный прототип. Поэтому при написании программ
    на С в них указываются полные прототипы функций — именно так поступает большинство программистов, работающих на этом 
    языке.






    ///////////Старомодные объявления функций
    В "ранней молодости" языка С, еще до создания прототипов функций, все - таки была необходимость сообщить компилятору о
    типе результата функции, чтобы при вызове функции был создан правильный код. (Так как размеры разных типов данных 
    разные, то размер типа результата надо было знать еще до вызова функции.) Это выполнялось с помощью объявления функции,
    не содержащего никакой информации о параметрах. С точки зрения теперешних стандартов этот старомодный подход является
    архаичным. Однако его до сих пор можно найти в старых кодах. По этой причине важно понимать, как он работает.

    Согласно старомодному подходу, тип результата и имя функции, как показано ниже, объявляются почти что в начале 
    программы:
    #include <stdio.h>

    double div();  //старомодное объявление функции

    int main(void)
    {
        printf("%f", div(10.2, 20.0));

        return 0;
    }

    double div(double num, double denom)
    {
        return num / denom;
    }
    Старомодное объявление типа функции сообщает компилятору, что функция div() возвращает результат типа double. Это 
    объявление позволяет компилятору правильно генерировать код для вызовов этой функции. Однако оно ничего не говорит 
    о параметрах div().

    Общий вид старомодного оператора объявления функции такой:
    спецификатор_типа имя_функции();

    Обратите внимание, что список параметров пустой. Даже если функция принимает аргументы, то ни один из них не 
    перечисляется в объявлении типа.
    Как уже говорилось, старомодное объявление функции устарело и не должно использоваться в новом коде. Кроме того, оно
    несовместимо с C++.
    
    
    
    
    
    ///////////Прототипы старомодных библиотечных функций (ЖЕНЯ)
    Любая стандартная библиотечная функция в программе должна иметь прототип. Поэтому для каждой такой функции необходимо
    ввести соответствующий заголовок. Все необходимые заголовки предоставляются компилятором С. В системе программирования
    на языке С библиотечными заголовками(обычно) являются файлы, в именах которых используется расширение.h. В заголовке
    имеется два основных элемента: любые определения, используемые библиотечными функциями, и прототипы библиотечных 
    функций. Например, почти во все программы из этой книги включается файл <stdio.h>, потому что в этом файле находится 
    прототип для printf(). Заголовки для стандартных функций описаны в части II.
    */






    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/06/0609.htm
    printf("\n\n\n/////////// Объявление списков параметров переменной длины\n");
    /*
    Можно вызвать функцию, которая имеет переменное количество параметров. Самым известным примером является printf(). 
    Чтобы сообщить компилятору, что функции будет передано заранее неизвестное количество аргументов, объявление списка 
    ее параметров необходимо закончить многоточием. Например, следующий прототип указывает, что у функции func() будет 
    как минимум два целых параметра и после них еще некоторое количество (в том числе и 0) параметров:
    int func(int a, int b, ...);

    В любой функции, использующей переменное количество параметров, должен быть как минимум один реально существующий 
    параметр. Например, следующее объявление неправильное:
    int func(...); //ошибка
    */    






    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/06/0610.htm
    printf("\n\n\n/////////// Правило неявного int\n");
    /*
    Первоначальная версия С отличалась особенностью, которую иногда называют правилом "неявного int" (а также правилом 
    "int по умолчанию"). Это правило состоит в том, что если спецификатор базового типа явно не указан, то подразумевается
    спецификатор int. Это правило было включено в стандарт С89, но в С99 это правило не вошло. (И, кроме того, не
    поддерживается в языке C++.) Так как правило "неявного int" теперь устарело, то в этой книге оно не используется. 
    Однако из-за того, что во многих действующих программах это правило еще используется, то о нем следует немного рассказать.

    Больше всего правило "неявного int" использовалось при определении типа результата функции, т.е. при определении 
    возвращаемого типа. Много лет назад большинство программистов, писавших программы на С, пользовались этим правилом,
    когда писали код функций, возвращавших результат типа int. Поэтому много лет назад такая функция, как

    int f(void) {
      // ... //
        return 0;
    }

    часто могла быть написана таким образом:
    f(void) {       //int - возвращаемый тип по умолчанию
      // ... //
        return 0;
    }
    В первом случае возвращаемый тип int определяется явно. Во втором же — подразумевается по умолчанию.

    Правило "неявного int" применяется не только к значениям, возвращаемым функциями(хотя это было самое распространенное
    применение). Например, для С89 и более ранних вариантов С правильной является следующая функция:

    //по умолчанию возвращается тип int, такой же тип, как и у параметров a и b
    f(register a, register b) {
        register c; //переменная c по умолчанию также будет иметь тип int

        c = a + b;

        printf("%d", c);

        return c;
    }
    Здесь возвращаемым типом по умолчанию для f() является int; т.е. такой же тип по умолчанию, как и у параметров а и b,
    и у локальной переменной c.

    Помните, что правило "неявного int" не поддерживается в С99 или C++.Таким образом, использовать его в программах, 
    совместимых с С89, не рекомендуется. Лучше всего явно определять каждый тип, используемый в вашей программе.
    */    





    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/06/0611.htm
    printf("\n\n\n/////////// Старомодные и современные объявления параметров функций\n");
    /*
    В ранних версиях С использовался синтаксис объявления параметров, отличающийся от того, который используется в 
    современных версиях этого языка, включая С89, С99 и C++. Такой ранний синтаксис иногда называется классическим. 
    В отличие от него, синтаксис, который используется в этой книге, называется современным. В стандартном С поддерживаются
    оба синтаксиса, но настоятельно рекомендуется современный. (А в C++ поддерживается только современный синтаксис
    объявления параметров.) Однако старомодный синтаксис надо знать, потому что он до сих пор используется во многих 
    старых программах, написанных на языке С.

    Старомодное объявление параметров функции состоит из двух частей: списка параметров внутри круглых скобок, следующих
    за именем функции, а также объявлений параметров, находящихся между закрывающей круглой скобкой и открывающей фигурной
    скобкой функции. В общем виде старомодное определение параметров должно выглядеть таким образом:

    тип имя_функции(парм1, парм2,...пармN)
    тип парм1;
    тип парм2;
    .
    .
    .
    тип пармN;
    {
      код функции
    }

    Например, такое современное объявление, как
    float f(int a, int b, char ch)
    {
      // ... //
    }

    в старомодном виде будет выглядеть следующим образом:
    float f(a, b, ch)
    int a, b;
    char ch;
    {
        // ... //
    }
    Обратите внимание, что старомодный синтаксис позволяет в списке, стоящем за именем типа, объявить более одного параметра.
    На заметку: Старомодный синтаксис объявления параметров признан устаревшим для стандартного С и не поддерживается в
    языке C++.
    */  






    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/06/0612.htm
    printf("\n\n\n/////////// Ключевое слово inline\n");
    /*
    В Стандарте С99 было введено ключевое слово inline, применяемое к функциям. Оно подробно рассматривается в части II, а
    здесь мы дадим только его краткое описание. Ставя перед объявлением функции ключевое слово inline, вы даете компилятору
    указание оптимизировать вызовы этой функции. Обычно это означает, что такие вызовы желательно заменить последовательной
    вставкой кода самой функции. Однако inline является всего лишь запросом к компилятору и может быть проигнорировано.

    На заметку	Спецификатор inline также поддерживается в языке C++.
    */    













    printf("\n\n\n/////////// 000\n");
    /*

    */

    return 0;
}
