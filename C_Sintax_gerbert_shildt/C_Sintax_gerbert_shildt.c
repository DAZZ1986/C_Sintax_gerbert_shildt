#include <stdio.h>        // подключаем заголовочный файл stdio.h
#include <locale.h>





int main(void)
{
    char* locale = setlocale(LC_ALL, "");
    printf("///////// C_Sintax_gerbert_shildt\n");









    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/02/0204.htm
    printf("\n\n\n/////////// Переменные\n\n");
    // идентификатор - это переменная
    int i, j, k; //объявление переменной
    i = 30;      //инициализация переменной

    printf("\n\n\n/////////// Где объявляются переменные\n");
    /* 
    Объявление переменных может быть расположено в трех местах: 
    - внутри функции - ЛОКАЛЬНЫЕ
    - в определении параметров функции - ФОРМАЛЬНЫЕ
    - и вне всех функций. Это места объявлений соответсвенно локальных, формальных параметров функций и 
    глобальных переменных. 
    */

    printf("\n\n\n/////////// Локальные переменные\n");
    /* 
    Переменные, объявленные внутри функций, называются локальными переменными. В некоторых книгах по С они
    называются динамическими переменными[2]. В этой книге используется более распространенный термин 
    локальная переменная. Локальную переменную можно использовать только внутри блока, в котором она 
    объявлена. Иными словами, локальная переменная невидима за пределами своего блока. (Блок программы — 
    это описания и инструкции, объединенные в одну конструкцию путем заключения их в фигурные скобки.)

    Локальные переменные существуют только во время выполнения программного блока, в котором они 
    объявлены, создаются они при ВХОДЕ в блок, а разрушаются — при ВЫХОДЕ из него. Более того, переменная,
    объявленная в одном блоке, не имеет никакого отношения к переменной с тем же именем, объявленной в 
    другом блоке.

    Чаще всего блоком программы, в котором объявлены локальные переменные, является функция. Рассмотрим,
    например, следующие две функции:
    void func1(void)
    {
        int x = 10;   //компилятор не ругается
    }

    void func2(void)
    {
        int x = -199;   //компилятор не ругается
    }
    Целая переменная х объявлена дважды: один раз в func1() и второй — в func2(). При этом переменная х 
    в одной функции никак не связана и никак не влияет на переменную с тем же именем в другой функции. 
    Это происходит потому, что локальная переменная видима только внутри блока, в котором она объявлена,
    за пределами этого блока она невидима.

    В языке С есть ключевое слово auto (спецификатор класса памяти), которое можно использовать в 
    объявлении локальной переменной. Однако так как по умолчанию предполагается, что все переменные, не 
    являющиеся глобальными, являются динамическими, то ключевое слово auto почти никогда не используется,
    а поэтому в примерах в данной книге отсутствует.

    Из соображений удобства и в силу устоявшейся традиции все локальные переменные функции чаще всего 
    объявляются в самом начале функции, сразу после открывающейся фигурной скобки. Однако можно объявить
    локальную переменную и внутри блока программы (блок функции — это частный случай блока программы). 
    Например:
    void f(void)
    {
          int t;

          scanf("%d%*c", &t);

          if(t==1) {
            char s[80];  // эта переменная создается только при входе в этот блок 
            printf("Введите имя:");
            gets(s);
            //некоторые операторы ... 
        }

        //здесь переменная s невидима 
    }

    В этом примере локальная переменная s создается при входе в блок if и разрушается при выходе из него.
    Следовательно, переменная s видима только внутри блока if и не может быть использована ни в каких 
    других местах, даже если они находятся внутри функции, содержащей этот блок.

    Объявление переменных внутри блока программы помогает избежать нежелательных побочных эффектов.
    Переменная не существует вне блока, в котором она объявлена, следовательно, "посторонний" участок 
    программы не сможет случайно изменить ее значение.

    Если имена переменных, объявленных во внутреннем и внешнем блоках совпадают,  то переменная 
    внутреннего блока прячет переменную внешнего блока. Рассмотрим следующий пример:

    int main(void)
    {
      int x = 10;    // внешняя x

      if(x == 10) {
        int x;      // эта x прячет внешнюю x

        x = 99;
        printf("Внутренняя x: %d\n", x);
    }

    printf("Внешняя x: %d\n", x);
    return 0;
    }

    Результат выполнения программы следующий :
    Внутренняя х : 99
    Внешняя х : 10





    В стандарте С89 все локальные переменные должны быть объявлены в начале блока, до любого выполнимого
    оператора. Например: (функция вызовет ошибку компиляции в С89)

    void f(void)
    {
      int i;  //объявили переменную
      i = 10; //инициализировали переменную

      int j;  //тут ошибка, тк тут мы объявили переменную, после того как, что либо инициализировали, 
              //а как мы видим, выше мы инициалзировали переменную i. Тоесть сначала нужно всё объявить
              //и толлько потом инициализировать.
      j = 20; //инициализировали переменную
    }
    А в С99 (и в C++) эта функция будет работать, так как там главное чтобы переменная инпользовалась 
    после ее объявления. И не важно инициализировалась ли ранее какая либо другая переменная, главное,
    чтобы та переменная с которой мы работаем была объявлена до ее использования.


    Static
    Так как локальные переменные создаются и уничтожаются при каждом входе и выходе из блока, их 
    значение теряется каждый раз, когда программа выходит из блока. Это необходимо учитывать при вызове
    функции. Локальная переменная создается при входе в функцию и разрушается при выходе из нее. 
    Это значит, что локальная переменная не сохраняет свое значение в период между вызовами (однако 
    можно дать указание компилятору сохранить значение локальной переменной, для этого нужно объявить 
    ее с модификатором static).

    По умолчанию локальные переменные хранятся в стеке. Стек — динамически изменяющаяся область памяти. 
    Вот почему в общем случае локальные переменные не сохраняют свое значение в период между вызовами 
    функций.

    Локальные переменные можно инициализировать каким-либо заранее заданным значением. Это значение 
    будет присвоено переменной каждый раз при входе в тот блок программы, в котором она объявлена. 
    Например, следующая программа напечатает число 10 десять раз:

    #include <stdio.h>

    void f(void);

    int main(void)
    {
      int i;
      for(i=0; i<10; i++)  f();
      return 0;
    }

    void f(void)
    {
      int j = 10;
      printf("%d ", j);
      j++;  // этот оператор не влияет на результат
    }
    */





    printf("\n\n\n/////////// Формальные параметры функции\n");
    /*
    Если функция имеет аргументы, значит должны быть объявлены переменные, которые примут их значения. 
    Эти переменные называются формальными параметрами функции. Внутри функции они фигурируют как обычные
    локальные переменные. Как показано в следующем фрагменте программы, они объявляются после имени 
    функции внутри круглых скобок.

    // Возвращает 1, если в строке s содержится символ c, в противном случае возвращает 0
    int is_in(char* s, char c)
    {
        while (*s)
            if (*s == c) return 1;
            else s++;

        return 0;
    }

    Функция is_in() имеет два параметра: s и с, она возвращает 1, если символ, записанный в переменной с,
    входит в строку s, в противном случае она возвращает 0.

    Внутри функции формальные параметры ничем не отличаются от обычных локальных переменных, единственное
    их отличие состоит в том, что при ВХОДЕ в функцию они получают значения аргументов. Можно, например,
    присваивать параметру какое-либо значение или использовать его в выражении. Необходимо помнить, 
    что, как и локальные переменные, формальные параметры тоже являются динамическими переменными и, 
    следовательно, разрушаются при выходе из функции.
    */





    printf("\n\n\n/////////// Глобальные переменные\n");
    /*
    В отличие от локальных, глобальные переменные видимы и могут использоваться в любом месте программы. 
    Они сохраняют свое значение на протяжении всей работы программы. Чтобы создать глобальную переменную,
    ее необходимо объявить за пределами функции. Глобальная переменная может быть использована в любом 
    выражении, независимо от того, в каком блоке это выражение используется.

    В следующем примере переменная count объявлена вне каких бы то ни было функций. Ее объявление 
    расположено перед main(), однако, оно может находиться в любом месте перед первым использованием 
    этой переменной, но только не внутри функции! Объявлять глобальные переменные рекомендуется в верхней
    части программы!

    #include <stdio.h>
    int count;  //глобальная переменная count

        void func1(void);
        void func2(void);

        int main(void)
        {
            count = 100;
            func1();
            return 0;
        }

        void func1(void)
        {
            int temp;
            temp = count;
            func2();
            printf("count равно %d", count); // напечатает 100
        }

        void func2(void)
        {
            int count;
            for (count = 1; count < 10; count++)
                putchar('.');
        }

        Внимательно посмотрите на эту программу. Обратите внимание на то, что func1(), и func2() могут 
        использовать глобальную переменную count. Но, в func2() глобальную переменную count использовать 
        не получится, так как в ней объявлена локальная переменная с тем же именем. Когда внутри func2()
        происходит обращение к переменной count, то происходит обращение к локальной переменной, а не к  
        глобальной. Таким образом, выполняется следующее правило: если локальная и глобальная переменные
        имеют одно и то же имя, то при обращении к ней внутри блока, в котором объявлена локальная 
        переменная, происходит ссылка на локальную переменную, а на глобальную переменную это никак не 
        влияет.

        Глобальные переменные хранятся в отдельной фиксированной области памяти, созданной компилятором 
        специально для этого. Глобальные переменные используются в тех случаях, когда разные функции 
        программы используют одни и те же данные. Однако рекомендуется избегать излишнего использования 
        глобальных переменных, потому что они занимают память в течение всего времени выполнения 
        программы, а не только тогда, когда они необходимы. Кроме того, и это еще более важно, 
        использование глобальной переменной делает функцию менее универсальной, потому что в этом случае
        функция использует нечто, определенное вне ее. К тому же большое количество глобальных переменных
        легко приводит к ошибкам в программе из-за нежелательных побочных эффектов. При увеличении 
        размера программы серьезной проблемой становится случайное изменение значения переменной где-то
        в другой части программы, а когда глобальных переменных много, предотвратить это очень трудно.
    */






    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/02/0205.htm
    printf("\n\n\n/////////// Четыре типа областей видимости\n");
    /*
    Стандарт С определяет четыре типа областей видимости[1] идентификаторов:

    1. Область действия - файл (имя, объявленное вне всех блоков и классов, можно использовать в 
    транслируемом файле, содержащем это объявление; такие имена называются глобальными (global)).
    Область видимости
    Начинается в начале файла (единица трансляции) и кончается в конце файла. Такую область видимости 
    имеют только идентификаторы, объявленные вне функции. Эти идентификаторы видимы в любом месте файла. 
    Переменные с этой областью видимости являются глобальными.

    2. Область действия - блок.
    Область видимости
    Начинается открывающейся фигурной скобкой "{" блока и кончается с его закрытием скобкой "}". Эту 
    область видимости имеют также параметры функции. Переменные, имеющие такую область видимости, 
    являются локальными в своем блоке.

    3. Область действия - прототип функции.
    Область видимости
    Идентификаторы, объявленные в прототипе функции, видимы внутри прототипа.


    4. Область действия - функция (имена объявленные в функции, могут быть использованы только в теле 
    функции).
    Область видимости
    Начинается открывающейся фигурной скобкой "{" функции и кончается с ее закрытием скобкой "}". 
    Такую область видимости имеют только метки. Метка используется оператором goto и должна находится 
    внутри той же функции.

    [1]Область видимости называется также контекстом или областью действия(имен.)
    */






    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/02/0206.htm
    printf("\n\n\n/////////// Квалификатор типа (доступность и модифицируемость переменной(const, volatile, restrict))\n");
    /*
    В языке С определяются квалификаторы типа[1], указывающие на доступность и модифицируемость 
    переменной. Стандарт С89 определяет два квалификатора: const и volatile. (C99 добавляет третий, 
    restrict, описанный в части II.) Квалификатор типа должен предшествовать имени типа, который он 
    квалифицирует (уточняет). 

    [1]Называются также классификаторами, описателями, спецификаторами.
    */

    printf("\n\n\n/////////// Квалификатор const\n");
    /*
    МОЁ - изменение возможно только при внешнем воздействии, это и гарантирует квалификатор const. 
    
    Переменная, к которой в объявлении (декларации) применен квалификатор const, не может изменять свое 
    значение. Ее можно только инициализировать, то есть присвоить ей значение в начале выполнения 
    программы. Компилятор может поместить переменную этого типа в постоянное запоминающее устройство, 
    так называемое ПЗУ (ROM, read-only memory). Например, в объявлении
    const int a=10;
    создается переменная с именем а, причем ей присваивается начальное значение 10, которое в дальнейшем 
    в программе изменить никак нельзя.

    Квалификатор const часто используется для того, чтобы предотвратить изменение функцией объекта, на 
    который указывает аргумент функции. Без него при передаче в функцию указателя эта функция может 
    изменить объект, на который он указывает. Однако если в объявлении параметра-указателя применен 
    квалификатор const, функция не сможет изменить этот объект. В следующем примере функция sp_to_dash()
    печатает минус вместо каждого пробела в строке, передаваемой ей как аргумент. То есть строка 
    "тестовый пример" будет напечатана как "тестовый-пример". Применение квалификатора const в объявлении
    параметра функции гарантирует, что внутри функций объект, на который указывает параметр функции, не
    будет изменен.

    #include <stdio.h>

    void sp_to_dash(const char *str);   //это прототип функции

    int main(void)
    {
      sp_to_dash("тестовый пример");
      return 0;
    }

    void sp_to_dash(const char *str)
    {
      while(*str) {
        if(*str== ' ') printf("%c", '-');
        else printf("%c", *str);
        str++;
      }
    }

    Если написать sp_to_dash() таким образом, что внутри функции строка изменяется, то еще на этапе 
    компиляции в программе будет обнаружена ошибка. Например, на этапе компиляции возникнет ошибка, 
    если написать так:

    // Неправильный пример:
    void sp_to_dash(const char* str)
    {
        while (*str) {
            if (*str == ' ') *str = '-'; // это не правильно - тк мы не можем в строку что либо 
                                         //присваивать/перезаписывать тк она не изменяема.
            printf("%c", *str);
            str++;
        }
    }

    Квалификатор const используется в объявлениях параметров многих функций стандартной библиотеки.
    Например, прототип функции strlen() выглядит так:
    size_t strlen(const char* str);

    Применение квалификатора const в объявлении str гарантирует, что функция не изменит строку, на 
    которую указывает str. Если функция стандартной библиотеки не предназначена для изменения аргумента, 
    то практически всегда в объявлении указателя на аргумент применяется квалификатор const.

    Программист тоже может применять квалификатор const для того, чтобы гарантировать сохранность объекта.
    Но следует помнить, что переменная, даже если к ней применен квалификатор const, может быть изменена
    в результате какого - нибудь внешнего по отношению к программе воздействия. Например, ей может быть
    присвоено значение каким либо устройством. Однако применение квалификатора const в объявлении 
    переменной гарантирует, что ее изменение может произойти только в ходе внешнего по отношению к 
    программе события.
    */


    printf("\n\n\n/////////// Квалификатор volatile\n");
    /*
    МОЁ - volatile 
    1. Говорит компилятору, что данное значение может изменяться в любой момент как программно, так и 
    аппаратно, когда угодно и поэтому компилятор не имеет право ее выбрасывать, обновлять самостоятельно,
    потому что программист может изменить ее в любой момент. Тоесть volatile позволяет использовать
    системный таймер и при этом у нас данная переменная не удаляется.
    2. Суда же относятся прерывания
    н/п если бы иы работали в нескольких потоках, тог в этом случае volatile говорил бы компилятору, что
    нужно работать конкретно с данной переменной и никак не делать никаких ее джубликатов, тоесть оба
    потока одновременно обращались бы к данной переменной и изменяли бы конккретно ее, а в ней бы всегда 
    хранилось актуальное значение.
    

    Шилдт
    Квалификатор volatile указывает компилятору на то, что значение переменной может измениться независимо
    от программы, т.е. вследствие воздействия еще чего-либо, не являющегося оператором программы. 
    Например, адрес глобальной переменной можно передать в подпрограмму операционной системы, следящей 
    за временем, и тогда эта переменная будет содержать системное время. В этом случае значение 
    переменной будет изменяться без участия какого-либо оператора программы. 
    
    Знание таких подробностей важно потому, что большинство компиляторов С автоматически оптимизируют 
    некоторые выражения, предполагая при этом неизменность переменной, если она не встречается в левой 
    части оператора присваивания. В этом случае при очередной ссылке на переменную может использоваться 
    ее предыдущее значение. Некоторые компиляторы изменяют порядок вычислений в выражениях, что может 
    привести к ошибке, если в выражении присутствует переменная, вычисляемая вне программы. Квалификатор 
    volatile предотвращает такие изменения программы.

    Квалификаторы const и volatile могут применяться и совместно. Например, если 0x30 — адрес порта, 
    значение в котором может задаваться только извне, то следующее объявление предотвратит всякую 
    возможность нежелательных побочных эффектов:

    const volatile char *port = (const volatile char *) 0x30;//тоесть тут мы присвиваем номер порта, 
                                                             //единожды и из вне, хотя при volatile можно
                                                             //менять значение аппаратно, извне и 
                                                             //программно. Поэтому хз?
    */






    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/02/0207.htm
    printf("\n\n\n/////////// Спецификаторы класса памяти\n");
    /*
    Стандарт С поддерживает четыре спецификатора класса памяти:
    extern - внешнее связывание, доступ во всей программе. Объявление extern сообщает компилятору, что 
             переменные определены в другом месте. И что эти переменные будут объявлены в файле позже.
             extern позволяет объявить переменную, не определяя ее.
    static - придает внутренее связывание, тоесть доступ внутри файла.
    register - 
    auto - списан.


    Эти спецификаторы сообщают компилятору, как он должен разместить соответствующие переменные в памяти. 
    Общая форма объявления переменных при этом такова:
    Синтаксис:  спецификатор_класса_памяти   тип   имя_переменой;
    Спецификатор класса памяти в объявлении всегда должен стоять первым.

    Связывание - по умолчанию для простых переменных int i, применяется внешнее связывание, тоесть доступ
    из других файлов.
    В языке С, при редактировании связей, к переменной может применяться одно из трех связываний: 
    внутреннее, внешнее или же связывание не применяется.
    1. Внешнее связывание - можно получить доступ из других файлов. Применяется к именам функций и 
    глобальным переменным, не обязательно помеченными как extern!!!! После компоновки они будут доступны во 
    всех файлах, составляющих программу.
    2. Внутреннее связывание - применяется к сущностям, объявленным со спецификатором static в рамках 
    одного .с файла(не включая .h). Тоесть в рамках одной единицы компиляции, это файл по простому.
    После компоновки они будут доступны только внутри файла, в котором они объявлены. 
    3. Связывание не применяется - к локальным переменным, поэтому они доступны только внутри своих блоков.
    */


    printf("\n\n\n/////////// Спецификатор extern\n");
    /*
    Спецификатор extern указывает на то, что к объекту применяется внешнее связывание, именно поэтому они
    будут доступны во всей программе. 
    Далее нам понадобятся чрезвычайно важные понятия объявления и определения: 
     -объявление (декларация) - объявляет тип и имя объекта. 
     -определение(описание, инициализация) - выделяет для объекта участок памяти, где он будет находиться. 
    Один и тот же объект может быть объявлен неоднократно в разных местах и файлах со спецификатором 
    extern, но определен он может быть только один раз!!!

    В большинстве случаев объявление переменной является в то же время и ее определением. Однако, если 
    перед именем переменной стоит спецификатор extern, то объявление переменной может и не быть ее 
    определением. Таким образом, если нужно сослаться на переменную, определенную в другой части 
    программы (в другом файле или в том же), необходимо объявить ее как внешнюю (extern).

    Приведем пример использования спецификатора extern. Обратите внимание, что глобальные переменные
    first и last объявлены после main().

    #include <stdio.h>

    int main(void)
    {
      extern int first, last; // используются глобальные переменные
      printf("%d %d", first, last);
      return 0;
    }

    // описание глобальных переменных first и last
    int first = 10, last = 20;  

    Программа напечатает 10, 20. Объявление extern сообщает компилятору, что переменные first и last 
    определены в другом месте, поэтому программа компилируется без ошибки, несмотря даже на то, что 
    first и last используются до своего описания(определения).

    Обратите внимание, в этом примере объявление переменных со спецификатором extern необходимо только
    потому, что они не были объявлены до main(). Если бы их объявление встретилось перед main(), то в
    объявлении со спецификатором extern не было бы необходимости.
    _____________________________________________________________
    При компиляции выполняются следующие правила. Если компилятор находит переменную, не объявленную
    внутри блока, он ищет ее объявление во внешних блоках. Если не находит ее и там, то ищет среди
    объявлений глобальных переменных. В предыдущем примере, если бы не было объявления extern, компилятор
    не нашел бы first и last среди глобальных переменных, потому что они объявлены после main(), а как 
    мы знаем, глобальные переменные объявляются в начале файла! Здесь спецификатор extern сообщает
    компилятору, что эти переменные будут объявлены в файле позже.

    Как сказано выше, спецификатор extern позволяет объявить переменную, не определяя ее. Но если в
    объявлении со спецификатором extern определить переменную, то это объявление становится также
    и определением. При этом программист обязательно должен учитывать, что объект может иметь много
    объявлений, но лишь одно определение(описание).

    Спецификатор extern играет большую роль в программах, состоящих из многих файлов. В языке С программа
    может быть записана в нескольких файлах, которые компилируются раздельно, а затем компонуются в одно
    целое. В этом случае необходимо как-то сообщить всем файлам о глобальных переменных программы. Самый
    лучший способ сделать это — определить(описать) все глобальные переменные в одном файле и объявить их
    со спецификатором extern в остальных файлах, как показано на рис. 2.1.

    От Жени - первым написал int playerAge, тк переменная по умолчанию имеет внешнее связывание, и потом
    в другом файле ему понадобились эти данные и он написал extern int playerAge, тем самым сказал 
    компилятору не нужно выделять новый участок памяти, а иди ищи эту переменную она существует и тут
    происходит обращение к той же ячейки памяти, новая память не выделяется, переменная не копируется,
    по сути обращается к той же самой переменной.
    Дополнение: в файле 1 он объявил и определил, в файле 2 повторно объявил.
    ГЛАНВАЯ цель не засорять глобальное пространство имен! У меня 
    Extern в других файлах мы пишем для того чтобы мы не создали новую переменную с таким же именем в 
    данном файле,а обратились к переменной которую мы создали вне данного файла!!!!!!!!!!!!!!!!!!!!!!!!
    И данная глоб. переменная extern должна быть определена только 1 раз!!!!!!!!!!!!!!!!!!!

    Рис. 2.1.Использование глобальных переменных в раздельно компилируемых модулях

    Файл 1                    Файл 2
    int playerAge, y;         extern int playerAge, y;
    char ch;                  extern char ch;

    int main(void)            void func22(void)
    {
        {
            // ... //                 playerAge = y / 10;
        }
    }

    void func1(void)          void func23(void)
    {
        {
            playerAge = 123;           y = 10;
        }
    }

    Во втором файле спецификатор extern сообщает компилятору, что эти переменные описаны в других
    файлах. Таким образом компилятор узнает имена и типы переменных, размещенных в другом месте, и может
    отдельно компилировать второй файл, ничего не зная о первом. При компоновке этих двух модулей все
    ссылки на глобальные переменные будут разрешены.  

    На практике программисты обычно включают объявления extern в заголовочные файлы, которые просто
    подключаются к каждому файлу исходного текста программы. Это более легкий путь, который к тому же
    приводит к меньшему количеству ошибок, чем повторение этих объявлений вручную в каждом файле.
    */


    printf("\n\n\n/////////// Спецификатор static\n");
    /*
    Переменные, объявленные со спецификатором static, хранятся постоянно внутри своей функции или файла.
    В отличие от глобальных переменных они невидимы за пределами своей функции или файла, но они 
    сохраняют свое значение между вызовами. Эта особенность делает их полезными в общих функциях и 
    библиотечных функциях, которые будут использоваться другими программистами. 
    Спецификатор static воздействует на локальные и глобальные переменные по разному.
    
    
    
    Локальные статические переменные

    Для локальной переменной, описанной со спецификатором static, компилятор выделяет в постоянное 
    пользование участок памяти, точно так же, как и для глобальных переменных. Коренное отличие 
    статических локальных от глобальных переменных заключается в том, что статические локальные 
    переменные видны только внутри блока, в котором они объявлены. Говоря коротко, статические локальные 
    переменные — это локальные переменные, сохраняющие свое значение между вызовами функции.

    Статические локальные переменные очень важны при создании функций, работающих отдельно, так как 
    многие процедуры требуют сохранения некоторых значений между вызовами. Если бы не было статических 
    переменных, вместо них пришлось бы использовать глобальные, подвергая их риску непреднамеренного 
    изменения другими участками программы. Рассмотрим пример функции, в которой особенно уместно 
    применение статической локальной переменной. Это — генератор последовательности чисел, каждое из 
    которых зависит только от предыдущего. Для хранения числа между вызовами можно использовать глобальную
    переменную. Однако тогда при каждом использовании функции придется объявлять эту переменную и, что 
    особенно неудобно, постоянно следить за тем, чтобы ее объявление не конфликтовало с объявлениями 
    других глобальных переменных. Значительно лучшее решение — объявить эту переменную со спецификатором 
    static:

    int series(void)
    {
        static int series_num;
        series_num = series_num + 23;
        return series_num;
    }

    В этом примере переменная series_num продолжает существовать между вызовами функций, в то время как 
    обычная локальная переменная создается заново при каждом вызове, а затем уничтожается. Поэтому в 
    данном примере каждый вызов series() генерирует новое число, зависящее от предыдущего, причем удается
    обойтись без глобальных переменных.

    Статическую локальную переменную можно инициализировать. Это значение присваивается ей только один раз
    — в начале работы всей программы, но не при каждом входе в блок программы, как у обычной локальной 
    переменной. В следующей версии функции series() статическая локальная переменная инициализируется 
    числом 100:

    int series(void)
    {
        static int series_num = 100;
        series_num = series_num + 23;
        return series_num;
    }
    Теперь эта функция всегда будет генерировать последовательность, начинающуюся с числа 123. Однако во 
    многих случаях необходимо дать пользователю программы возможность ввести первое число вручную. Для 
    этого переменную series_num можно сделать глобальной и предусмотреть возможность задания начального 
    значения. Если же отказаться от объявления переменной series_num в качестве глобальной, то необходимо 
    ее объявить со спецификатором static.
    
    
    
    Глобальные статические переменные

    Спецификатор static в объявлении глобальной переменной заставляет компилятор создать глобальную 
    переменную, видимую только в том файле, в котором она объявлена. Статическая глобальная переменная, 
    таким образом, подвергается внутреннему связыванию, как описано ранее в разделе "Спецификатор extern".
    Это значит, что хоть эта переменная и глобальная, тем не менее процедуры в других файлах не увидят ее
    и не смогут случайно изменить ее значение. Этим снижается риск нежелательных побочных эффектов. А в 
    тех относительно редких случаях, когда для выполнения задачи статическая локальная переменная не 
    подойдет, можно создать небольшой отдельный файл, который содержит только функции, в которых 
    используется эта статическая глобальная переменная. Затем этот файл необходимо откомпилировать 
    отдельно; тогда можно быть уверенным, что побочных эффектов не будет.

    В следующем примере иллюстрируется применение статической глобальной переменной. Здесь генератор 
    последовательности чисел переделан так, что начальное число задается вызовом другой функции, 
    series_start():
    //Это должно быть в одном файле отдельно от всего остального.

    static int series_num;
    void series_start(int seed);
    int series(void);

    int series(void)
    {
        series_num = series_num + 23;
        return series_num;
    }

    // иницилизирует переменную series_num
    void series_start(int seed)
    {
        series_num = seed;
    }

    Вызов функции series_start() с некоторым целым числом в качестве параметра инициализирует генератор 
    series(). После этого можно генерировать последовательность чисел путем многократного вызова series().

    Обзор: Имена локальных статических переменных видимы только внутри блока, в котором они объявлены; 
    имена глобальных статических переменных видимы только внутри файла, в котором они объявлены.

    Если поместить функции series() и series_num() в библиотеку, то уже нельзя будет сослаться на 
    переменную series_num, она оказалась спрятанной от любых операторов всей остальной программы. При 
    этом в программе(конечно, в других файлах) можно объявить и использовать другую переменную под именем
    series_num. Иными словами, спецификатор static позволяет создать переменную, видимую только для 
    функций, в которых она нужна, что исключает нежелательные побочные эффекты.

    Таким образом, при разработке больших и сложных программ для "сокрытия" переменных можно применять 
    спецификатор static.
    */


    printf("\n\n\n/////////// Спецификатор register (пропускаем)\n");
    /*
    Первоначально спецификатор класса памяти register применялся только к переменным типа int, char и для
    указателей. Однако стандарт С расширил использование спецификатора register, теперь он может 
    применяться к переменным любых типов.

    В первых версиях компиляторов С спецификатор register сообщал компилятору, что переменная должна 
    храниться в регистре процессора, а не в оперативной памяти, как все остальные переменные. Это 
    приводит к тому, что операции с переменной register осуществляются намного быстрее, чем с обычными 
    переменными, потому такая переменная уже находится в процессоре и не нужно тратить время на выборку 
    ее значения из оперативной памяти (и на запись в память).

    В настоящее время определение спецификатора register существенно расширено. Стандарты С89 и С99 
    попросту декларируют "доступ к объекту так быстро, как только возможно". Практически при этом 
    символьные и целые переменные по-прежнему размещаются в регистрах процессора. Конечно, большие 
    объекты (например, массивы) не могут поместиться в регистры процессора, однако компилятор получает 
    указание "позаботиться" о быстродействии операций с ними. В зависимости от конкретной реализации 
    компилятора и операционной системы переменные register обрабатываются по-разному. Иногда спецификатор
    register попросту игнорируется, а переменная обрабатывается как обычная, однако на практике это 
    бывает редко.

    Спецификатор register можно применить только к локальным переменным и формальным параметрам функций. 
    В объявлении глобальных переменных применение спецификатора register не допускается. Ниже приведен 
    пример использования переменной, в объявлении которой применен спецификатор register; эта переменная
    используется в функции возведения целого числа m в степень. (Степень — натуральное число — 
    представлена идентификатором е.)

    int int_pwr(register int m,  register int e)
    {
      register int temp;
      temp = 1;
      for(; e; e--) temp = temp * m;
      return temp;
    }

    В этом примере в объявлениях к переменным е, m и temp применен спецификатор register потому, что они 
    используются внутри цикла. Переменные register идеально подходят для оптимизации скорости работы 
    цикла. Как правило, переменные register используются там, где от них больше всего пользы, а именно, 
    когда процесс многократно обращается к одной и той же переменной. Это существенно потому, что в 
    объявлении можно применить спецификатор register к любой переменной, но средства оптимизации 
    быстродействия могут быть применены далеко не ко всем переменным в равной степени.

    Максимальное количество переменных register, оптимизирующихся по быстродействию, зависит от среды 
    программирования и конкретной реализации компилятора. Если таких переменных окажется слишком много, 
    то компилятор автоматически преобразует регистровые переменные в нерегистровые. Этим обеспечивается
    переносимость программы в широком диапазоне процессоров.

    Обычно в регистры процессора можно поместить как минимум две переменные типа char или int. Однако в
    различных средах программирования режимы оптимизации могут очень отличаться, поэтому выбор режима 
    оптимизации необходимо осуществлять с учетом особенностей конкретного компилятора.

    В языке С с помощью оператора & (рассматривается в этой главе дале) нельзя получить адрес регистровой
    переменной, потому что она может храниться в регистре процессора, который обычно не имеет адреса.

    Хотя в настоящее время применение спецификатора register в значительной мере вышло за его традиционные
    рамки, практически ощутимый эффект от его применения по-прежнему может быть получен только для 
    переменных целого и символьного типа. Не следует ожидать заметного повышения скорости от объявления 
    регистровыми переменных других типов.
    */


    


    printf("\n\n\n/////////// Инициализация переменных\n");
    /*
    При объявлении переменной она может быть инициализирована. Для этого нужно после ее объявления поставить знак 
    равенства и константу, т.е. общая форма инициализации имеет следующий вид:
    тип имя_переменной = константа;

    Приведем несколько примеров инициализации переменных:
    char ch = 'a';
    int first = 0;
    double balance = 123.23;

    Глобальные, статические глобальные??? и статические локальные переменные инициализируются только один раз в 
    начале работы программы. 
    Неинициализированные глобальные, статические глобальные??? и статические локальные переменные в начале работы
    программы автоматически обнуляются.

    Локальные переменные (исключая статические локальные) инициализируются каждый раз при входе в блок, в котором они 
    объявлены. 
    Неинициализированные локальные переменные до первого присвоения имеют произвольное значение. 
   */


    /*
    Виды переменных:
        глобальная - объявленная вне блоков{}, видимость в рамках программы, во всех файлах.
        локальная - объявленная в блоке{}(функции, if конструкции итд), видимость в рамках блока.
        глобальная статическая - объявленная вне блоков{}, видимость в рамках файла.
        локальная статическая - объявленная в блоке{}, видимость в рамках блока.
    */















    printf("\n\n\n/////////// 000\n");
    /*

    */
    printf("\n\n\n/////////// 000\n");
    /*

    */










    printf("\n\n\n/////////// 000\n");
    /*
    
    */
    return 0;
}





// Локальные переменные
void func1(void)
{
    int x = 10;
}

void func2(void)
{
    int x = -199;
}