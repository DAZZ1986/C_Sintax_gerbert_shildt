#include <stdio.h>        // подключаем заголовочный файл stdio.h
#include <locale.h>






int main(void)
{
    char* locale = setlocale(LC_ALL, "");

    /*
    // Коллекции в С++: массив(строгий размер, данные одного типа)
    вектор контейнер(динамически увеличиваться размер, данные одного типа), 
    стринг контейнер(динамически увеличиваться размер, данные одного типа char, vchar_t)
    */


    //Это просто полезная вставка с Метанита!
    printf("\n\n\n/////////// Консольный вывод\n");
    // Консольный вывод. Функция printf - https://metanit.com/cpp/c/2.4.php
    /*
    Кроме стандартного текста мы можем передавать в строку специальные группы символов, которые называются
    управляющими последовательностями. Наиболее распространенные из них :
        \n : перевод на новую строку
        \t : табуляция
        \r : возврат каретки(курсора) в начало строки
        \\: обратный слеш
        \': одинарная кавычка
        \": двойная кавычка
     */
    printf("The book \"The C Programming Language\"\nBrian Kernighan, Dennis Ritchie.");

    printf("\n\n");
    //Спецификации преобразования
    /*
    Спецификации преобразования позволяют задать формат вывода различных типов данных. Формальное определение
    спецификаций преобразования выглядит следующим образом:
        % флаги ширина_поля.точность модификатор спецификатор

        Из этих компонентов обязательными являются только два % и спецификатор.

        Какие спецификаторы мы можем использовать:
        %c : для вывода отдельных символов(тип char)
        %s : для вывода строк
        %d : для вывода целых чисел со знаком(тип int)
        %i : для вывода целых чисел со знаком(тип int)
        %u : для вывода целых положительных чисел(тип unsigned)
        %f : для вывода чисел с плавающей точкой(float, double)
        %F : для вывода чисел с плавающей точкой в верхнем регистре(float, double)
        %e : для вывода экспоненциального представления чисел с плавающей точкой(float, double)
        %E : для вывода экспоненциального представления чисел с плавающей точкой в верхнем регистре(float, double)
        %g : для вывода чисел используется более короткий из форматов % e или % f
        %G : для вывода чисел используется более короткий из форматов % E или % F
        %o : для вывода восьмеричных чисел без знака
        %x : для вывода шестнадцатеричных чисел
        %X : для вывода шестнадцатеричных чисел в верхнем регистре
        %% : для вывода знака процента
    */
    float r = 71.8986;
    printf("x = %f \n", r);
    printf("x = %e \n", r);

    char symbol = 'r';
    printf("symbol = %c \n", symbol);

    unsigned int number2 = 23;
    printf("number2 = %u \n", number2);

    printf("%s \n", "Hello Word 2013");


    // Здесь спецификация преобразования представляет строку "%4.2f", где "4" - ширина поля (для вывода числа будут 
    // использоваться 4 цифры), а "2" - точность (2 цифры в дробной части).
    printf("x = %4.8f \n", r);  // 71.90  


    printf("\n\n");
    /* Модификаторы позволяют конкретизировать выводимое значение.
    Используются следующие модификаторы:
    h: для вывода значений short int
    l: для вывода значений long int
    L: для вывода значений long double
    */
    short r2 = 7100;
    printf("x = %hd \n", r2);

    // Необязательно передавать по одному значению для вывода в функцию printf. Мы можем передавать множество значений:
    printf("Name=%s \t Age=%d \t Weight=%3.2f", "Tom", 23, 63.3456);

    printf("\n\n");
    /*
    Дополнительно можно использовать флаги, которые дополнительно позволяют управлять форматированием вывода:
        +: если выводимое значение имеет знак (+ или -), то оно выводится. Без данного флага знак выводится только в
           случае отрицательного значения.

        пробел: вставляет пробел на месте знака перед положительными числами.

        #: при использовании со спецификаторами "o", "x", "X" значение числа выводится с предшествующими
           символами 0, 0x или 0X. При использовании со спецификаторами "f", "g", "G" десятичная точка будет выводиться,
           даже если в числе нет дробной части.

    Пример использования флагов:
*/
    printf("%d \n", 8);
    printf("% d \n", 8);
    printf("%+d \n", 8);
    printf("%#o \n", 28);
    printf("%#f \n", 8.);






    printf("\n\n\n\n");







    printf("///////// C_Sintax_gerbert_shildt\n");

    printf("///////// Глава 01. Обзор возможностей языка C\n");


    printf("///////// Структура программы на языке С\n");
    /*
    Объявление глобальных переменных...

    int main(список параметров)
    {
        последовательность операторов...
    }


    Функции...
    тип_возвращаемого_значения f1(список п
    {
        последовательность операторов
    }
    тип_возвращаемого_значения f2(список п
    {
        последовательность операторов
    }
    .
    .
    тип_возвращаемого_значения fN(список п
    {
        последовательность  операторов
    }
    */

    printf("///////// Карта памяти программы на языке С\n");
    /*
    Скомпилированная программа С имеет четыре логически обособленные области памяти:
    1) Первая — это область памяти, содержащая выполнимый код программы. 
    2) Во второй области хранятся глобальные переменные. 
    3) Стек используется для хранения вспомогательных переменных во время выполнения программы. Здесь находятся адреса 
    возврата функций, аргументы функций, локальные переменные и т.п. Текущее состояние процессора также хранится в стеке.
    4) Куча - динамически распределяемая область памяти, это такая свободная область памяти, для получения участков памяти
    из которой программа вызывает функции динамического распределения памяти.


    На рис. 1.2 показано, как распределяется память во время выполнения программы. Но не следует забывать, что конкретное 
    распределение может быть разным в зависимости от типа процессора и реализации языка.

    Рис 1.2.Распределение памяти(карта памяти) при выполнении программ, написанной на языке C
    -----------------------------------------------
                         Стек
                           ↓
    -----------------------------------------------
                           ↑
    Куча(динамически распределяемая область памяти)
    -----------------------------------------------
                  Глобальные переменные
    -----------------------------------------------
                     Код программы
    -----------------------------------------------
    */










    printf("///////// Глава 02. Выражения\n");

    /*
    ШПОРГАЛКА

    Объявление переменных может быть расположено в трех местах: 
       - внутри функции - ЛОКАЛЬНЫЕ
       - в определении параметров функции - ФОРМАЛЬНЫЕ
       - и вне всех функций. Это места объявлений соответсвенно формальных параметров функций, локальных и 
         глобальных переменных.

    Область видимости: //ЖЕНЯ
      файл - видимость в рамках файла!
      блок - видимость в рамках блолка{}!
      прототип функции - идентификаторы, объявленные в прототипе функции, видимы внутри прототипа.?
      функция - видимость в рамках блока{}, используется только метками.?


    Глобальные переменные- видимость в рамках всей программы(всех файлов), сохраняют свое значение между вызовами функции! ??
    Локальные переменные- видимость в рамках блока, создаются и разрушаются между вызовами функции(вход и выход из блока)! ??


    Static - переменные, объявленные со спецификатором static, хранятся постоянно внутри своей функции или файла. В отличие 
    от глобальных переменных они невидимы за пределами своей функции или файла, но они сохраняют свое значение между вызовами! 

    Спецификатор static воздействует на локальные и глобальные переменные по-разному:
	    локальный static  - переменная видима внутри своего блока, сохраняет свое значение между вызовами функции!
	    глобальный static - переменная имеет внутреннее связывание и видима только внутри объявленного файла, сохраняет 
			                свое значение между вызовами функции!

    Внутреннее связывание - применяется к сущностям, объявленным со спецификатором static в рамках одного .с файла(не включая .h)!
			                Файл хедер это тупая вставка как макрос и он не является еденицой компиляции!
    Внешнее связывание - переменная доступна во всех файлах, тоесть по всей программе!



    Инициализация переменных
    Глобальные:
      - Глобальные, статические глобальные и статические локальные переменные инициализируются только один раз в 
        начале работы программы. 
      - Неинициализированные глобальные, статические глобальные и статические локальные переменные в начале работы
        программы автоматически инициализируются в ноль.
    Локальные:
      - Локальные переменные (исключая статические локальные) инициализируются каждый раз при входе в блок, в котором они 
        объявлены. 
      - Неинициализированные локальные переменные до первого присвоения имеют произвольное значение. 




    Существует четыре основных класса операций: арифметические, логические, поразрядные и операции сравнения.





    */





    printf("\n\n\n/////////// Переменные\n\n");
    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/02/0204.htm
    // идентификатор - это переменная
    int i, j, k; //объявление переменной
    i = 30;      //инициализация переменной

    ///////////Где объявляются переменные
    /* 
    Объявление переменных может быть расположено в трех местах: 
    - внутри функции - ЛОКАЛЬНЫЕ
    - в определении параметров функции - ФОРМАЛЬНЫЕ
    - и вне всех функций. Это места объявлений соответсвенно локальных, формальных параметров функций и 
    глобальных переменных. 
    */

    /////////// Локальные переменные
    /* 
    Переменные, объявленные внутри функций, называются локальными переменными. В некоторых книгах по С они
    называются динамическими переменными[2]. В этой книге используется более распространенный термин 
    локальная переменная. Локальную переменную можно использовать только внутри блока, в котором она 
    объявлена. Иными словами, локальная переменная невидима за пределами своего блока. (Блок программы — 
    это описания и инструкции, объединенные в одну конструкцию путем заключения их в фигурные скобки.)

    Локальные переменные существуют только во время выполнения программного блока, в котором они 
    объявлены, создаются они при ВХОДЕ в блок, а разрушаются — при ВЫХОДЕ из него. Более того, переменная,
    объявленная в одном блоке, не имеет никакого отношения к переменной с тем же именем, объявленной в 
    другом блоке.

    Чаще всего блоком программы, в котором объявлены локальные переменные, является функция. Рассмотрим,
    например, следующие две функции:
    void func1(void)
    {
        int x = 10;   //компилятор не ругается
    }

    void func2(void)
    {
        int x = -199;   //компилятор не ругается
    }
    Целая переменная х объявлена дважды: один раз в func1() и второй — в func2(). При этом переменная х 
    в одной функции никак не связана и никак не влияет на переменную с тем же именем в другой функции. 
    Это происходит потому, что локальная переменная видима только внутри блока, в котором она объявлена,
    за пределами этого блока она невидима.

    В языке С есть ключевое слово auto (спецификатор класса памяти), которое можно использовать в 
    объявлении локальной переменной. Однако так как по умолчанию предполагается, что все переменные, не 
    являющиеся глобальными, являются динамическими, то ключевое слово auto почти никогда не используется,
    а поэтому в примерах в данной книге отсутствует.

    Из соображений удобства и в силу устоявшейся традиции все локальные переменные функции чаще всего 
    объявляются в самом начале функции, сразу после открывающейся фигурной скобки. Однако можно объявить
    локальную переменную и внутри блока программы (блок функции — это частный случай блока программы). 
    Например:
    void f(void)
    {
          int t;

          scanf_s("%d%*c", &t);

          if(t==1) {
            char s[80];  // эта переменная создается только при входе в этот блок 
            printf("Введите имя:");
            gets(s);
            //некоторые операторы ... 
        }

        //здесь переменная s невидима 
    }

    В этом примере локальная переменная s создается при входе в блок if и разрушается при выходе из него.
    Следовательно, переменная s видима только внутри блока if и не может быть использована ни в каких 
    других местах, даже если они находятся внутри функции, содержащей этот блок.

    Объявление переменных внутри блока программы помогает избежать нежелательных побочных эффектов.
    Переменная не существует вне блока, в котором она объявлена, следовательно, "посторонний" участок 
    программы не сможет случайно изменить ее значение.

    Если имена переменных, объявленных во внутреннем и внешнем блоках совпадают,  то переменная 
    внутреннего блока прячет переменную внешнего блока. Рассмотрим следующий пример:

    int main(void)
    {
      int x = 10;    // внешняя x

      if(x == 10) {
        int x;      // эта x прячет внешнюю x

        x = 99;
        printf("Внутренняя x: %d\n", x);
    }

    printf("Внешняя x: %d\n", x);
    return 0;
    }

    Результат выполнения программы следующий :
    Внутренняя х : 99
    Внешняя х : 10





    В стандарте С89 все локальные переменные должны быть объявлены в начале блока, до любого выполнимого
    оператора. Например: (функция вызовет ошибку компиляции в С89)

    void f(void)
    {
      int i;  //объявили переменную
      i = 10; //инициализировали переменную

      int j;  //тут ошибка, тк тут мы объявили переменную, после того как, что либо инициализировали, 
              //а как мы видим, выше мы инициалзировали переменную i. Тоесть сначала нужно всё объявить
              //и толлько потом инициализировать.
      j = 20; //инициализировали переменную
    }
    А в С99 (и в C++) эта функция будет работать, так как там главное чтобы переменная инпользовалась 
    после ее объявления. И не важно инициализировалась ли ранее какая либо другая переменная, главное,
    чтобы та переменная с которой мы работаем была объявлена до ее использования.


    Static
    Так как локальные переменные создаются и уничтожаются при каждом входе и выходе из блока, их 
    значение теряется каждый раз, когда программа выходит из блока. Это необходимо учитывать при вызове
    функции. Локальная переменная создается при входе в функцию и разрушается при выходе из нее. 
    Это значит, что локальная переменная не сохраняет свое значение в период между вызовами. Однако 
    можно дать указание компилятору сохранить значение локальной переменной, для этого нужно объявить 
    ее с модификатором static.

    По умолчанию локальные переменные хранятся в стеке. Стек — динамически изменяющаяся область памяти. 
    Вот почему в общем случае локальные переменные не сохраняют свое значение в период между вызовами 
    функций.

    Локальные переменные можно инициализировать каким-либо заранее заданным значением. Это значение 
    будет присвоено переменной каждый раз при входе в тот блок программы, в котором она объявлена. 
    Например, следующая программа напечатает число 10 десять раз:

    #include <stdio.h>

    void f(void);

    int main(void)
    {
      int i;
      for(i=0; i<10; i++)  f();
      return 0;
    }

    void f(void)
    {
      int j = 10;
      printf("%d ", j);
      j++;  // этот оператор не влияет на результат
    }
    */





    /////////// Формальные параметры функции
    /*
    Если функция имеет аргументы, значит должны быть объявлены переменные, которые примут их значения. 
    Эти переменные называются формальными параметрами функции. Внутри функции они фигурируют как обычные
    локальные переменные. Как показано в следующем фрагменте программы, они объявляются после имени 
    функции внутри круглых скобок.

    // Возвращает 1, если в строке s содержится символ c, в противном случае возвращает 0
    int Is_in(char* s, char c)
    {
        while (*s)
            if (*s == c) return 1;
            else s++;

        return 0;
    }

    Функция Is_in() имеет два параметра: s и с, она возвращает 1, если символ, записанный в переменной с,
    входит в строку s, в противном случае она возвращает 0.

    Внутри функции формальные параметры ничем не отличаются от обычных локальных переменных, единственное
    их отличие состоит в том, что при ВХОДЕ в функцию они получают значения аргументов. Можно, например,
    присваивать параметру какое-либо значение или использовать его в выражении. Необходимо помнить, 
    что, как и локальные переменные, формальные параметры тоже являются динамическими переменными и, 
    следовательно, разрушаются при выходе из функции.
    */





    /////////// Глобальные переменные
    /*
    В отличие от локальных, глобальные переменные видимы и могут использоваться в любом месте программы. 
    Они сохраняют свое значение на протяжении всей работы программы. Чтобы создать глобальную переменную,
    ее необходимо объявить за пределами функции. Глобальная переменная может быть использована в любом 
    выражении, независимо от того, в каком блоке это выражение используется.

    В следующем примере переменная count объявлена вне каких бы то ни было функций. Ее объявление 
    расположено перед main(), однако, оно может находиться в любом месте перед первым использованием 
    этой переменной, но только не внутри функции! Объявлять глобальные переменные рекомендуется в верхней
    части программы!

    #include <stdio.h>
    int count;  //глобальная переменная count

        void func1(void);
        void func2(void);

        int main(void)
        {
            count = 100;
            func1();
            return 0;
        }

        void func1(void)
        {
            int temp;
            temp = count;
            func2();
            printf("count глобальная %d \n", count); // напечатает 100
        }

        void func2(void)
        {
            int count;  //происходит обращение к локальной переменной count, а не к глобальной
            count = 1;
            printf("count локальная %d \n", count); // напечатает 1

        }

        Внимательно посмотрите на эту программу. Обратите внимание на то, что func1(), и func2() могут 
        использовать глобальную переменную count. Но, в func2() глобальную переменную count использовать 
        не получится, так как в ней объявлена локальная переменная с тем же именем. Когда внутри func2()
        происходит обращение к переменной count, то происходит обращение к локальной переменной, а не к  
        глобальной. Таким образом, выполняется следующее правило: если локальная и глобальная переменные
        имеют одно и то же имя, то при обращении к ней внутри блока, в котором объявлена локальная 
        переменная, происходит ссылка на локальную переменную, а на глобальную переменную это никак не 
        влияет.

        Глобальные переменные хранятся в отдельной фиксированной области памяти, созданной компилятором 
        специально для этого. Глобальные переменные используются в тех случаях, когда разные функции 
        программы используют одни и те же данные. Однако рекомендуется избегать излишнего использования 
        глобальных переменных, потому что они занимают память в течение всего времени выполнения 
        программы, а не только тогда, когда они необходимы. Кроме того, и это еще более важно, 
        использование глобальной переменной делает функцию менее универсальной, потому что в этом случае
        функция использует нечто, определенное вне ее. К тому же большое количество глобальных переменных
        легко приводит к ошибкам в программе из-за нежелательных побочных эффектов. При увеличении 
        размера программы серьезной проблемой становится случайное изменение значения переменной где-то
        в другой части программы, а когда глобальных переменных много, предотвратить это очень трудно.
    */








    printf("\n\n\n/////////// Четыре типа областей видимости\n");    
    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/02/0205.htm
    /*
    Стандарт С определяет четыре типа областей видимости[1] идентификаторов:

    //ЖЕНЯ - странно тк если область действия глобальной переменной файл, то она должна быть статик!? 
    а тут пишет просто глобальная!
    1. Область действия - файл (имя, объявленное вне всех блоков и классов, можно использовать в 
    транслируемом файле, содержащем это объявление; такие имена называются глобальными (global)).
    Область видимости - начинается в начале файла (единица трансляции) и кончается в конце файла. Такую 
    область видимости имеют только идентификаторы, объявленные вне функции. Эти идентификаторы видимы в
    любом месте файла. Переменные с этой областью видимости являются глобальными.
    (В языке С имена переменных, функций, меток и т.п. называются идентификаторами.)

    2. Область действия - блок.
    Область видимости - начинается открывающейся фигурной скобкой "{" блока и кончается с его закрытием
    скобкой "}". Эту область видимости имеют также параметры функции. Переменные, имеющие такую область
    видимости, являются локальными в своем блоке.

    //ЖЕНЯ посмотреть бы пример по прототипам
    3. Область действия - прототип функции.
    Область видимости - идентификаторы, объявленные в прототипе функции, видимы внутри прототипа.

    //ЖЕНЯ - что такое метки?
    4. Область действия - функция (имена объявленные в функции, могут быть использованы только в теле 
    функции).
    Область видимости - начинается открывающейся фигурной скобкой "{" функции и кончается с ее закрытием
    скобкой "}". Такую область видимости имеют только метки. Метка используется оператором goto и должна
    находится внутри той же функции.

    [1]Область видимости называется также контекстом или областью действия(имен.)
    */







    printf("\n\n\n/////////// Квалификатор типа (доступность и модифицируемость переменной(const, volatile, restrict))\n");
    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/02/0206.htm
    /*
    В языке С определяются квалификаторы типа[1], указывающие на доступность и модифицируемость 
    переменной. Стандарт С89 определяет два квалификатора: const и volatile. (C99 добавляет третий, 
    restrict, описанный в части II.) Квалификатор типа должен предшествовать имени типа, который он 
    квалифицирует (уточняет). 

    [1]Называются также классификаторами, описателями, спецификаторами.
    */

    ///////////Квалификатор const
    /*
    МОЁ - изменение возможно только при внешнем воздействии, это и гарантирует квалификатор const. 
    
    Переменная, к которой в объявлении (декларации) применен квалификатор const, не может изменять свое 
    значение. Ее можно только инициализировать, то есть присвоить ей значение в начале выполнения 
    программы. Компилятор может поместить переменную этого типа в постоянное запоминающее устройство, 
    так называемое ПЗУ (ROM, read-only memory). Например, в объявлении
    const int a = 10;
    создается переменная с именем а, причем ей присваивается начальное значение 10, которое в дальнейшем 
    в программе изменить никак нельзя.

    Квалификатор const часто используется для того, чтобы предотвратить изменение функцией объекта, на 
    который указывает аргумент функции. Без него при передаче в функцию указателя эта функция может 
    изменить объект, на который он указывает. Однако если в объявлении параметра-указателя применен 
    квалификатор const, функция не сможет изменить этот объект. В следующем примере функция sp_to_dash()
    печатает минус вместо каждого пробела в строке, передаваемой ей как аргумент. То есть строка 
    "тестовый пример" будет напечатана как "тестовый-пример". Применение квалификатора const в объявлении
    параметра функции гарантирует, что внутри функций объект, на который указывает параметр функции, не
    будет изменен.

    #include <stdio.h>

    void sp_to_dash(const char *str);   //это прототип функции

    int main(void)
    {
      sp_to_dash("тестовый пример");
      return 0;
    }

    void sp_to_dash(const char *str)
    {
      while(*str) {
        if(*str== ' ') printf("%c", '-');
        else printf("%c", *str);
        str++;
      }
    }

    Если написать sp_to_dash() таким образом, что внутри функции строка изменяется, то еще на этапе 
    компиляции в программе будет обнаружена ошибка. Например, на этапе компиляции возникнет ошибка, 
    если написать так:

    // Неправильный пример:
    void sp_to_dash(const char* str)
    {
        while (*str) {
            if (*str == ' ') *str = '-'; // это не правильно - тк мы не можем в строку что либо 
                                         //присваивать/перезаписывать тк она не изменяема.
            printf("%c", *str);
            str++;
        }
    }

    Квалификатор const используется в объявлениях параметров многих функций стандартной библиотеки.
    Например, прототип функции strlen() выглядит так:
    size_t strlen(const char* str);

    Применение квалификатора const в объявлении str гарантирует, что функция не изменит строку, на 
    которую указывает str. Если функция стандартной библиотеки не предназначена для изменения аргумента, 
    то практически всегда в объявлении указателя на аргумент применяется квалификатор const.

    Программист тоже может применять квалификатор const для того, чтобы гарантировать сохранность объекта.
    Но следует помнить, что переменная, даже если к ней применен квалификатор const, может быть изменена
    в результате какого - нибудь внешнего по отношению к программе воздействия. Например, ей может быть
    присвоено значение каким либо устройством. Однако применение квалификатора const в объявлении 
    переменной гарантирует, что ее изменение может произойти только в ходе внешнего по отношению к 
    программе события.
    */


    ///////////Квалификатор volatile
    /*
    МОЁ - volatile 
    1. Говорит компилятору, что данное значение может изменяться в любой момент как программно, так и 
    аппаратно, когда угодно и поэтому компилятор не имеет право ее выбрасывать, обновлять самостоятельно,
    потому что программист может изменить ее в любой момент. Тоесть volatile позволяет использовать
    системный таймер и при этом у нас данная переменная не удаляется.
    2. Суда же относятся прерывания
    н/п если бы мы работали в нескольких потоках, то в этом случае volatile говорил бы компилятору, что
    нужно работать конкретно с данной переменной и никак не делать никаких ее джубликатов, тоесть оба
    потока одновременно обращались бы к данной переменной и изменяли бы конккретно ее, а в ней бы всегда 
    хранилось актуальное значение.
    

    Шилдт
    Квалификатор volatile указывает компилятору на то, что значение переменной может измениться независимо
    от программы, т.е. вследствие воздействия еще чего-либо, не являющегося оператором программы. 
    Например, адрес глобальной переменной можно передать в подпрограмму операционной системы, следящей 
    за временем, и тогда эта переменная будет содержать системное время. В этом случае значение 
    переменной будет изменяться без участия какого-либо оператора программы. 
    
    Знание таких подробностей важно потому, что большинство компиляторов С автоматически оптимизируют 
    некоторые выражения, предполагая при этом неизменность переменной, если она не встречается в левой 
    части оператора присваивания. В этом случае при очередной ссылке на переменную может использоваться 
    ее предыдущее значение. Некоторые компиляторы изменяют порядок вычислений в выражениях, что может 
    привести к ошибке, если в выражении присутствует переменная, вычисляемая вне программы. Квалификатор 
    volatile предотвращает такие изменения программы.

    Квалификаторы const и volatile могут применяться и совместно. Например, если 0x30 — адрес порта, 
    значение в котором может задаваться только извне, то следующее объявление предотвратит всякую 
    возможность нежелательных побочных эффектов:

    const volatile char *port = (const volatile char *) 0x30;//тоесть тут мы присвиваем номер порта, 
                                                             //единожды и из вне, хотя при volatile можно
                                                             //менять значение аппаратно, извне и 
                                                             //программно. Поэтому хз?
    */






    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/02/0207.htm
    printf("\n\n\n/////////// Спецификаторы класса памяти\n");
    /*
    Стандарт С поддерживает четыре спецификатора класса памяти:
    extern - внешнее связывание, доступ во всей программе. Объявление extern сообщает компилятору, что 
             переменные определены в другом месте. И что эти переменные будут объявлены в файле позже.
             extern позволяет объявить переменную, не определяя ее.
    static - придает внутренее связывание, тоесть доступ внутри файла.
    register - пропускаем.
    auto - списан.


    Эти спецификаторы сообщают компилятору, как он должен разместить соответствующие переменные в памяти. 
    Общая форма объявления переменных при этом такова:
    Синтаксис:  спецификатор_класса_памяти   тип   имя_переменой;
    Спецификатор класса памяти в объявлении всегда должен стоять первым.

    Связывание - по умолчанию для простых переменных int i, применяется внешнее связывание, тоесть доступ
    из других файлов.
    В языке С, при редактировании связей, к переменной может применяться одно из трех связываний: 
    внутреннее, внешнее или же связывание не применяется.
    1. Внешнее связывание - можно получить доступ из других файлов. Применяется к именам функций и 
    глобальным переменным, не обязательно помеченными как extern!!!! После компоновки они будут доступны во 
    всех файлах, составляющих программу.
    2. Внутреннее связывание - применяется к сущностям, объявленным со спецификатором static в рамках 
    одного .с файла(не включая .h). Тоесть в рамках одной единицы компиляции, это файл по простому.
    После компоновки они будут доступны только внутри файла, в котором они объявлены. 
    3. Связывание не применяется - к локальным переменным, поэтому они доступны только внутри своих блоков.
    */


    ///////////Спецификатор extern
    /*
    Спецификатор extern указывает на то, что к объекту применяется внешнее связывание, именно поэтому они
    будут доступны во всей программе. 
    Далее нам понадобятся чрезвычайно важные понятия объявления и определения: 
     -объявление (декларация) - объявляет тип и имя объекта. 
     -определение(описание, инициализация) - выделяет для объекта участок памяти, где он будет находиться. 
    Один и тот же объект может быть объявлен неоднократно в разных местах и файлах со спецификатором 
    extern, но определен он может быть только один раз!!!

    В большинстве случаев объявление переменной является в то же время и ее определением. Однако, если 
    перед именем переменной стоит спецификатор extern, то объявление переменной может и не быть ее 
    определением. Таким образом, если нужно сослаться на переменную, определенную в другой части 
    программы (в другом файле или в том же), необходимо объявить ее как внешнюю (extern).

    Приведем пример использования спецификатора extern. Обратите внимание, что глобальные переменные
    first и last объявлены после main().

    #include <stdio.h>

    int main(void)
    {
      extern int first, last; // используются глобальные переменные
      printf("%d %d", first, last);
      return 0;
    }

    // описание глобальных переменных first и last
    int first = 10, last = 20;  

    Программа напечатает 10, 20. Объявление extern сообщает компилятору, что переменные first и last 
    определены в другом месте, поэтому программа компилируется без ошибки, несмотря даже на то, что 
    first и last используются до своего описания(определения).

    Обратите внимание, в этом примере объявление переменных со спецификатором extern необходимо только
    потому, что они не были объявлены до main(). Если бы их объявление встретилось перед main(), то в
    объявлении со спецификатором extern не было бы необходимости.
    _____________________________________________________________
    При компиляции выполняются следующие правила. Если компилятор находит переменную, не объявленную
    внутри блока, он ищет ее объявление во внешних блоках. Если не находит ее и там, то ищет среди
    объявлений глобальных переменных. В предыдущем примере, если бы не было объявления extern, компилятор
    не нашел бы first и last среди глобальных переменных, потому что они объявлены после main(), а как 
    мы знаем, глобальные переменные объявляются в начале файла! Здесь спецификатор extern сообщает
    компилятору, что эти переменные будут объявлены в файле позже.

    Как сказано выше, спецификатор extern позволяет объявить переменную, не определяя ее. Но если в
    объявлении со спецификатором extern определить переменную, то это объявление становится также
    и определением. При этом программист обязательно должен учитывать, что объект может иметь много
    объявлений, но лишь одно определение(описание).

    Спецификатор extern играет большую роль в программах, состоящих из многих файлов. В языке С программа
    может быть записана в нескольких файлах, которые компилируются раздельно, а затем компонуются в одно
    целое. В этом случае необходимо как-то сообщить всем файлам о глобальных переменных программы. Самый
    лучший способ сделать это — определить(описать) все глобальные переменные в одном файле и объявить их
    со спецификатором extern в остальных файлах, как показано на рис. 2.1.

    От Жени - первым написал int playerAge, тк переменная по умолчанию имеет внешнее связывание, и потом
    в другом файле ему понадобились эти данные и он написал extern int playerAge, тем самым сказал 
    компилятору не нужно выделять новый участок памяти, а иди ищи эту переменную она существует и тут
    происходит обращение к той же ячейки памяти, новая память не выделяется, переменная не копируется,
    по сути обращается к той же самой переменной.
    Дополнение: в файле 1 он объявил и определил, в файле 2 повторно объявил.
    ГЛАНВАЯ цель не засорять глобальное пространство имен! У меня 
    Extern в других файлах мы пишем для того чтобы мы не создали новую переменную с таким же именем в 
    данном файле,а обратились к переменной которую мы создали вне данного файла!!!!!!!!!!!!!!!!!!!!!!!!
    И данная глоб. переменная extern должна быть определена только 1 раз!!!!!!!!!!!!!!!!!!!

    Рис. 2.1.Использование глобальных переменных в раздельно компилируемых модулях
    Файл 1                    Файл 2
    int playerAge, y;         extern int playerAge, y;
    char ch;                  extern char ch;

    int main(void)            void func22(void)
    {
        {
            // ... //                 playerAge = y / 10;
        }
    }
    void func1(void)          void func23(void)
    {
        {
            playerAge = 123;           y = 10;
        }
    }

    Во втором файле спецификатор extern сообщает компилятору, что эти переменные описаны в других
    файлах. Таким образом компилятор узнает имена и типы переменных, размещенных в другом месте, и может
    отдельно компилировать второй файл, ничего не зная о первом. При компоновке этих двух модулей все
    ссылки на глобальные переменные будут разрешены.  

    На практике программисты обычно включают объявления extern в заголовочные файлы, которые просто
    подключаются к каждому файлу исходного текста программы. Это более легкий путь, который к тому же
    приводит к меньшему количеству ошибок, чем повторение этих объявлений вручную в каждом файле.
    */





    /////////// Спецификатор static
    /*
    Переменные, объявленные со спецификатором static, хранятся постоянно внутри своей функции или файла.
    В отличие от глобальных переменных они невидимы за пределами своей функции или файла, но они 
    сохраняют свое значение между вызовами. Эта особенность делает их полезными в общих функциях и 
    библиотечных функциях, которые будут использоваться другими программистами. 
    Спецификатор static воздействует на локальные и глобальные переменные по разному.
    
    
    
    ///////////Локальные статические переменные
    Для локальной переменной, описанной со спецификатором static, компилятор выделяет в постоянное 
    пользование участок памяти, точно так же, как и для глобальных переменных. Коренное отличие 
    статических локальных от глобальных переменных заключается в том, что статические локальные 
    переменные видны только внутри блока, в котором они объявлены. Говоря коротко, статические локальные 
    переменные — это локальные переменные, сохраняющие свое значение между вызовами функции.

    Статические локальные переменные очень важны при создании функций, работающих отдельно, так как 
    многие процедуры требуют сохранения некоторых значений между вызовами. Если бы не было статических 
    переменных, вместо них пришлось бы использовать глобальные, подвергая их риску непреднамеренного 
    изменения другими участками программы. Рассмотрим пример функции, в которой особенно уместно 
    применение статической локальной переменной. Это — генератор последовательности чисел, каждое из 
    которых зависит только от предыдущего. Для хранения числа между вызовами можно использовать глобальную
    переменную. Однако тогда при каждом использовании функции придется объявлять эту переменную и, что 
    особенно неудобно, постоянно следить за тем, чтобы ее объявление не конфликтовало с объявлениями 
    других глобальных переменных. Значительно лучшее решение — объявить эту переменную со спецификатором 
    static:

    int series(void)
    {
        static int series_num;
        series_num = series_num + 23;
        return series_num;
    }

    В этом примере переменная series_num продолжает существовать между вызовами функций, в то время как 
    обычная локальная переменная создается заново при каждом вызове, а затем уничтожается. Поэтому в 
    данном примере каждый вызов series() генерирует новое число, зависящее от предыдущего, причем удается
    обойтись без глобальных переменных.

    Статическую локальную переменную можно инициализировать. Это значение присваивается ей только один раз
    — в начале работы всей программы, но не при каждом входе в блок программы, как у обычной локальной 
    переменной. В следующей версии функции series() статическая локальная переменная инициализируется 
    числом 100:

    int series(void)
    {
        static int series_num = 100;
        series_num = series_num + 23;
        return series_num;
    }
    Теперь эта функция всегда будет генерировать последовательность, начинающуюся с числа 123. Однако во 
    многих случаях необходимо дать пользователю программы возможность ввести первое число вручную. Для 
    этого переменную series_num можно сделать глобальной и предусмотреть возможность задания начального 
    значения. Если же отказаться от объявления переменной series_num в качестве глобальной, то необходимо 
    ее объявить со спецификатором static.
    
    
    
    ///////////Глобальные статические переменные
    Спецификатор static в объявлении глобальной переменной заставляет компилятор создать глобальную 
    переменную, видимую только в том файле, в котором она объявлена. Статическая глобальная переменная, 
    таким образом, подвергается внутреннему связыванию, как описано ранее в разделе "Спецификатор extern".
    Это значит, что хоть эта переменная и глобальная, тем не менее процедуры в других файлах не увидят ее
    и не смогут случайно изменить ее значение. Этим снижается риск нежелательных побочных эффектов. А в 
    тех относительно редких случаях, когда для выполнения задачи статическая локальная переменная не 
    подойдет, можно создать небольшой отдельный файл, который содержит только функции, в которых 
    используется эта статическая глобальная переменная. Затем этот файл необходимо откомпилировать 
    отдельно; тогда можно быть уверенным, что побочных эффектов не будет.

    В следующем примере иллюстрируется применение статической глобальной переменной. Здесь генератор 
    последовательности чисел переделан так, что начальное число задается вызовом другой функции, 
    series_start():
    //Это должно быть в одном файле отдельно от всего остального.

    static int series_num;
    void series_start(int seed);
    int series(void);

    int series(void)
    {
        series_num = series_num + 23;
        return series_num;
    }

    // иницилизирует переменную series_num
    void series_start(int seed)
    {
        series_num = seed;
    }

    Вызов функции series_start() с некоторым целым числом в качестве параметра инициализирует генератор 
    series(). После этого можно генерировать последовательность чисел путем многократного вызова series().

    Обзор: Имена локальных статических переменных видимы только внутри блока, в котором они объявлены; 
    имена глобальных статических переменных видимы только внутри файла, в котором они объявлены.

    Если поместить функции series() и series_num() в библиотеку, то уже нельзя будет сослаться на 
    переменную series_num, она оказалась спрятанной от любых операторов всей остальной программы. При 
    этом в программе(конечно, в других файлах) можно объявить и использовать другую переменную под именем
    series_num. Иными словами, спецификатор static позволяет создать переменную, видимую только для 
    функций, в которых она нужна, что исключает нежелательные побочные эффекты.

    Таким образом, при разработке больших и сложных программ для "сокрытия" переменных можно применять 
    спецификатор static.
    */



    /////////// Спецификатор register (пропускаем)
    /*
    Первоначально спецификатор класса памяти register применялся только к переменным типа int, char и для
    указателей. Однако стандарт С расширил использование спецификатора register, теперь он может 
    применяться к переменным любых типов.

    В первых версиях компиляторов С спецификатор register сообщал компилятору, что переменная должна 
    храниться в регистре процессора, а не в оперативной памяти, как все остальные переменные. Это 
    приводит к тому, что операции с переменной register осуществляются намного быстрее, чем с обычными 
    переменными, потому такая переменная уже находится в процессоре и не нужно тратить время на выборку 
    ее значения из оперативной памяти (и на запись в память).

    В настоящее время определение спецификатора register существенно расширено. Стандарты С89 и С99 
    попросту декларируют "доступ к объекту так быстро, как только возможно". Практически при этом 
    символьные и целые переменные по-прежнему размещаются в регистрах процессора. Конечно, большие 
    объекты (например, массивы) не могут поместиться в регистры процессора, однако компилятор получает 
    указание "позаботиться" о быстродействии операций с ними. В зависимости от конкретной реализации 
    компилятора и операционной системы переменные register обрабатываются по-разному. Иногда спецификатор
    register попросту игнорируется, а переменная обрабатывается как обычная, однако на практике это 
    бывает редко.

    Спецификатор register можно применить только к локальным переменным и формальным параметрам функций. 
    В объявлении глобальных переменных применение спецификатора register не допускается. Ниже приведен 
    пример использования переменной, в объявлении которой применен спецификатор register; эта переменная
    используется в функции возведения целого числа m в степень. (Степень — натуральное число — 
    представлена идентификатором е.)

    int int_pwr(register int m,  register int e)
    {
      register int temp;
      temp = 1;
      for(; e; e--) temp = temp * m;
      return temp;
    }

    В этом примере в объявлениях к переменным е, m и temp применен спецификатор register потому, что они 
    используются внутри цикла. Переменные register идеально подходят для оптимизации скорости работы 
    цикла. Как правило, переменные register используются там, где от них больше всего пользы, а именно, 
    когда процесс многократно обращается к одной и той же переменной. Это существенно потому, что в 
    объявлении можно применить спецификатор register к любой переменной, но средства оптимизации 
    быстродействия могут быть применены далеко не ко всем переменным в равной степени.

    Максимальное количество переменных register, оптимизирующихся по быстродействию, зависит от среды 
    программирования и конкретной реализации компилятора. Если таких переменных окажется слишком много, 
    то компилятор автоматически преобразует регистровые переменные в нерегистровые. Этим обеспечивается
    переносимость программы в широком диапазоне процессоров.

    Обычно в регистры процессора можно поместить как минимум две переменные типа char или int. Однако в
    различных средах программирования режимы оптимизации могут очень отличаться, поэтому выбор режима 
    оптимизации необходимо осуществлять с учетом особенностей конкретного компилятора.

    В языке С с помощью оператора & (рассматривается в этой главе дале) нельзя получить адрес регистровой
    переменной, потому что она может храниться в регистре процессора, который обычно не имеет адреса.

    Хотя в настоящее время применение спецификатора register в значительной мере вышло за его традиционные
    рамки, практически ощутимый эффект от его применения по-прежнему может быть получен только для 
    переменных целого и символьного типа. Не следует ожидать заметного повышения скорости от объявления 
    регистровыми переменных других типов.
    */


    


    printf("\n\n\n/////////// Инициализация переменных\n");
    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/02/0208.htm
    /*
    При объявлении переменной она может быть инициализирована. Для этого нужно после ее объявления поставить знак 
    равенства и константу, т.е. общая форма инициализации имеет следующий вид:
    тип имя_переменной = константа;

    Приведем несколько примеров инициализации переменных:
    char ch = 'a';
    int first = 0;
    double balance = 123.23;

    Глобальные:
      - Глобальные, статические глобальные и статические локальные переменные инициализируются только один раз в
        начале работы программы.
      - Неинициализированные глобальные, статические глобальные и статические локальные переменные в начале работы
        программы автоматически обнуляются.
    Локальные:
      - Локальные переменные (исключая статические локальные) инициализируются каждый раз при входе в блок, в котором они
        объявлены.
      - Неинициализированные локальные переменные до первого присвоения имеют произвольное значение.


    Виды переменных:
        глобальная - объявленная вне блоков{}, видимость в рамках программы, во всех файлах.
        локальная - объявленная в блоке{}(функции, if конструкции итд), видимость в рамках блока.
        глобальная статическая - объявленная вне блоков{}, видимость в рамках файла.
        локальная статическая - объявленная в блоке{}, видимость в рамках блока.
   */





    printf("\n\n\n/////////// Константы (Шилд под константами понимает литералы)\n");
    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/02/0209.htm
    /*
    int i = 7;     // 7 - это вообще литерал, но по Шилду это константа.

    Константа — это фиксированное значение, которое не может быть изменено программой. Константа может относиться к 
    любому базовому типу. Способ представления константы определяется ее типом. Константы также называются литералами.

    Символьные константы заключаются в одинарные кавычки. Например, 'а' и '%' — это символьные константы. В языке С 
    определены многобайтовые (состоящие из одного или более байт) и широкие (обычно длиной 16 бит) символы. Они 
    используются для представления символов языков, имеющих в своем алфавите много букв. Многобайтовый символ 
    записывается в одинарных кавычках, например, 'ху', а широкий — с предшествующим символом L, например:
    wchar_t wc;
    wc = L'A';

    Здесь переменной wc присвоено значение константы А, рассматриваемой как широкий символ. Тип широкого символа wchar_t 
    определен в заголовочном файле <stddef.h>, этот тип не является встроенным.

    Целые константы определяются как числа без дробной части. Например, 10 и -100 — это целые константы. Константы в 
    плавающем формате записываются как числа с десятичной точкой, например, 11.123. Допускается также экспоненциальное 
    представление чисел (в виде мантиссы и порядка): 111.23е— 1.

    По умолчанию компилятор приписывает константе тип наименьшего размера, в ячейку которого может уместиться константа. 
    Таким образом, если целые числа обычно являются 16-разрядными, то константа 10 по умолчанию имеет тип int, a 
    103000 — тип long int. Число 10 может поместиться в типе char, однако компилятор не нарушит границы типов и поместит
    ее в int. Но это правило имеет исключение: всем константам в плавающем формате, даже самым маленьким, приписывается
    тип double (если, конечно, они сюда помещаются).

    Определение типов констант по умолчанию является вполне удовлетворительным при разработке большинства программ.
    Однако, используя суффикс, можно явно указать тип числовой константы. Если после числа в плавающем формате стоит 
    суффикс F, то считается, что константа имеет тип float, а если L, то long double. Для целых типов суффикс U означает
    unsigned, a L — long. Тип суффикса не зависит от регистра, например, как F, так и f определяют константы типа float. 
    
    Приведем несколько примеров:
    Тип данных	    Примеры констант
    int         	1       /   123	  /   21000   /	-243
    long int	    35000L	/   -34L
    unsigned int	10000U	/   987u  /	  40000U
    float	        123.23F	/   4.34e-4f
    double	        123.23 1.0 / -0.98765432
    long double	    1001.2L
    Стандарт С99 определяет также целые константы типа long long, их суффикс — LL или ll.


    Шестнадцатиричные и восмеричные константы
    Иногда удобнее использовать не десятичную, а восьмеричную или шестнадцатеричную систему. Позиционную систему 
    счисления с основанием 8 называют восьмеричной. В ней используются цифры от 0 до 7. Число 10 в восьмеричной системе 
    представляет то же число, что и 8 в десятичной. Позиционная система счисления с основанием 16 называется 
    шестнадцатеричной. В ней используются 16 символов: цифры от 0 до 9 и символы от А до F, обозначающие цифры от 10
    до 15. Например, запись 10 в шестнадцатеричной системе обозначает то же число, что и 16 в десятичной системе. Эти 
    системы счисления используются довольно часто, поэтому в С целые константы можно определять не только в десятичной, 
    но и в восьмеричной и шестнадцатеричной системах счисления. Шестнадцатеричная константа начинается с 0х, а 
    восьмеричная — с 0, например:
    int hex = 0x80;   // 128 в десятичной системе
    int oct = 012;    // 10 в десятичной системе


    Строковые константы
    Язык С поддерживает еще один тип констант, а именно — строковые. Строка — это последовательность символов, заключенных
    в двойные кавычки. Например, "тест" — это строка. В этой книге ранее уже встречались примеры строк в функции printf().
    В термине "строковая константа" слово "строковая" не означает строковый предопределенный тип данных, такого в С нет,
    здесь это всего лишь прилагательное.
    Не следует путать понятия строки и символа. Символьная константа заключается в одинарные кавычки, например, 'а'.
    Соответственно запись "а" означает строку, состоящую из одного символа.
    
    
    Специальные символьные константы
    Чтобы представить большинство символьных констант, достаточно заключить соответствующий символ в одинарные кавычки.
    Но некоторые символы, например, символ возврата каретки, требуют специального представления. В языке С определены 
    специальные символьные константы, приведенные в табл. 2.2. Иногда их называют ESC - последовательностями, управляющими
    последовательностями и символами с обратным слэшем. Управляющие последовательности можно использовать вместо 
    ASCII - кодов для обеспечения лучшей переносимости программы.
    В следующем примере программа выводит символ новой строки(т.е.переходит на новую строку), выводит символ табуляции
    (т.е.переходит на первую позицию табуляции) и, наконец, выводит строку Простой тест.
    #include <stdio.h>
    int main(void)
    {
        printf("\n\tПростой тест.");
        return 0;
    }

    Таблица 2.2.Специальные символы константы
        Код	Назначение
        \b	Удаление предыдущего символа
        \f	Подача бумаги
        \n	Новая строка
        \r	Возврат каретки
        \t	Горизонтальная табуляция
        \"	Двойные кавычки
        \'	Одинарная кавычка
        \\	Обратный слэш
        \v	Вертикальная табуляция
        \a	Сигнал
        \ ? Знак вопроса
        \N	Восьмеричная константа(N - восьмеричное представление)
        \xN	Шеснадцатеричная константа(N - шеснадцатеричное представление)
    */








    printf("\n\n\n/////////// Операции\n");
    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/02/0210.htm
    /*
    Язык С содержит большое количество встроенных операций. Их роль в С значительно больше, чем в других языках 
    программирования. Существует четыре основных класса операций: арифметические, логические, поразрядные и операции 
    сравнения. Кроме них, есть также некоторые специальные операторы, например, оператор присваивания.
    




    ///////////Оператор присваивания
    Оператор присваивания может присутствовать в любом выражении языка С[1]. Этим С отличается от большинства других 
    языков программирования (Pascal, BASIC и FORTRAN), в которых присваивание возможно только в отдельном операторе. 
    Общая форма оператора присваивания:
    имя_переменной=выражение;

    Выражение может быть просто константой или сколь угодно сложным выражением. В отличие от Pascal или Modula-2, в 
    которых для присваивания используется знак ":=", в языке С оператором присваивания служит единственный знак 
    присваивания "=". Адресатом (получателем), т.е. левой частью оператора присваивания должен быть объект, способный 
    получить значение, например, переменная.

    В книгах по С и в сообщениях компилятора часто встречаются термины lvalue[2] (left side value) и rvalue[3] 
    (right side value). Попросту говоря, lvalue — это объект. Если этот объект может стоять в левой части присваивания, 
    то он называется также модифицируемым (modifiable) lvalue. Подытожим сказанное: lvalue — это объект в левой части 
    оператора присваивания, получающий значение, чаще всего этим объектом является переменная. Термин rvalue означает
    значение выражения в правой части оператора присваивания.
    
    
    


    
    ///////////Преобразование типов при присваиваниях
    Если в операции встречаются переменные разных типов, происходит преобразование типов. В операторе присваивания 
    действует простое правило: значение выражения в правой части преобразуется к типу объекта в левой части.
    int x;
    char ch;
    float  f;

    void func(void)
    {
        ch = x;    // 1-я строка
        x = f;     // 2-я строка
        f = ch;    // 3-я строка
        f = x;     // 4-я строка
    }

    В 1 - й строке этого примера старшие двоичные разряды целой переменной х отбрасываются, а в ch заносятся младшие 
    8 бит. Если значение х лежит в интервале от 0 до 255, то ch и х будут идентичны и потери информации не произойдет. 
    В противном случае в ch будут занесены только младшие разряды переменной х.Во 2 - й строке в х будет записана целая
    часть числа f.В 3 - й строке произойдет преобразование целого 8 - разрядного числа, хранящегося в ch, в число в 
    плавающем формате.В 4 - й строке произойдет то же самое, только с 16 - разрядным целым.

    Преобразование целых в символы и длинных целых в целые удаляет соответствующее количество старших двоичных разрядов.
    В 16 - разрядной среде теряются 8 битов при преобразовании целого в символ и 16 битов при преобразовании длинного 
    целого в целое.В 32 - разрядной среде теряются 24 бита при преобразовании целого в символ и 16 битов при 
    преобразовании целого в короткое целое.

    В табл. 2.3.приведены варианты потери информации при некоторых преобразованиях.Необходимо помнить, что 
    преобразование int во float или float в double не повышает точность вычислений.При таком преобразовании только
    изменяется форма представления числа.Некоторые компиляторы при преобразовании char в int считают переменную char 
    положительной независимо от ее значения.Другие компиляторы считают переменную char отрицательной, если она 
    больше 127. Поэтому для обеспечения переносимости программы необходимо использовать переменные типа char для 
    хранения символов, а переменные типа signed char и int(целый) — для хранения чисел.

    Таблица 2.3.Результат некоторых преобразований типов 
    Тип адресата	    Тип выражения	    Потеря информации
    signed char	        char	            Если значение > 127, то результат отрицательный
    char	            short int	        Старшие 6 бит
    char	            int(16-разрядный)	Старшие 8 бит
    char	            int(32 - разрядный)	Старшие 24 бит
    char	            long int	        Старшие 24 бит
    short int	        int(16 - разрядный)	Нет
    short int	        int(32 - разрядный)	Старшие 16 бит
    int(16 - разрядный)	long int	        Старшие 16 бит
    int(32 - разрядный)	long int	        Нет
    long int(32 - разрядный)	long long int(64 - разрядный)	Старшие 32 бита(это относится только к C99)
    int	                float	            Дробная часть
    float	            double	            Результат округляется
    double	            long double	            Результат округляется

    Если какое - либо преобразование не приведено в табл. 2.3, то, чтобы определить, что именно теряется в результате 
    этого преобразования, нужно представить его в виде композиции(суперпозиции, произведения) указанных в таблице 
    преобразований и затем провести последовательные преобразования.Например, преобразование double в int эквивалентно
    последовательному выполнению двух преобразований : сначала double в float, а затем float в int.
    





    ///////////Множественные присваивания
    В одном операторе присваивания можно присвоить одно и то же значение многим переменным. Для этого используется 
    оператор множественного присваивания[4], например:
    x = y = z = 0;
    Следует отметить, что в практике программирования этот прием используется очень часто.






    ///////////Составное присваивание
    Составное присваивание — это разновидность оператора присваивания, в которой запись сокращается и становится более
    удобной в написании[5]. Например, оператор
    x = x+10;
    можно записать как
    x += 10;
    Оператор "+=" сообщает компилятору, что к переменной х нужно прибавить 10.
    "Составные" операторы[6] присваивания существуют для всех бинарных операций (то есть операций, имеющих два операнда).
    Любой оператор вида
    переменная = переменная оператор выражение;
    можно записать как
    переменная оператор = выражение;
    Еще один пример:
    x = x-100;
    означает то же самое, что и
    x -= 100;
    Составное присваивание значительно компактнее, чем соответствующее простое присваивание, поэтому его иногда называют
    стенографическим (shorthand) присваиванием. В программах на С этот оператор широко используется, поэтому необходимо
    хорошо его усвоить.
    


    
    
    
    ///////////Арифметические операции
    В табл. 2.4 приведены арифметические операции С. Операции +, —, * и / работают так же, как и в большинстве других языков
    программирования. Их можно применять почти ко всем встроенным типам данных. Если операция / применяется к целому или 
    символьному типам, то остаток от деления отбрасывается. Например, результатом операции 5/2 является 2.
    Таблица 2.4. Арифметические операции 
    Оператор	Операция
    -	        Вычитание, так же унарный минус
    +	        Сложение
    *	        Умножение
    /	        Деление
    %	        Остаток от деления
    --	        Декремент[7], или уменьшение
    ++	        Инкремент[8], или увеличение

    Оператор деления по модулю % в С работает так же, как и в других языках, его результатом является остаток от 
    целочисленного деления. Этот оператор, однако, нельзя применять к типам данных с плавающей точкой. Применение 
    оператора % иллюстрируется следующим примером:
    int x, y;

    x = 5;
    y = 2;

    printf("%d ", x/y);    //напечатает 2
    printf("%d ", x% y);   //напечатает 1, остаток от целочисленного деления

    x = 1;
    y = 2;
    printf("%d %d", x / y, x% y); //  напечатает 0 1

    Последняя строка программы напечатает 0 1 потому, что при целочисленном делении остаток отбрасывается и здесь 
    результат будет 0, а сам остаток равен 1.
    Унарный минус умножает операнд на - 1, то есть меняет его знак на противоположный.






    ///////////Операции увеличения (инкремента) и уменьшения (декремента)
    В языке С есть два полезных оператора, значительно упрощающие широко распространенные операции. Это инкремент ++ и 
    декремент --. Оператор ++ увеличивает значение операнда на 1, а — уменьшает на 1. Иными словами:
    x = x+1;
    можно записать как
    ++x;

    Аналогично оператор
    x = x-1;
    равносилен оператору
    x--;

    Как инкремент, так и декремент могут предшествовать операнду (префиксная форма) или следовать за ним (постфиксная 
    форма). Например
    x = x+1;
    можно записать как в виде
    ++x;
    так и в виде
    x++;

    Однако префиксная и постфиксная формы отличаются при использовании их в выражениях. Если оператор инкремента или 
    декремента предшествует операнду, то сама операция выполняется до использования результата в выражении. Если же 
    оператор следует за операндом, то в выражении значение операнда используется до выполнения операции инкремента 
    или декремента. То есть для выражения эта операция как бы не существует, она выполняется только для операнда. 
    Например,
    x = 10;
    y = ++x;
    присваивает у значение 11. Однако если написать
    x = 10;
    y = x++;
    то переменной у будет присвоено значение 10. В обоих случаях х присвоено значение 11, разница только в том, когда
    именно это случилось, до или после присваивания значения переменной у.

    Большинство компиляторов С генерируют для инкремента и декремента очень быстрый, эффективный объектный код, 
    значительно лучший, чем для соответствующих операторов присваивания. Поэтому везде, где это возможно, рекомендуется
    использовать инкремент и декремент.

    Приоритет выполнения арифметических операторов следующий:
    Наивысший     ++ --
                  - (унарный минус)
                  * / %
    Наинизший     + -

    Операции с одинаковым приоритетом выполняются слева направо. Используя круглые скобки, можно изменить порядок 
    вычислений. В языке С круглые скобки интерпретируются компилятором так же, как и в любом другом языке 
    программирования: они как бы придают операции (или последовательности операций) наивысший приоритет.






    ///////////Операции сравнения и логические операции
    Операции сравнения — это операции, в которых значения двух переменных сравниваются друг с другом. Логические же 
    операции реализуют средствами языка С операции формальной логики. Между логическими операциями и операциями 
    сравнения существует тесная связь: результаты операций сравнения часто являются операндами логических операций.

    В операциях сравнения и логических операциях в качестве операндов и результатов операций используются значения 
    ИСТИНА (true) и ЛОЖЬ (false). В языке С значение ИСТИНА представляется любым числом, отличным от нуля. Значение 
    ЛОЖЬ представляется нулем. Результатом операции сравнения или логической операции являются ИСТИНА (true, 1) или 
    ЛОЖЬ (false, 0).
    На заметку	Как в С89, так и в С99 значение ИСТИНА представлено любым отличным от нуля числом, а ЛОЖЬ — нулем. 
    В стандарте С99 дополнительно определен тип данных _Bооl, переменные которого могут принимать значение только 
    или 1. Подробнее см. часть II.

    В табл. 2.5 приведен полный список операций сравнения и логических операций. Таблица истинности логических 
    операций имеет следующий вид:
    p	q	p && q	    p || q	    !p
    0	0	  0	           0	    1
    0	1	  0	           1	    1
    1	1	  1	           1    	0
    1	0	  0	           1    	0

    Как операции сравнения, так и логические операции имеют низший приоритет по сравнению с арифметическими. То есть,
    выражение 10>1+12 интерпретируется как 10>(1+12). Результат, конечно, равен ЛОЖЬ.
    В одном выражении можно использовать несколько операций:
    10>5 && !(10<9) || 3<4
    В этом случае результатом будет ИСТИНА.

    */
    /*
    //просто моя вставка кода для тестов
    if (10>5 && !(10<9) || 3<4) //тут истина, тут условие или выполняется в истину и слева и справа
    {
        printf("\n True \n");
    }
    if (10 > 5 && !(10 < 9) || 3>4) //тут истина, тк условия или выполняется слева истина
    {
        printf("\n True \n");
    }
    */
    /*
    В языке С не определена операция "исключающего ИЛИ" (exclusive OR, или XOR). Однако с помощью логических операторов
    несложно написать функцию, выполняющую эту операцию. Результатом операции "исключающее ИЛИ" является ИСТИНА, если
    и только если один из операндов (но не оба) имеют значение ИСТИНА. В следующем примере функция xor() возвращает
    результат операции "исключающее ИЛИ", а операндами служат аргументы функции:
    #include <stdio.h>

    int xor(int a, int b);
    int main(void)
    {
      printf("%d", xor(1, 0));
      printf("%d", xor(1, 1));
      printf("%d", xor(0, 1));
      printf("%d", xor(0, 0));

      return 0;
    }

    // Выполнение логической оперции исключающее ИЛИ над двумя аргументами.
    intxor (int a, int b)
    {
        return (a || b) && !(a && b);
    }

    Таблица 2.5.Операции сравнения и логические операции 
    Операторы сравнения
    Оператор	    Операция
        >           Больше чем
        >=          Больше или равно
        <	        Меньше чем
        <=          Меньше или равно
        ==          Равно
        !=          Не равно

     Логические операции
     Оператор	    Операция
        &&             И
        ||            ИЛИ
        !         НЕ,отрицание


    Ниже приведен приоритет логических операций:
    Наивысший     !
                  > >= < <=
                  == !=
                  &&
    Наинизший     ||

    Как и в арифметических выражениях, для изменения порядка выполнения операций сравнения и логических операций
    можно использовать круглые скобки. Например, выражение:
    !0 && 0 || 0
    равно ЛОЖЬ. Однако, если добавить скобки как показано ниже, то результатом будет ИСТИНА:
    !(0 && 0) || 0

    Необходимо помнить, что результатом любой операции сравнения или логической операции есть 0 или 1. Поэтому 
    следующий фрагмент программы является правильным и в результате его выполнения будет напечатано 1.
    int x;
    x = 100;
    printf("%d", x > 10);







    ///////////Поразрядные операции
    В отличие от многих других языков программирования, в С определен полный набор поразрядных операций[9]. Это 
    обусловлено тем, что С был задуман как язык, призванный во многих приложениях заменить ассемблер, который способен
    оперировать битами данных.Поразрядные операции — это тестирование(проверка), сдвиг или присвоение значений 
    отдельным битам данных.Эти операции осуществляются над ячейками памяти, содержащими данные типа char или int. 
    Данные типа float, double, long double, void или другие более сложные не могут участвовать в поразрядных операциях.
    В табл. 2.6 приведен полный список знаков поразрядных операций, выполняемых над отдельными разрядами(битами) 
    операндов.
    Таблица 2.6.Поразрядные операции 
    Оператор	Операция
        &       И
        |       ИЛИ
        ^       исключающее ИЛИ
        ~       НЕ(отрицание, дополнение к 1)
        >>      Сдвиг вправо
        <<      Сдвиг влево

    Таблицы истинности логических операций и поразрядных операций И, ИЛИ, НЕ совпадают.Отличие лишь в том, что 
    поразрядные операции выполняются над отдельными разрядами(битами) операндов.Операция "исключающее ИЛИ" имеет 
    следующую таблицу истинности:
    p	q	p ^ q
    0	0	  0
    1	0	  1
    1	1	  0
    0	1	  1

    Как показано в таблице, результат операции "исключающее ИЛИ" равен ИСТИНА если и только если один из операндов 
    равен 1, иначе результат будет равен ЛОЖЬ.

    Наиболее часто поразрядные операции применяются при программировании драйверов устройств, таких как модемы, а 
    также процедур, выполняющих операции над файлами, и стандартных программ обслуживания принтера.В них поразрядные
    операции используются для маскирования определенных битов, например, бита контроля четности[10]. (Этот бит 
    служит для проверки правильности остальных битов в байте.Чаще всего это бит старшего разряда в каждом байте.)

    Операция И может быть использована для очищения бита[11].Иными словами, для гашения бита используется следующее 
    свойство операции И : если бит одного из операндов равен 0, то соответствующий бит результата будет равен 0 
    независимо от состояния этого бита во втором операнде.Например, следующая функция читает символ из порта модема 
    и обнуляет бит контроля четности:

    char get_char_from_modem(void)
    {
        char ch;
        ch = read_modem(); // чтение символа из порта модема
        return(ch & 127);
    }

    Бит контроля четности, находящийся в 8 - м разряде байта, обнуляется с помощью операции И.При этом в качестве 
    второго операнда выбирается число, имеющее 1 в разрядах от 1 до 7, и 0 в 8 - м разряде.Именно таким числом и 
    является 127, поскольку все биты двоичного представления числа 127, кроме старшего, равны 1. В силу указанного
    свойства операции И операция ch & 127 оставляет все биты, кроме старшего, без изменения, а старший обнуляет:
    Бит контроля четности

    |
    V
    1100 0001     переменная ch содержит символ 'A' с битом четности
    0111 1111     двоичное представление числа 127
  & ---------     поразрядная операция И
    0100 0001     символ 'A' с обнуленным битом контроля четности

    Поразрядная операция ИЛИ, являющаяся двойственной операции И, применяется для установки необходимых битов в 1. 
    В следующем примере выполняется операция 128 | 3:
    |
    V
    1000 0000     двоичное представление числа 128
    0000 0011     двоичное представление числа 3
  | ---------     поразрядная операция ИЛИ
    1000 0011     результат

    Операция исключающего ИЛИ(XOR) устанавливает бит результата в 1, если соответствующие биты операндов различны.
    В следующем примере выполняется операция 127 ^ 120:
    |
    V
    0000 0011     двоичное представление числа 127
    0111 1000     двоичное представление числа 120
  ^ ---------     поразрядная операция XOR
    0000 0111     результат

    Необходимо помнить, что результат логической операции всегда равен 0 или 1. В то же время результатом поразрядной 
    операции может быть любое значение, которое, как видно из предыдущих примеров, не обязательно равно 0 или 1.

    Поразрядные операторы сдвига >> и << сдвигают все биты переменной вправо или влево.Общая форма оператора сдвига 
    вправо:  переменная >> количество_разрядов
    Общая форма оператора сдвига влево:  переменная << количество_разрядов

    Во время сдвига битов в один конец числа, другой конец заполняется нулями.Но если число типа signed int 
    отрицательно, то при сдвиге вправо левый конец заполняется единицами, так что знак числа сохраняется. Необходимо
    отметить различие между сдвигом и циклическим сдвигом.При циклическом сдвиге биты, сдвигаемые за пределы операнда,
    появляются на другом конце операнда.А при сдвиге вышедшие за границу биты теряются.

    Поразрядные операции сдвига очень полезны при декодировании выходов внешних устройств, например таких, как цифро
    - аналоговые преобразователи, а также при считывании информации о статусе устройств.Побитовые операторы сдвига 
    могут быстро умножать и делить целые числа.Как показано в табл. 2.7, сдвиг на один бит вправо делит число на 2, 
    а на один бит влево — умножает на 2. Следующая программа иллюстрирует применение операторов сдвига:

    // Пример применения операторов сдвига.
    #include <stdio.h>

    int main(void)
    {
        unsigned int i;
        int j;
        i = 1;

        //сдвиг влево
        for (j = 0; j < 4; j++) {
            i = i << 1;  // сдвиг i влево на 1 разраяд, что равносильно умножению на 2
            printf("Сдвиг влево на %d разр.: %d\n", j, i);
        }

        //сдвиг вправо
        for (j = 0; j < 4; j++) {
            i = i >> 1;  // сдвиг i вправо на 1 разраяд, что равносильно делению на 2
            printf("Сдвиг вправо на %d разр.: %d\n", j, i);
        }

        return 0;
    }

    Таблица 2.7.Умножение и деление операторами сдвига 
    unsigned char x	        x после операции	        значение x
    x = 7	                    0000 0111	                7
    x = x << 1	                0000 1110	                14
    x = x << 3	                0111 0000	                112
    x = x << 2	                1100 0000	                192
    x = x >> 1	                0110 0000	                96
    x = x >> 2	                0001 1000	                24
    Каждый сдвиг влево умножает на 2. Потеря информации произошла после операции x << 2 в результате сдвига за левую 
    границу. Каждый сдвиг вправо делит на 2. Сдвиг вправо потерянную информацию не восстановил.

    Поразрядная операция отрицания(дополнения) ~инвертирует состояние каждого бита операнда.То есть, 0 преобразует в 1,
    а 1 — в 0.

    Поразрядные операции часто используются в процедурах кодирования.Проделав с дисковым файлом некоторые поразрядные 
    операции, его можно сделать нечитаемым.Простейший способ сделать это — применить операцию отрицания к каждому биту:
    Исходный байт 0010100
    После 1 - го отрицания 1101011
    После 2 - го отрицания 0010100

    Обратите внимание, при последовательном применении 2 - х отрицаний результатом всегда будет исходное число. Таким 
    образом, 1 - е отрицание кодирует состояние байта, а 2 - е — декодирует.

    В следующем примере оператор отрицания используется в функции шифрования символа :

    //Простейшая процедура шифрования
    char encode(char ch)
    {
        return(~ch); //оперция отрицания
    }
    Конечно, взломать такой шифр не представляет труда.






    ///////////Операция ?
    В языке С определен мощный и удобный оператор, который часто можно использовать вместо оператора 
    вида if - then - else. Речь идет о тернарном операторе ?, общий вид которого следующий:
    Выражение1 ? Выражение2 : Выражение3;
    Обратите внимание на использование двоеточия.Оператор ? работает следующим образом : сначала вычисляется 
    Выражение1, если оно истинно, то вычисляется Выражение2 и его значение присваивается всему выражению; 
    если Выражение1 ложно, то вычисляется Выражение3 и всему выражению присваивается его значение. В примере
    x = 10;
    y = x > 9 ? 100 : 200;
    переменной у будет присвоено значение 100. Если бы х было меньше 9, то переменной у было бы присвоено значение 200.
    Эту же процедуру можно написать, используя оператор if - else:
    x = 10;
    if (x > 9) y = 100;
    else y = 200;
    Более подробно оператор ? обсуждается в главе 3 в связи с условными операторами.






    ///////////Операция получения адреса(&) и раскрытия ссылки(*)
    Указатель — это адрес объекта в памяти.Переменная типа "указатель" (или просто переменная - указатель) — это 
    специально объявленная переменная, в которой хранится указатель на переменную определенного типа. В языке С 
    указатели служат мощнейшим средством создания программ и широко используются для самых разных целей. Например, 
    с их помощью можно быстро обратиться к элементам массива или дать функции возможность модифицировать свои 
    аргументы. Указатели широко используются для связи элементов в списках, в двоичных деревьях и в других динамических
    структурах данных.Глава 5 полностью посвящена указателям.В данной главе коротко рассматриваются два оператора,
    использующиеся для работы с указателями.

    Первый из них — оператор&, это унарный оператор, возвращающий адрес операнда в памяти[12]. (Унарной операцией 
    называется операция, имеющая только один операнд.) Например, оператор
    m = &count;
    записывает в переменную m адрес переменной count.Этот адрес представляет собой адрес ячейки памяти компьютера, 
    в которой размещена переменная. Адрес и значение переменной — совершенно разные понятия.Выражение "&переменная" 
    означает "адрес переменной". Следовательно, инструкция m = &scount; означает: "Переменной m присвоить адрес, по 
    которому расположена переменная count;".

    Допустим, переменная count расположена в памяти в ячейке с адресом 2000, а ее значение равно 100. Тогда в 
    предыдущем примере переменной m будет присвоено значение 2000.
    */
    int count = 100;
    int* m = &count; //это указатель(pointer), тоесть это переменная предназначенна для хранения адреса и тут мы 
                     //присвоили переменной m, адрес переменной count.
    printf("\n Адрес переменной count: %p \n", m);

    int q = *m; //q получает значение, расположенное по адресу m, а в m лежит знгачение переменной count.
    printf("\n Значение переменной count: %d \n", q);


    /*
    Второй рассматриваемый оператор * является двойственным(дополняющим) по отношению к & [13].Оператор * является 
    унарным оператором, он возвращает значение объекта, расположенного по указанному адресу. Операндом для* служит 
    адрес объекта(переменной).Например, если переменная m содержит адрес переменной count, то оператор
    q = *m;
    записывает значение переменной count в переменную q. В нашем примере переменная q получит значение 100, потому 
    что по адресу 2000 записано число 100, причем этот адрес записан в переменной m. Выражение "* адрес" означает "по 
    адресу". Наш фрагмент программы можно прочесть как "q получает значение, расположенное по адресу m".

    К сожалению, символ операции раскрытия ссылки совпадает с символом операции умножения, а символ операции получения
    адреса — с символом операции поразрядного И.Необходимо помнить, что эти операторы не имеют никакого отношения друг
    к другу.Операторы* и& имеют более высокий приоритет, чем любая арифметическая операция, кроме унарного минуса, 
    имеющего такой же приоритет.

    Если переменная является указателем, то в объявлении перед ее именем нужно поставить символ*, он сообщит 
    компилятору о том, что это указатель на переменную данного типа.Например, объявление указателя на переменную 
    типа char записывается так :

    char* ch;

    Необходимо понимать, что ch — это не переменная типа char, а указатель на переменную данного типа, это совершенно
    разные вещи.Тип данных, на который указывает указатель(в данном случае это char), называется базовым типом 
    указателя[14].Сам указатель является переменной, содержащей адрес объекта базового типа.Компилятор учтет размер
    указателя в архитектуре компьютера и выделит для него необходимое количество байтов, чтобы в указатель поместился
    адрес.Базовый тип указателя определяет тип объекта, хранящегося по этому адресу.

    В одном операторе объявления можно одновременно объявить и указатель, и переменную, не являющуюся указателем.
    Например, оператор
    int x, * y, count;
    объявляет х и count как переменные целого типа, а у — как указатель на переменную целого типа.

    В следующей программе операторы* и& используются для записи значения 10 в переменную target. Программа выведет
    значение 10 на экран.
    #include <stdio.h>
    int main(void)
    {
        int target, source;
        int* m;

        source = 10;
        m = &source;
        target = *m;

        printf("%d", target);

        return 0;
    }





    ЖЕНЯ
    ///////////Операция определения размера sizof
    Унарная операция sizeof, выполняемая во время компиляции программы, позволяет определить длину операнда в байтах.
    Например, если компилятор для чисел типа int отводит 4 байта, а для чисел типа double — 8, то следующая программа
    напечатает 8 4.
    */
    printf("\n Операция определения размера sizof \n ");

    double f;
    printf("%d ", sizeof f);
    printf("%d", sizeof(int));
    /*
    Необходимо помнить, что для вычисления размера типа переменной имя типа должно быть заключено в круглые скобки.
    Имя переменной заключать в скобки не обязательно, но ошибки в этом не будет.

    В языке С определяется(с помощью спецификатора класса памяти typedef) специальный тип size_t, приблизительно 
    соответствующий целому числу без знака. Результат операции sizeof имеет тип size_t. Но практически его можно 
    использовать везде, где допустимо использование целого числа без знака.

    Оператор sizeof очень полезен для улучшения переносимости программ, так как переносимость существенно зависит от
    размеров встроенных типов данных.Для примера рассмотрим программу, работающую с базой данных, в которой необходимо
    хранить шесть целых чисел в одной записи.Если эта программа предназначена для работы на многих компьютерах, ни в
    коем случае нельзя полагаться на то, что размер целого числа на всех компьютерах будет один и тот же.В программе 
    следует определять размер целого, используя оператор sizeof.Соответствующая программа имеет следующий вид:

    // Запись шести целых чисел в дисковый файл.
    void put_rec(int rec[6], FILE * fp)
    {
        int len;

        len = fwrite(rec, sizeof(int) * 6, 1, fp);
        if (len != 1) printf("Ошибка при записи");
    }
    Приведенная функция put_rec() компилируется и выполняется правильно в любой среде, в том числе на 16 - и 32 - 
    разрядных компьютерах.
    И в заключение: оператор sizeof выполняется во время трансляции, его результат в программе рассматривается как
    константа.





    ЖЕНЯ
    ///////////Оператор последовательного вычисления : оператор "запятая"
    Оператор "запятая"[15] связывает воедино несколько выражений. При вычислении левой части оператора "запятая" всегда
    подразумевается, что она имеет тип void.Это значит, что выражение, стоящее справа после оператора "запятая", 
    является значением всего разделенного запятыми выражения. Например, оператор
    x = (y = 3, y + 1);
    сначала присваивает у значение 3, а затем присваивает х значение 4. Скобки здесь обязательны, потому что приоритет
    оператора "запятая" меньший, чем оператора присваивания.
    В операторе "запятая" выполняется последовательность операций.Если этот оператор стоит в правой части оператора 
    присваивания, то его результатом всегда является выражение, стоящее последним в списке.
   
   
   

   
    ЖЕНЯ
    ///////////Оператор доступа к члену структуры(оператор . (точка)) и оператор доступа через указатель -> (оператор
    стрелка)
    В языке С операторы . (точка)и -> (стрелка)обеспечивают доступ к элементам структур и объединений. Структуры и
    объединения — это составные типы данных, в которых под одним именем хранятся многие объекты. (Структуры и 
    объединения подробно рассматриваются в главе 7.)

    Оператор точка используется для прямой ссылки на элемент структуры или объединения, т.е.перед точкой стоит имя 
    структуры, а после — имя элемента структуры.Оператор стрелка используется с указателем на структуру или 
    объединение, т.е.перед стрелкой стоит указатель на структуру. Например, во фрагменте программы

    struct employee
    {
        char name[80];
        int age;
        float wage;
    } emp;

    struct employee* p = &emp;   //адрес emp заносится в p
    для присвоения члену wage значения 123.33 необходимо записать
    emp.wage = 123.23;
    То же самое можно сделать, использовав указатель на структуру:
    p->wage = 123.23;






    ///////////Оператор[] и()
    Круглые скобки являются оператором, повышающим приоритет выполнения операций, которые в них заключены. Квадратные
    скобки служат для индексации массива(массивы подробно рассматриваются в главе 4). Если в программе определен 
    массив, то выражение в квадратных скобках представляет собой индекс массива. Например, в программе

    #include <stdio.h>
    char s[80];

    int main(void)
    {
        s[3] = 'X';
        printf("%c", s[3]);

        return 0;
    }
    значение 'Х' сначала присваивается четвертому элементу массива(в С элементы массива нумеруются с нуля), затем 
    этот элемент выводится на экран.





    ///////////Сводка приоритетов операций
    В табл. 2.8 приведены приоритеты всех операций, определенных в С.Необходимо помнить, что все операторы, кроме 
    унарных и "?", связывают(присоединяют, ассоциируют) свои операнды слева направо.Унарные операторы(*, &, -) и "?" 
    связывают(присоединяют, ассоциируют) свои операнды справа налево.

    Таблица 2.8.Приоритеты опреаций в языке C 
    Наивысший           ()[] -> .
                        !~++ -- - (type) * &sizeof
                        * / %
                        +-
                        << >>
                        < <= > >=
                        == !=
                        &
                        ^
                        |
                        &&
                        ||
                        ? :
                            = += -= *= /= и т.д.
    Наинизший           ,
    ----------

    [1]В данном случае под оператором имеется в виду, конечно, знак операции.По этому поводу см.сделанное ранее 
    примечание редактора о переводе термина operator
    [2]lvalue — именующее выражение, т.е.выражение, которое может стоять в левой части оператора присваивания.
    Под lvalue также часто подразумевается адрес переменной. (С идентификатором переменной в программе связано 
    две величины : адрес переменной и ее значение.Адрес используется, когда переменная стоит в левой части 
    присваивания, значение — в правой части присваивания.) Иногда встречается и термин l - значение. Как бы то ни
    было, этим термином обозначается выражение, которое может находиться в левой части оператора присваивания. 
    Семантически оно представляет собой адрес, по которому размещена переменная, массив, элемент структуры и т.п.
    [3]rvalue — значение переменной; иногда переводится, как r - значение, т.е.значение в правой части оператора 
    присваивания.
    [4]Множественное присваивание — присваивание одного и того же значения нескольким переменным.Под множественным
    присваиванием также подразумевается конструкция языка программирования, позволяющая присвоить одно и то же 
    значение нескольким переменным одновременно.
    [5]По этой причине варианты оператора присваивания, в которых используется такая запись, называются "сокращенными"
    или "укороченными".Что касается терминологии, то необходимо отметить также следующее обстоятельство. Хотя 
    термины присваивание и оператор присваивания часто могут рассматриваться как синонимы, составное присваивание
    не является составным оператором!(Под составным оператором в языке С подразумевают блок.)
    [6]Под "составными" операторами в данном случае, подразумеваются составные знаки операций, т.е.знаки операций, 
    состоящие из нескольких(обычно двух) символов.Составные операторы - блоки не имеют к этому никакого отношения.
    [7]На жаргоне программистов: декрементация.
    [8]На жаргоне программистов: инкрементация.
    [9]Называются также битовыми, побитовыми и логическими операциями.
    [10]Бит контроля четности называется также контрольным двоичным разрядом четности, контрольным разрядом четности, 
    проверочным двоичным разрядом четности, проверочным разрядом четности, битом четности, разрядом четности,
    контрольным битом и битом контроля на четность.Это дополнительный бит, который добавляется к группе(обычно из семи)
    битов.Передающее устройство устанавливает значение бита четности равным нулю или единице так, чтобы сумма битов 
    в каждом байте всегда была четной или нечетной в зависимости от выбора типа проверки — на четность или нечетность.
    Невыполнение условия такой проверки на приемном конце линии означает искажение по крайней мере одного бита при 
    передаче.При обнаружении ошибки принимающее устройство делает запрос на повтор данных.Иными словами, это бит, 
    добавляемый к данным для контроля их верности таким образом, чтобы сумма двоичных единиц, составляющих данное, 
    включая единицу контрольного бита, всегда была четной(либо всегда нечетной).
    [11]Очищение бита — гашение, т.е.занесение нуля.
    [12]Оператор& называется также оператором получения(взятия) адреса.
    [13]Оператор* называется также оператором косвенности, оператором раскрытия ссылки и оператором разыменования адреса.
    [14]Иногда называется также основным или исходным типом.
    [15]Чаще встречается написание без кавычек: оператор запятая. Мы пишем кавычки лишь для того, чтобы новичкам было
    легче воспринимать несколько непривычное для них название оператора.
    */







    printf("\n\n\n/////////// Выражения\n");
    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/02/0211.htm
    /*
    Выражения состоят из операторов, констант, функций и переменных. В языке С выражением является любая правильная
    последовательность этих элементов. Большинство выражений в языке С по форме очень похожи на алгебраические, часто
    их и пишут, руководствуясь правилами алгебры. Однако здесь необходимо быть внимательным и учитывать специфику 
    выражений в языке С.
    
    
    

    
    ///////////Порядок вычислений
    Порядок вычисления подвыражений в выражениях языка С не определен. Компилятор может самостоятельно перестроить
    выражение с целью создания оптимального объектного кода. Это значит, что программист не может полагаться на 
    определенную последовательность вычисления подвыражений. Например, при вычислении выражения
    х = f1() + f2();
    нет никаких гарантий того, что функция f1() будет вызвана перед вызовом f2().




    ///////////Преобразования типов в выражениях
    Если в выражении встречаются переменные и константы разных типов, они преобразуются к одному типу. Компилятор 
    преобразует "меньший" тип в "больший". Этот процесс называется продвижением типов (type promotion). Сначала 
    все переменные типов char и short int автоматически продвигаются в int. Это называется целочисленным расширением.
    (В С99 целочисленное расширение может также завершиться преобразованием в unsigned int.) После этого все остальные
    операции выполняются одна за другой, как описано в приведенном ниже алгоритме преобразования типов:

    IF операнд имеет тип long double
    THEN второй операнд преобразуется в long double
    ELSE IF операнд имеет тип double
    THEN второй операнд преобразуется в double
    ELSE IF операнд имеет тип float
    THEN второй операнд преобразуется в float
    ELSE IF операнд имеет тип unsigned long
    THEN второй операнд преобразуется в unsigned long
    ELSE IF операнд имеет тип long
    THEN второй операнд преобразуется в long
    ELSE IF операнд имеет тип unsigned int
    THEN второй операнд преобразуется в unsigned int

    Для тех, кто еще не знаком с общей формой оператора IF, приводим более русифицированную запись алгоритма:

    ЕСЛИ операнд имеет тип long double
    ТО второй операнд преобразуется в long double
    ИНАЧЕ ЕСЛИ операнд имеет тип double
    ТО второй операнд преобразуется в double
    ИНАЧЕ ЕСЛИ операнд имеет тип float
    ТО второй операнд преобразуется в float
    ИНАЧЕ ЕСЛИ операнд имеет тип unsigned long
    ТО второй операнд преобразуется в unsigned long
    ИНАЧЕ ЕСЛИ операнд имеет тип long
    ТО второй операнд преобразуется в long
    ИНАЧЕ ЕСЛИ операнд имеет тип unsigned int
    ТО второй операнд преобразуется в unsigned int

    Кроме того, действует следующее правило: если один из операндов имеет тип long, а второй — unsigned int, притом 
    значение unsigned int не может быть представлено типом long, то оба операнда преобразуются в unsigned long.
    На заметку	Описание правил целочисленного расширения в С99 см. в части II.
    После выполнения приведенных выше преобразований оба операнда относятся к одному и тому же типу, к этому типу 
    относится и результат операции.

    Рассмотрим пример преобразования типов, приведенный на рис. 2.2. Сначала символ ch преобразуется в целое число. 
    Результат операции ch/i преобразуется в double, потому что результат f*d имеет тип double. Результат операции f+i 
    имеет тип float, потому что f имеет тип float. Окончательный результат имеет тип double.

    Рис. 2.2. Пример преобразования типов

      char    ch;
      int     i;
      float   f;
      double  d;

      r  e  s  u  l  t  =  (  ch  /  i  )  +  (  f  *  d  )  -  (  f  +  i  )  ;
                               |     |           |     |           |     |
                              int    |         double  |           |    float
                               |_____|           |_____|           |_____|
                                  |                 |                 |
                                 int              double             float
                                  |_________________|                 |
                                           |__________________________|
                                                        |
                                                      double






    ///////////Явное преоразование типов: операция приведения типов
    Программист может "принудительно" преобразовать значение выражения к нужному ему типу, используя операцию 
    приведения типов. Общая форма оператора явного приведения типа:
    (тип) выражение
    Здесь тип — это любой поддерживаемый тип данных. Например, следующая запись преобразует значение выражения х/2
    к типу float:

    (float) х/2

    Явное преобразование типа — это операция. Оператор приведения типа является унарным и имеет тот же приоритет, 
    что и остальные унарные операторы.

    Иногда приведение типов может быть весьма полезным. Допустим, целую переменную нужно использовать как параметр 
    цикла, притом в вычислении участвует и дробная часть числа. В следующем примере показано, как с помощью 
    приведения можно сохранить точность:

    #include <stdio.h>

    int main(void) // печать i и i/2 с дробной частью
    {
        int i;

        for (i = 1; i <= 100; ++i)
            printf("%d / 2 is: %f\n", i, (float)i / 2);

        return 0;
    }
    */
    printf("Преобразования типов в выражениях \n");

    for (i = 1; i <= 10; ++i)
            printf("%d / 2 is: %f\n", i, (float)i / 2);
    /*
    Без операции приведения(float) выполнялось бы целочисленное деление.Дробная часть результата выводится благодаря 
    приведению типа переменной i.






    ///////////Пробелы и круглые скобки
    Для повышения удобочитаемости программы при записи выражений можно использовать пробелы и символы табуляции.
    Например, следующие два оператора эквивалентны:
    x = 10 / y~(127 / x);
    x = 10 / y ~(127 / x);

    Лишние скобки, если они не изменяют приоритет операций, не приводят к ошибке и не замедляют вычисление выражения.
    Дополнительные скобки часто используют для прояснения порядка вычислений.В следующем примере 2 - я строка читается
    значительно легче:
    x = y / 3 - 34 * temp + 127;
    x = (y / 3) - (34 * temp) + 127;
    */    
















    printf("\n\n\n/////////// 000\n");
    /*
    
    */
    return 0;
}





// Локальные переменные
void func1(void)
{
    int x = 10;
}

void func2(void)
{
    int x = -199;
}