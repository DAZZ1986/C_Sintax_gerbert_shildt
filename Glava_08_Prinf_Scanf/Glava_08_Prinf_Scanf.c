#include <locale.h>
#include <stdio.h>



int main(void)
{
    char* locale = setlocale(LC_ALL, "");

    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/08/08.htm
    printf("\n\n\n/////////// Ввод / вывод на консоль\n");
    /*
    Ввод / вывод на консоль

    В языке С не определено никаких ключевых слов, с помощью которых можно выполнять ввод/вывод. Вместо них используются 
    библиотечные функции. Система ввода/вывода языка С — это элегантная конструкция, которая обеспечивает гибкий и в то же
    время слаженный механизм передачи данных от одного устройства к другому. Впрочем, эта система достаточно большая и 
    состоит из нескольких различных функций. Заголовочным файлом для функций ввода/вывода является <stdio.h>.

    Имеются как консольные, так и файловые[1] функции ввода/вывода. С практической точки зрения консольный и файловый 
    ввод/вывод отличаются друг от друга очень мало. Однако теоретически они находятся в двух очень "разных мирах". В 
    этой главе подробно рассказывается о функциях ввода/вывода на консоль. В следующей же главе представлена система 
    файлового ввода/вывода, а также говорится, что имеется общего между этими двумя системами.

    За одним исключением, в этой главе рассказывается только о функциях ввода/вывода на консоль, которые определяются 
    стандартом языка С. В стандарте языка С не определены никакие функции, предназначенные для выполнения различных операций
    управления экраном (например, позиционирования курсора) или вывода на него графики. И не определены потому, что эти 
    операции на разных машинах очень сильно отличаются. Кроме того, в стандартном С не определены никакие функции, которые
    выполняют операции вывода в обычном или диалоговом окне, создаваемом в среде Windows. Функции ввода/вывода на консоль 
    выполняют всего лишь телетайпный вывод. Однако в библиотеках большинства компиляторов имеются функции графики и
    управления экраном, предназначенные для той среды, в которой как раз и должны выполняться программы. И, конечно же,
    на языке С можно писать Windows-программы. Просто в С не определены функции, которые выполняли бы эти задачи напрямую.

    В этой главе консольными функциями ввода/вывода называются те, которые выполняют ввод с клавиатуры и вывод на экран. 
    В действительности же эти функции работают со стандартным потоком ввода и стандартным потоком вывода[2]. Более того, 
    стандартный ввод[3] и стандартный вывод[4] могут быть перенаправлены на другие устройства. Таким образом, "консольные
    функции" не обязательно должны работать только с консолью. Перенаправление ввода/вывода описано в главе 9. В данной 
    же главе предполагается, что ни стандартный ввод, ни стандартный вывод на другие устройства не перенаправляются.
    На заметку	В языке C++ ввод/вывод выполняют не только функции, но имеются еще и операторы (знаки операций) ввода/вывода.
    Впрочем, в языке С эти операторы ввода/вывода не поддерживаются.

    Чтение и запись символов
    Чтение и запись строк
    Форматный ввод / вывод на консоль
    printf()
    scanf()


----------
    [1]Ввод/вывод в файл и файловый ввод/вывод — синонимы.
    [2]Иногда говорят, что ввод происходит со стандартного устройства ввода, а вывод — на стандартное устройство вывода.
    [3]Стандартный ввод — логический файл для ввода данных, связываемый с физическим файлом или стандартным выводом другой 
        программы при запуске. По умолчанию стандартный ввод в пакетном режиме связывается со входным потоком, а в диалоговом 
        режиме — с терминалом.
    [4]Стандартный вывод — логический файл вывода данных, связываемый с физическим файлом или стандартным вводом другой 
        программы при запуске. По умолчанию стандартный вывод в пакетном режиме связывается с выходным потоком, а в диалоговом
        режиме — с терминалом.
    */









    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/08/0801.htm
    printf("\n\n\n/////////// Чтение и запись символов\n");
    /*
    Самыми простыми из консольных функций ввода/вывода являются getchar(), которая читает символ с клавиатуры, и putchar(),
    которая отображает символ на экране. Первая из этих функций ожидает, пока не будет нажата клавиша, а затем возвращает 
    значение этой клавиши. Кроме того, при нажатии клавиши на клавиатуре на экране дисплея автоматически отображается
    соответствующий символ. Вторая же функция, putchar(), отображает символ на экране в текущей позиции курсора. Вот 
    прототипы функций getchar() и putchar():

    int getchar(void);
    int putchar(int c);

    Как видно из прототипа, считается, что функция getchar() возвращает целый результат. Однако возвращаемое значение можно
    присвоить переменной типа char, что обычно и делается, так как символ содержится в младшем байте. (Старший байт при 
    этом обычно обнулен.) В случае ошибки getchar() возвращает EOF. (Макрос EOF определяется в <stdio.h> и часто равен -1.)

    Что же касается putchar(), то несмотря на то, что эта функция объявлена как принимающая целый параметр, она обычно
    вызывается с символьным аргументом. На самом деле из ее аргумента на экран выводится только младший байт. Функция 
    putchar() возвращает записанный символ или, в случае ошибки, EOF.

    В следующей программе продемонстрировано применение getchar() и putchar(). В этой программе с клавиатуры вводятся 
    символы, а затем они отображаются на другом регистре. То есть символы, вводимые на верхнем регистре, выводятся на
    нижнем, а вводимые на нижнем — выводятся на верхнем. Чтобы остановить программу, введите точку.

    #include <stdio.h>
    #include <ctype.h>

    int main(void)
    {
      char ch;

      printf("Введите какой-нибудь текст
              (для завершения работы введите точку).\n");
      do {
        ch = getchar();

        if(islower(ch)) ch = toupper(ch);
        else ch = tolower(ch);

        putchar(ch);
      } while (ch != '.');

      return 0;
    }
    (Эта программа не работает, правда, с кириллическими символами.)






    ///////////Трудности использования getchar()
    Использование getchar() может быть связано с определенными трудностями. Во многих библиотеках компиляторов эта функция
    реализуется таким образом, что она заполняет буфер ввода до тех пор, пока не будет нажата клавиша <ENTER>. Это называется
    построчно буферизованным вводом. Чтобы функция getchar() возвратила какой-либо символ, необходимо нажать клавишу <ENTER>.
    Кроме того, эта функция при каждом ее вызове вводит только по одному символу. Поэтому сохранение в буфере целой строки 
    может привести к тому, что в очереди на ввод останутся ждать один или несколько символов, а в интерактивной среде это 
    раздражает достаточно сильно. Хотя getchar() и можно использовать в качестве интерактивной функции, но это делается
    редко. Так что если предшествующая программа ведет себя не так, как ожидалось, то вы теперь знаете, в чем тут дело.
    
    

    
    
    
    ///////////Альтернативы getchar()
    Так как getchar(), имеющаяся в библиотеке компилятора, может оказаться неподходящей в интерактивной среде, то для 
    чтения символов с клавиатуры может потребоваться другая функция. В стандарте языка С не определяется никаких функций, 
    которые гарантировали бы интерактивный ввод, но их определения имеются буквально в библиотеках всех компиляторов С. 
    И пусть в стандарте С эти функции не определены, но известны они всем! А известны они благодаря функции getchar(), 
    которая для большинства программистов явно не подходит.

    У двух из самых распространенных альтернативных функций getch() и getche() имеются следующие прототипы:
    int getch(void);
    int getche(void);

    В библиотеках большинства компиляторов прототипы таких функций находятся в заголовочном файле <conio.h>. В библиотеках
    некоторых компиляторов имена этих функций начинаются со знака подчеркивания (_). Например, в Visual C++ компании 
    Microsoft они называются _getch() и _getche().

    Функция getch() ожидает нажатия клавиши, после которого она немедленно возвращает значение. Причем, символ, введенный
    с клавиатуры, на экране не отображается. Имеется еще и функция getche(), которая хоть и такая же, как getch(), но
    символ на экране отображает. И если в интерактивной программе необходимо прочитать символ с клавиатуры, то часто 
    вместо getchar() применяется getche() или getch(). Вот, например, предыдущая программа, в которой getchar() заменена
    функцией getch():

    #include <stdio.h>
    #include <conio.h>
    #include <ctype.h>

    int main(void)
    {
      char ch;

      printf("Введите какой-нибудь текст
              (для завершения работы введите точку).\n");
      do {
        ch = getch();

        if(islower(ch)) ch = toupper(ch);
        else ch = tolower(ch);

        putchar(ch);
      } while (ch != '.');

      return 0;
    }
    Когда выполняется эта версия программы, при каждом нажатии клавиши соответствующий символ сразу передается программе
    и выводится на другом регистре. А ввод в строках не буферизируется. И хотя в кодах в этой книге функции getch() и
    getche() больше не встречаются, но они вполне могут пригодиться в тех программах, которые напишете вы.
    
    На заметку: Тогда: когда писались эти слова, при использовании компилятора Visual C++ компании Microsoft 
    функции _getch() и getch() были несовместимы с функциями ввода стандартного С, например, с функциями scanf() или gets().
    Поэтому вам придется вместо стандартных функций использовать такие их специальные версии, как cscanf() или cgets(). 
    Чтобы получить более подробную информацию, следует изучить документацию по Visual C++.
    */








    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/08/0802.htm
    printf("\n\n\n/////////// Чтение и запись строк\n");
    /*
    Среди функций ввода/вывода на консоль есть и более сложные, но и более мощные: это функции gets() и puts(), которые позволяют считывать и отображать строки символов.

    Функция gets() читает строку символов, введенную с клавиатуры, и записывает ее в память по адресу, на который указывает ее аргумент. Символы можно вводить с клавиатуры до тех пор, пока не будет введен символ возврата каретки. Он не станет частью строки, а вместо него в ее конец будет помещен символ конца строки ('0'), после чего произойдет возврат из функции gets(). На самом деле вернуть символ возврата каретки с помощью этой функции нельзя (а с помощью getchar() — как раз можно). Перед тем как нажимать <ENTER>, можно исправлять неправильно введенные символы, пользуясь для этого клавишей возврата каретки на одну позицию (клавишей backspace). Вот прототип для gets():

    char *gets(char *cmp);

    Здесь cmp — это указатель на массив символов, в который записываются символы, вводимые пользователем, gets() также возвращает cmp. Следующая программа читает строку в массив str и выводит ее длину:

    #include <stdio.h>
    #include <string.h>

    int main(void)
    {
      char str[80];

      gets(str);
      printf("Длина в символах равна %d", strlen(str));

      return 0;
    }

    Необходимо очень осторожно использовать gets(), потому что эта функция не проверяет границы массива, в который
    записываются введенные символы. Таким образом, может случиться, что пользователь введет больше символов, чем помещается
    в этом массиве. Хотя функция gets() прекрасно подходит для программ-примеров и простых утилит, предназначенных только
    для вас, но в профессиональных программах ею лучше не пользоваться. Ее альтернативой, позволяющей предотвратить 
    переполнение массива, будет функция fgets(), которая описана в следующей главе.

    Функция puts() отображает на экране свой строковый аргумент, после чего курсор переходит на новую строку. Вот прототип 
    этой функции:

    int puts(const char *cmp);

    puts() признает те же самые управляющие последовательности[1], что и printf(), например, \t в качестве символа табуляции. 
    Вызов функции puts() требует намного меньше ресурсов, чем вызов printf(). Это объясняется тем, что puts() может только
    выводить строку символов, но не может выводить числа или делать преобразования формата. В результате эта функция 
    занимает меньше места и выполняется быстрее, чем printf(). Поэтому тогда, когда не нужны преобразования формата, часто
    используется функция puts().

    Функция puts() в случае успешного завершения возвращает неотрицательное значение, а в случае ошибки — EOF. Однако при 
    записи на консоль обычно предполагают, что ошибки не будет, поэтому значение, возвращаемое puts(), проверяется редко.
    Следующий оператор выводит фразу Привет:

    puts("Привет");

    В таблице 8.1 перечислены основные функции консольного ввода/вывода.
    Функция	    Ее действия
    getchar()	Читает символ с клавиатуры; обычно ожидает возврат каретки.
    getche()	Читает символ, при этом он отображается на экране; не ожидает возврата каретки; в стандарте С не определена, 
                но распространена достаточно широко.
    getch()	    Читает символ, но не отображает его на экране; не ожидает возврата каретки; в стандарте С не определена, но 
                распространена достаточно широко.
    putchar()	Отображает символ на экране.
    gets()	    Читает строку с клавиатуры.
    puts()	    Отображает строку на экране.

    В следующей программе — простом компьютеризованном словаре — показано применение нескольких основных функций консольного
    ввода/вывода. Эта программа предлагает пользователю ввести слово, а затем проверяет, совпадает ли оно с каким-либо из тех
    слов, что находятся в ее базе данных. Если оно там есть, то программа выводит значение слова. Обратите особое внимание 
    на использование косвенной адресации в этой программе. Чтобы легче было понять программу, прежде всего вспомните, что 
    массив dic — это массив указателей на строки. Обратите внимание, что список должен завершаться двумя нулями.

    //Простой словарь
    #include <stdio.h>
    #include <string.h>
    #include <ctype.h>

    //список слов и их значений
    char* dic[][40] = {
      "атлас", "Том географических и/или топографических карт.",
      "автомобиль", "Моторизоравонное средство передвижения.",
      "телефон", "Средство связи.",
      "самолет", "Летающая машина.",
      "", ""  /* нули, завершающие список
    };

    int main(void)
    {
        char word[80], ch;
        char** p;

        do {
            puts("\nВведите слово: ");
            scanf("%s", word);

            p = (char**)dic;

            //поиск слова в словаре и вывод его значения
            do {
                if (!strcmp(*p, word)) {
                    puts("Значение:");
                    puts(*(p + 1));
                    break;
                }
                if (!strcmp(*p, word)) break;
                p = p + 2;  /* продвижение по списку
            } while (*p);
            if (!*p) puts("Слово в словаре отсутствует.");
            printf("Будете еще вводить? (y/n): ");
            scanf(" %c%*c", &ch);
        } while (toupper(ch) != 'N');

        return 0;
    }

    ----------
    [1]Называются также ESC - последовательностями; в C / C++ — это комбинация символов, обычно используемая для задания 
    неотображаемых символов и символов, имеющих специальное значение.Представление управляющих последовательностей 
    начинается с обратной косой черты.

    */








    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/08/0803.htm
    printf("\n\n\n/////////// Форматный ввод / вывод на консоль\n");
    /*
    Функции printf() и scanf() выполняют форматный ввод и вывод, то есть они могут читать и писать данные в разных форматах. 
    Данные на консоль выводит printf(). А ее "дополнение", функция scanf(), наоборот — считывает данные с клавиатуры. Обе 
    функции могут работать с любым встроенным типом данных, а также с символьными строками, которые завершаются символом 
    конца строки ('0').
    */







    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/08/0804.htm
    printf("\n\n\n/////////// printf() \n");
    /*
    Вот прототип функции printf():

    int printf(const char *управляющая_строка, ...);

    Функция printf() возвращает число выведенных символов или отрицательное значение в случае ошибки.
    Управляющая_строка[1] состоит из элементов двух видов. Первый из них — это символы, которые предстоит вывести на экран;
    второй — это спецификаторы преобразования[2], которые определяют способ вывода стоящих за ними аргументов. Каждый такой
    спецификатор начинается со знака процента, за которым следует код формата. Аргументов должно быть ровно столько, сколько
    и спецификаторов, причем спецификаторы преобразования и аргументы должны попарно соответствовать друг другу в направлении
    слева направо. Например, в результате такого вызова printf()

    printf("Мне нравится язык %c %s", 'C', "и к тому же очень сильно!");

    Будет выведено
    "Мне нравится язык C и к тому же очень сильно!"

    В этом примере первому спецификатору преобразования (%c), соответствует символ 'C', а второму (%s), — строка "и к тому
    же очень сильно!".

    В функции printf(), как видно из табл. 8.2, имеется широкий набор спецификаторов преобразования.
    Таблица 8.2. Спецификаторы преобразования для функции printf() 
    Код	Формат
    %a	Шестнадцатеричное в виде 0xh.hhhhp+d (только С99)
    %A	Шестнадцатеричное в виде 0Xh.hhhhP+d (только С99)
    %c	Символ
    %d	Десятичное целое со знаком
    %i	Десятичное целое со знаком
    %e	Экспоненциальное представление ('е' на нижнем регистре)
    %E	Экспоненциальное представление ('Е' на верхнем регистре)
    %f	Десятичное с плавающей точкой
    %g	В зависимости от того, какой вывод будет короче, используется %е или %f
    %G	В зависимости от того, какой вывод будет короче, используется %Е или %F
    %o	Восьмеричное без знака
    %s	Строка символов
    %u	Десятичное целое без знака
    %x	Шестнадцатеричное без знака (буквы на нижнем регистре)
    %X	Шестнадцатеричное без знака (буквы на верхнем регистре)
    %p	Выводит указатель
    %n	Аргумент, соответствующий этому спецификатору, должен быть указателем на целочисленную переменную. Спецификатор позволяет сохранить в этой переменной количество записанных символов (записанных до того места, в котором находится код %n)
    %%	Выводит знак %







    ///////////Вывод символов
    Для вывода отдельного символа используйте %с. В результате соответствующий аргумент будет выведен на экран без изменения.
    Для вывода строки используйте %s.







    ///////////Вывод чисел
    Числа в десятичном формате со знаком отображаются с помощью спецификатора преобразования %d или %i. Эти спецификаторы
    преобразования эквивалентны; оба поддерживаются в силу сложившихся привычек программистов, например, из-за желания 
    поддерживать те же спецификаторы, которые применяются в функции scanf().

    Для вывода целого значения без знака используйте %u.

    Спецификатор преобразования %f дает возможность выводить числа в формате с плавающей точкой. Соответствующий аргумент 
    должен иметь тип double.

    Спецификаторы преобразования %e и %E в функции printf() позволяют отображать аргумент типа double в экспоненциальном 
    формате. В общем виде числа в таком формате выглядят следующим образом:

    x.dddddE+/-yy

    Чтобы отобразить букву E в верхнем регистре, используйте спецификатор преобразования %E; в противном случае используйте
    спецификатор преобразования %e.

    Спецификатор преобразования %g или %G указывает, что функции printf() необходимо выбрать один из спецификаторов:
    %f или %e. В результате printf() выберет тот спецификатор преобразования, который позволяет сделать самый короткий 
    вывод. Если нужно, чтобы при выборе экспоненциального формата буква E отображалась на верхнем регистре, используйте 
    спецификатор преобразования %G; в противном случае используйте спецификатор преобразования %g.

    Применение спецификатора преобразования %g показано в следующей программе:
    #include <stdio.h>

    int main(void)
    {
      double f;

      for(f=1.0; f<1.0e+10; f=f*10)
        printf("%g ", f);

      return 0;
    }

    В результате выполнения получится следующее:
    1  10  100  1000  10000  100000  1e+06  1e+07  1e+08  1e+09

    Целые числа без знака можно выводить в восьмеричном или шестнадцатеричном формате, используя спецификатор 
    преобразования %o или %x. Так как в шестнадцатеричной системе для представления чисел от 10 до 15 используются 
    буквы от А до F, то эти буквы можно выводить на верхнем или на нижнем регистре. Как показано ниже, в первом случае
    используется спецификатор преобразования %X, а во втором — спецификатор преобразования %x:
    #include <stdio.h>

    int main(void)
    {
      unsigned num;

      for(num=0; num < 16; num++) {
        printf("%o ", num);
        printf("%x ", num);
        printf("%X\n", num);
      }

      return 0;
    }

    Вот что вывела эта программа:
    0 0 0
    1 1 1
    2 2 2
    3 3 3
    4 4 4
    5 5 5
    6 6 6
    7 7 7
    10 8 8
    11 9 9
    12 a A
    13 b B
    14 c C
    15 d D
    16 e E
    17 f F







    ///////////Отображение адреса
    Для отображения адреса используйте спецификатор преобразования %p. Этот спецификатор преобразования дает printf() 
    указание отобразить машинный адрес в формате, совместимом с адресацией, которая используется компьютером. Следующая 
    программа отображает адрес переменной sample:
    #include <stdio.h>

    int sample;

    int main(void)
    {
      printf("%p", &sample);

      return 0;
    }






    ///////////Спецификатор преобразования %n
    Спецификатор %n довольно значительно отличается от остальных спецификаторов преобразования. Когда функция printf() 
    встречает его, ничто не выводится. Вместо этого выполняется совсем другое действие: в целую переменную, указанную 
    соответствующим аргументом функции, записывается количество выведенных символов. Другими словами, значение, которое 
    соответствует спецификатору преобразования %n, должно быть указателем на переменную. После завершения вызова printf()
    в этой переменной будет храниться количество символов, выведенных до того момента, когда встретился спецификатор 
    преобразования %n. Чтобы уяснить смысл этого несколько необычного спецификатора преобразования, разберитесь, как 
    работает следующая программа:
    #include <stdio.h>

    int main(void)
    {
      int count;

      printf("this%n is a test\n", &count);
      printf("%d", count);

      return 0;
    }
    Программа отображает строку Это проверка, после которой появляется число 3. Спецификатор преобразования %n в основном
    используется в программе для выполнения динамического форматирования.







    ///////////Модификаторы формата
    Во многих спецификаторах преобразования можно указать модификаторы[3], которые слегка меняют их значение. Например, можно
    указывать минимальную ширину поля, количество десятичных разрядов и выравнивание по левому краю. Модификатор формата 
    помещают между знаком процента и кодом формата. Об этих модификаторах сейчас и пойдет речь.






    ///////////Модификаторы минимальной ширины поля
    Целое число, расположенное между знаком % и кодом формата, играет роль модификатора минимальной ширины поля. Если указан
    модификатор минимальной ширины поля, то чтобы ширина поля вывода была не меньше указанной минимальной длины, при 
    необходимости вывод будет дополнен пробелами. Если же выводятся строки или числа, которые длиннее указанного минимума,
    то они все равно будут отображаться полностью. По умолчанию для дополнения используются пробелы. А если для этого надо
    использовать нули, то перед модификатором ширины поля следует поместить 0. Например, %05d означает, что любое число, 
    количество цифр которого меньше пяти, будет дополнено таким количеством нулей, чтобы число состояло из пяти цифр. В
    следующей программе показано, как применяется модификатор минимальной ширины поля:
    #include <stdio.h>

    int main(void)
    {
      double item;

      item = 10.12304;

      printf("%f\n", item);
      printf("%10f\n", item);
      printf("%012f\n", item);

      return 0;
    }

    Вот что выводится при выполнении этой программы:
    10.123040
     10.123040
    00010.123040

    Модификатор минимальной ширины поля чаще всего используется при создании таблиц, в которых столбцы должны быть выровнены
    по вертикали. Например, следующая программа выводит таблицу квадратов и кубов чисел от 1 до 19:
    #include <stdio.h>

    int main(void)
    {
      int i;

      //вывод таблицы квадратов и кубов
        for (i = 1; i < 20; i++)
            printf("%8d %8d %8d\n", i, i * i, i * i * i);

        return 0;
    }

    А вот пример полученного с ее помошью вывода:
    1       1       1
    2       4       8
    3       9      27
    4      16      64
    5      25     125
    6      36     216
    7      49     343
    8      64     512
    9      81     729
    10     100    1000
    11     121    1331
    12     144    1728
    13     169    2197
    14     196    2744
    15     225    3375
    16     256    4096
    17     289    4913
    18     324    5832
    19     361    6859






    ///////////Модификаторы точности
    Модификатор точности следует за модификатором минимальной ширины поля(если таковой имеется).Он состоит из точки и 
    расположенного за ней целого числа.Значение этого модификатора зависит от типа данных, к которым его применяют.

    Когда модификатор точности применяется к данным с плавающей точкой, для преобразования которых используются спецификаторы
    преобразования% f, % e или% E, то он определяет количество выводимых десятичных разрядов.Например, % 10.4f означает, 
    что ширина поля вывода будет не менее 10 символов, причем для десятичных разрядов будет отведено четыре позиции.

    Если модификатор точности применяется к% g или% G, то он определяет количество значащих цифр.

    Примененный к строкам, модификатор точности определяет максимальную длину поля.Например, % 5.7s означает, что длина 
    выводимой строки будет составлять минимум пять и максимум семь символов.Если строка окажется длиннее, чем максимальная
    длина поля, то конечные символы выводиться не будут.

    Если модификатор точности применяется к целым типам, то он определяет минимальное количество цифр, которые будут 
    выведены для каждого из чисел.Чтобы получилось требуемое количество цифр, добавляется некоторое количество ведущих нулей.

    В следующей программе показано, как можно использовать модификатор точности:
    #include <stdio.h>

    int main(void)
    {
        printf("%.4f\n", 123.1234567);
        printf("%3.8d\n", 1000);
        printf("%10.15s\n", "Это простая проверка.");

        return 0;
    }

    Вот что выводится при выполнении этой программы:
    123.1235
    00001000
    Это простая про






    ///////////Выравнивание вывода
    По умолчанию весь вывод выравнивается по правому краю.То есть если ширина поля больше ширины выводимых данных, то эти
    данные располагаются по правому краю поля.Вывод по левому краю можно назначить принудительно, поместив знак минус прямо
    за% .Например, % -l0.2f означает, что число с плавающей точкой и с двумя десятичными разрядами будет выровнено по левому
    краю 10 - символьного поля.

    В следующей программе показано, как применяется выравнивание по левому краю:
    #include <stdio.h>

    int main(void)
    {
        printf(".........................\n");
        printf("по правому краю: %8d\n", 100);
        printf(" по левому краю: %-8d\n", 100);

        return 0;
    }

    И вот что получилось :
    .........................
    по правому краю : 100
    по левому краю : 100






    ///////////Обработка данных других типов
    Некоторые модификаторы в вызове функции printf() позволяют отображать целые числа типа short и long.Такие модификаторы 
    можно использовать для следующих спецификаторов типа : d, i, o, u и x.Модификатор l(эль) в вызове функции printf() 
    указывает, что за ним следуют данные типа long.Например, % ld означает, что надо выводить данные типа long int.
    После модификатора h функция printf() выведет целое значение в виде short.Например, % hu означает, что выводимые данные
    имеют тип short unsigned int.

    Модификаторы l и h можно также применить к спецификатору n.Это делается с той целью, чтобы показать — соответствующий 
    аргумент является указателем соответственно на длинное(long) или короткое(short) целое.

    Если компилятор поддерживает обработку символов в расширенном 16 - битном алфавите, добавленную Поправкой 1 от 1995 
    года(1995 Amendment 1), то для указания символа в расширенном 16 - битном алфавите вы можете применять модификатор 1
    для спецификатора преобразования c.Кроме того, для указания строки из символов в расширенном 16 - битном алфавите
    можно применять модификатор 1 для спецификатора преобразования s.

    Модификатор L может находиться перед спецификаторами преобразования с плавающей точкой e, f и g, и указывать этим, 
    что преобразуется значение long double.

    В Стандарте С99 вводится два новых модификатора формата : hh и ll.Модификатор hh можно применять для спецификаторов
    преобразования d, i, o, u, x или n.Он показывает, что соответствующий аргумент является значением signed или unsigned
    char или, в случае n, указателем на переменную signed char.Модификатор ll также можно применять для спецификаторов 
    преобразования d, i, o, u, x или n.Он показывает, что соответствующий аргумент является значением signed или unsigned 
    long long int или, в случае n, указателем на long long int.В С99 также разрешается применять l для спецификаторов 
    преобразования с плавающей точкой a, е, f и g; впрочем, это не дает никакого результата.
    На заметку	В составе С99 имеются некоторые дополнительные модификаторы типа для функции printf(); о них рассказывается
    в части II.






    ///////////Модификатор * и #
    Для некоторых из своих спецификаторов преобразования функция printf() поддерживает два дополнительных модификатора : *и #.

    Непосредственное расположение # перед спецификаторами преобразования g, G, f, Е или e означает, что при выводе обязательно
    появится десятичная точка — даже если десятичных цифр нет.Если вы поставите # непосредственно перед x или X, то 
    шестнадцатеричное число будет выведено с префиксом 0x.Если # будет непосредственно предшествовать спецификатору 
    преобразования o, число будет выведено с ведущим нулем.К любым другим спецификаторам преобразования модификатор # 
    применять нельзя. (В С99 модификатор # можно применять по отношению к преобразованию% а; это значит, что обязательно 
    будет выведена десятичная точка.)

    Модификаторы минимальной ширины поля и точности можно передавать функции printf() не как константы, а как аргументы.
    Для этого в качестве заполнителя используйте звездочку(*).При сканировании строки формата функция printf() будет каждой 
    звездочке* из этой строки ставить в соответствие очередной аргумент, причем в том порядке, в каком расположены аргументы.
    Например, при выполнении оператора, показанного на рис. 8.1, минимальная ширина поля будет равна 10 символам, 
    точность — 4, а отображаться будет число 123.3.

    В следующей программе показано применение обоих модификаторов # и *:
    #include <stdio.h>

    int main(void)
    {
        printf("%x %#x\n", 10, 10);
        printf("%*.*f", 10, 4, 1234.34);

        return 0;
    }


    printf("%*.*f", 10.4, 123.3);
    | |     |     |
    '-+-----'     |
    |           |
    '-----------'
    Рис. 8.1.Обратите внимание на то, каким образом звездочке(*) ставится в соответствие определенное значение


    ----------
    [1]Часто называется просто форматной строкой, форматным стрингом или форматом.
    [2]Называются также спецификациями формата.
    [3]Называются также спецификаторами.
    */









    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/08/0805.htm
    printf("\n\n\n/////////// scanf()\n");
    /*
    Функция scanf() — это программа ввода общего назначения, выполняющая ввод с консоли. Она может читать данные всех 
    встроенных типов и автоматически преобразовывать числа в соответствующий внутренний формат, scanf() во многом выглядит
    как обратная к printf(). Вот прототип функции scanf():

    int scanf(const char *управляющая_строка, ...);

    Эта функция возвращает количество тех элементов данных, которым было успешно присвоено значение. В случае ошибки scanf()
    возвращает EOF, управляющая_строка определяет преобразование считываемых значений при записи их переменные, на которые
    указывают элементы списка аргументов.

    Управляющая строка состоит из символов трех видов:
        - спецификаторов преобразования,
        - разделителей,
        - символов, не являющихся разделителями.

    Теперь поговорим о каждом из этих видов.







    ///////////Спецификаторы преобразования
    Каждый спецификатор формата ввода начинается со знака %, причем спецификаторы формата ввода сообщают функции scanf() 
    тип считываемых данных. Перечень этих кодов (т.е. литер-спецификаторов) приведен в табл. 8.3. Спецификаторам 
    преобразования в порядке слева направо ставятся в соответствие элементы списка аргументов. Рассмотрим некоторые примеры.

    Таблица 8.3. Спецификаторы преобразования для функции scanf() 
    Код	Значение
    %a	Читает значение с плавающей точкой (только С99)
    %c	Читает одиночный символ
    %d	Читает десятичное целое число
    %i	Читает целое число как в десятичном, так и восьмеричном или шестнадцатеричном формате
    %e	Читает число с плавающей точкой
    %f	Читает число с плавающей точкой
    %g	Читает число с плавающей точкой
    %о	Читает восьмеричное число
    %s	Читает строку
    %x	Читает шестнадцатеричное число
    %p	Читает указатель
    %n	Принимает целое значение, равное количеству уже считанных символов
    %u	Читает десятичное целое число без знака
    %[]	Читает набор сканируемых символов
    %%	Читает знак процента
    
    
    
    
    
    
    
    ///////////Ввод чисел
    Для чтения целого числа используйте спецификатор преобразования %d или %i. A для чтения числа с плавающей точкой, 
    представленного в стандартном или экспоненциальном виде, используйте спецификатор преобразования %e, %f или %g. 
    (Кроме того, для чтения числа с плавающей точкой стандарт С99 разрешает использовать также спецификатор преобразования %a.)

    Функцию scanf() можно использовать для чтения целых значений в восьмеричной или шестнадцатеричной форме, применяя для 
    этого соответственно команды форматирования %o и %x, последняя из которых может быть как на верхнем, так и на нижнем 
    регистре. Когда вводятся шестнадцатеричные числа, то буквы от А до F, представляющие шестнадцатеричные цифры, должны быть
    на том же самом регистре, что и литера-спецификатор. Следующая программа читает восьмеричное и шестнадцатеричное число:
    #include <stdio.h>

    int main(void)
    {
      int i, j;

      scanf("%o%x", &i, &j);
      printf("%o %x", i, j);

      return 0;
    }
    Функция scanf() прекращает чтение числа тогда, когда встречается первый нечисловой символ.








    ///////////Ввод целых значений без знака
    Для ввода целого значения без знака используйте спецификатор формата %u. Например, операторы
    unsigned num;
    scanf("%u", &num);
    выполняют считывание целого числа без знака и присваивают его переменной num.







    ///////////Чтение одиночных символов с помощью scanf()
    Как уже говорилось в этой главе, одиночные символы можно прочитать с помощью функции getchar() или какой-либо функции, 
    родственной с ней. Для той же цели можно использовать также вызов функции scanf() со спецификатором формата %c. Но, как
    и большинство реализаций getchar(), функция scanf() при использовании спецификатора преобразования %c обычно будет 
    выполнять построчно буферизованный ввод. В интерактивной среде такая ситуация вызывает определенные трудности.

    При чтении одиночного символа символы разделителей читаются так же, как и любой другой символ, хотя при чтении данных 
    других типов разделители интерпретируются как разделители полей. Например, при вводе с входного потока "x y" фрагмент кода
    scanf("%c%c%c", &a, &b, &c);

    помещает символ x в a, пробел — в b, а символ y — в c.






    ///////////Чтение строк
    Для чтения из входного потока строки можно использовать функцию scanf() со спецификатором преобразования %s. 
    Использование спецификатора преобразования %s заставляет scanf() читать символы до тех пор, пока не встретится какой-либо
    разделитель. Читаемые символы помещаются в символьный массив, на который указывает соответствующий аргумент, а после 
    введенных символов еще добавляется символ конца строки ('0'). Что касается scanf(), то таким разделителем может быть 
    пробел, разделитель строк, табуляция, вертикальная табуляция или подача страницы. В отличие от gets(), которая читает 
    строку, пока не будет нажата клавиша <ENTER>, scanf() читает строку до тех пор, пока не встретится первый разделитель.
    Это означает, что scanf() нельзя использовать для чтения строки "это испытание", потому что после пробела процесс 
    чтения прекратится. Чтобы увидеть, как действует спецификатор %s, попробуйте при выполнении этой программы ввести
    строку "привет всем":

    #include <stdio.h>

    int main(void)
    {
      char str[80];

      printf("Введите строку: ");
      scanf("%s", str);
      printf("Вот Ваша строка: %s", str);

      return 0;
    }
    Программа выведет только часть строки, то есть слово привет.







    ///////////Ввод адреса
    Для ввода какого-либо адреса памяти используйте спецификатор преобразования %p. Этот спецификатор преобразования 
    заставляет функцию scanf() читать адрес в том формате, который определен архитектурой центрального процессора.
    Например, следующая программа вначале вводит адрес, а затем отображает то, что находится в памяти по этому адресу:
    #include <stdio.h>

    int main(void)
    {
      char *p;

      printf("Введите адрес: ");
      scanf("%p", &p);
      printf("По адресу %p находится %c\n", p, *p);

      return 0;
    }

    
    
    
    
    
    
    ///////////Спецификатор %n
    Спецификатор %n указывает, что scanf() должна поместить количество символов, считанных (до того момента, когда 
    встретился %n) из входного потока в целую переменную, указанную соответствующим аргументом.
   
   
    
    
    
    
    
    ///////////Использование набора сканируемых символов
    Функция scanf() поддерживает спецификатор формата общего назначения, называемый набором сканируемых символов (scanset). 
    Набор сканируемых символов представляет собой множество символов. Когда scanf() обрабатывает такое множество, то 
    вводит только те символы, которые входят в набор сканируемых символов. Читаемые символы будут помещаться в массив символов,
    который указан аргументом, соответствующим набору сканируемых символов. Этот набор определяется следующим образом: 
    все те символы, которые предстоит сканировать, помещают в квадратные скобки. Непосредственно перед открывающей 
    квадратной скобкой должен находиться знак %. Например, следующий набор сканируемых символов дает указание scanf() 
    сканировать только символы X, Y и Z:
    %[XYZ]

    При использовании набора сканируемых символов функция scanf() продолжает читать символы, помещая их в соответствующий
    массив символов, пока не встретится символ, не входящий в этот набор. При возвращении из scanf() в массиве символов 
    будет находиться строка, состоящая из считанных символов, причем эта строка будет заканчиваться символом конца строки. 
    Чтобы увидеть, как это все работает, запустите следующую программу:
    #include <stdio.h>

    int main(void)
    {
      int i;
      char str[80], str2[80];

      scanf("%d%[abcdefg]%s", &i, str, str2);
      printf("%d %s %s", i, str, str2);

      return 0;
    }

    Введите 123abcdtye, а затем нажмите клавишу <ENTER>. После этого программа выведет 123 abed tye. Так как в данном 
    случае 't' не входит в набор сканируемых символов, то scanf() прекратила чтение символов в переменную str сразу после
    того, как встретился символ 't'. Оставшиеся символы были помещены в переменную str2.

    Кроме того, можно указать набор сканируемых символов, работающий с точностью до наоборот; тогда первым символом в таком 
    наборе должен быть ^. Этот символ дает указание scanf() принимать любой символ, который не входит в набор сканируемых
    символов.

    В большинстве реализаций для указания диапазона можно использовать дефис. Например, указанный ниже набор сканируемых 
    символов дает функции scanf() указание принимать символы от А до Z:
    %[A-Z]

    Следует обратить внимание на такой важный момент: набор сканируемых символов чувствителен к регистру букв. Если нужно 
    сканировать буквы и на верхнем, и на нижнем регистре, то их надо указывать отдельно для каждого регистра.






    ///////////Пропуск лишних разделителей
    Разделитель в управляющей строке дает scanf() указание пропустить в потоке ввода один или несколько начальных 
    разделителей. Разделителями являются пробелы, табуляции, вертикальные табуляции, подачи страниц и разделители строк. 
    В сущности, один разделитель в управляющей строке заставляет scanf() читать, но не сохранять любое количество (в том 
    числе и нулевое) разделителей, которые находятся перед первым символом, не являющимся разделителем.
    
    
    
    
    
    
    ///////////Символы в управляющей строке, не являющиеся разделителями
    Если в управляющей строке находится символ, не являющийся разделителем, то функция scanf() прочитает символ из входного 
    потока, проверит, совпадает ли прочитанный символ с указанным в управляющей строке, и в случае совпадения пропустит 
    прочитанный символ. Например, "%d,%d" заставляет scanf() прочитать целое значение, прочитать запятую и пропустить ее 
    (если это была запятая!), а затем прочитать следующее целое значение. Если же указанный символ во входном потоке не 
    будет найден, то scanf() завершится. Когда нужно прочитать и отбросить знак процента, то в управляющей строке следует 
    указать %%.
    
    
    
    
    
    ///////////Функции scanf() необходимо передавать адреса
    Для всех переменных, которые должны получить значения с помощью scanf(), должны быть переданы адреса. Это означает, 
    что все аргументы должны быть указателями. Вспомните, что именно так в С создается вызов по ссылке и именно тогда функция
    может изменить содержимое аргумента. Например, для считывания целого значения в переменную count можно использовать 
    такой вызов функции scanf():
    scanf("%d", &count);

    Строки будут читаться в символьные массивы, а имя массива без индекса является адресом первого его элемента. Таким
    образом, чтобы прочитать строку в символьный массив, можно использовать оператор
    scanf("%s", str);

    В этом случае str является указателем, и потому перед ним не нужно ставить оператор &.







    ///////////Модификаторы форматат
    Как и printf(), функция scanf() дает возможность модифицировать некоторое число своих спецификаторов формата. В 
    спецификаторах формата моно указать модификатор максимальной длины поля. Это целое число, расположенное между % и
    спецификатором формата; оно ограничивает число символов, считываемых из этого поля. Например, чтобы считывать в 
    переменную str не более 20 символов, пишите
    scanf("%20s", str);

    Если поток ввода содержит больше 20 символов, то при следующем вызове функций ввода считывание начнется после того места,
    где оно закончилось при предыдущем вызове. Например, если вы в ответ на вызов scanf() из этого примера введете
    ABCDEFGHIJKLMNOPRSTUVWXYZ

    то в str из-за спецификатора максимальной ширины поля будет помещено только 20 символов, то есть символы вплоть до Т. 
    Это значит, что оставшиеся символы UVWXYZ пока еще не прочитаны. При следующем вызове scanf(), например при выполнении
    оператора

    scanf("%s", str);

    в str будут помешены буквы UVWXYZ. Ввод из поля может завершиться и до того, как будет достигнута максимальная длина 
    поля — если встретится разделитель. В таком случае scanf() переходит к следующему полю.

    Чтобы прочитать длинное целое, перед спецификатором формата поместите l (эль). А для чтения короткого целого значения 
    перед спецификатором формата следует поместить n. Эти модификаторы можно использовать со следующими кодами форматов: 
    d, i, o, u, x и n.

    По умолчанию спецификаторы f, e и g дают scanf() указание присваивать данные переменной типа float. Если перед одним 
    из этих спецификаторов будет помещен l (эль), то scanf() будет присваивать данные переменной типа double. Использование 
    L дает scanf() указание, чтобы переменная, принимающая данные, имела тип long double.

    Если в компиляторе предусмотрена обработка двухбайтовых символов[1], добавленных в язык С Поправкой 1 от 1995 года, 
    то модификатор l можно также использовать с такими кодами формата, как c и s. l непосредственно перед c является 
    признаком указателя на объект типа wchar_t. А l непосредственно перед s — признак указателя на массив элементов типа
    wchar_t. Кроме того, l также применяется для модификации набора сканируемых символов, чтобы этот набор можно было 
    использовать для двухбайтовых символов.

    В Стандарте С99, кроме перечисленных, предусмотрены также модификаторы ll и hh, последний из которых можно применять
    к спецификаторам d, i, o, u, x или n. Он является признаком того, что соответствующий аргумент является указателем 
    на значение, типа signed или unsigned char. Кроме того, к спецификаторам d, i, o, u, x и n можно применять и ll, 
    этот спецификатор является признаком того, что соответствующий аргумент является указателем на значение типа signed 
    (или unsigned) long long int.

    На заметку: В С99 для функции scanf() имеются еще и другие модификаторы типа; о них рассказывается в части II.
    
    
    
    
    
    
    ///////////Подавление ввода
    scanf() может прочитать поле, но не присваивать прочитанное значение никакой переменной; для этого надо перед 
    литерой-спецификатором формата поля поставить звездочку, *. Например, когда выполняется оператор
    scanf("%d%*c%d", &x, &y);

    можно ввести пару координат 10,10. Запятая будет прочитана правильно, но ничему не будет присвоена. Подавление присвоения
    особенно полезно тогда, когда нужно обработать только часть того, что вводится.

    ----------
    [1]Называются также символами в расширенном 16-битном алфавите или символами уникода. (Unicode (уникод) — 16-битовый 
    стандарт кодирования символов, позволяюший представлять алфавиты всех существующих в мире языков.)
    */





    return 0;
}
