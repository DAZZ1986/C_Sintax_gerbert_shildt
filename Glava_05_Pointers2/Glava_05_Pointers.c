#include <locale.h>
#include <stdio.h>



int main(void)
{
    char* locale = setlocale(LC_ALL, "");



    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/05/05.htm
    printf("///////// Глава 05. Указатели\n");
    /*
    Правильное понимание и использование указателей особенно необходимо для составления хороших программ на языке С.
    И вот почему:
      - Во-первых, указатели являются средством, с помощью которого функция может изменять значения передаваемых в нее
        аргументов.
      - Во-вторых, с помощью указателей выполняется динамическое распределение памяти.
      - В-третьих, указатели позволяют повысить эффективность многих процедур.
      - И наконец, они обеспечивают поддержку динамических структур данных, например, двоичные деревья, связные списки.

    Таким образом, указатели являются весьма мощным средством языка С. Но и весьма опасным. Например, если указатель
    содержит неправильное значение, программа может потерпеть крах. Указатели весьма опасны еще и потому, что легко
    ошибиться при их использовании. К тому же ошибки, связанные с неправильными значениями указателей, найти очень трудно.

    Содержание:
    Что такое указатели
    Указательные переменные
    Операции для работы с указателями
    Указательные выражения
    Указатели и массивы
    Многоуровневая адресация
    Инициализация указателей
    Указатели на функции
    Функции динамического распределения
    Указатели с квалификатором restrict
    Трудности при работе с указателями
    */





    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/05/0501.htm
    printf("\n\n\n/////////// Что такое указатели\n");
    /*
    Указатель — это переменная, значением которой является адрес некоторого объекта(обычно другой переменной) в памяти
    компьютера. Например, если одна переменная содержит адрес другой переменной, то говорят, что первая переменная
    указывает(ссылается) на вторую. Это иллюстрируется с помощью рис. 5.1.

    Адрес     Значение
    ячейки  переменной в
    памяти     памяти
            +----------+
    1000    |   1003   |--.
            +----------+  |
    1001    |          |  |
            +----------+  |
    1002    |          |  |
            +----------+  |
    1003    |          |<-'
            +----------+
    1004    |          |
            +----------+
    1005    |          |
            +----------+
    1006    |          |
            +----------+
                 .
                 .
                 .
               Память

    Рис. 5.1.Одна переменная ссылается на другую
    */





    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/05/0502.htm
    printf("\n\n\n/////////// Указательные переменные\n");
    /*
    Как известно, переменную, являющуюся указателем, нужно соответствующим образом объявить. Объявление указателя
    состоит из имени базового типа, символа * и имени переменной. Общая форма объявления указателя следующая:
    тип* имя;

    // !!!!!!!!!!!!!!!!!!!!!!
    Здесь тип — это базовый тип указателя, им может быть любой правильный тип. Имя определяет имя переменной-указателя.
    Базовый тип указателя определяет тип объекта, на который указатель будет ссылаться!!!!!!!!!!!! Фактически указатель 
    любого типа может ссылаться на любое место в памяти!! Однако выполняемые с указателем операции существенно зависят 
    от его типа. Например, если объявлен указатель типа int*, компилятор предполагает, что любой адрес, на который он
    ссылается, содержит переменную типа int, хоть это может быть и не так!! Следовательно, объявляя указатель, необходимо
    убедиться, что его тип совместим с типом объекта, на который он будет ссылаться!!
    */




    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/05/0503.htm
    printf("\n\n\n/////////// Операции для работы с указателями\n");
    /*
    Операции для работы с указателями рассматривались в главе 2. Приведем их обзор. В языке С определены две операции
    для работы с указателями: * и &. Оператор & — это унарный оператор, возвращающий адрес своего операнда. (Напомним,
    что унарный оператор имеет один операнд). Например, оператор &

    int *m;
    m = &count;
    // !!!!!!!!!!!!!!!!!!!!!!
    присваивает переменной m адрес переменной count. Можно сказать, что адрес — это номер первого байта участка памяти,
    в котором хранится переменная. Адрес и значение переменной — это совершенно разные понятия. Оператор & можно
    представить себе как оператор, возвращающий адрес объекта. Следовательно, предыдущий пример можно прочесть так:
    "переменной m присваивается адрес переменной count".

    Предположим, переменная count хранится в ячейке памяти под номером 2000, а ее значение равно 100. Тогда переменной
    m будет присвоено значение 2000.     // !!!!!!!!!!!!!!!!!!!!!!

    Вторая операция для работы с указателями (ее знак, т.е. оператор, *) выполняет действие, обратное по отношению к &.
    Оператор * — это унарный оператор, возвращающий значение переменной, расположенной по указанному адресу. //!!!!!!!!!!!!!
    Например, если m содержит адрес переменной count, то оператор *

    q = *m;
    // !!!!!!!!!!!!!!!!!!!!!!
    присваивает переменной q значение переменной count. Таким образом, q получит значение 100, потому что по адресу 2000
    расположена переменная count, которая имеет значение 100. Действие оператора * можно выразить словами "значение по
    адресу", тогда предыдущий оператор может быть прочитан так: "q получает значение переменной, расположенной по адресу
    m".
    */
    //ТЕСТЫ
    int a, c;
    int* b;

    a = 2222;
    b = &a;
    c = *b;
    printf("%d %d\n", b, c);    //вывод: адрес, значение
    printf("%d %d\n", *b, c);   //вывод: значение, значение







    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/05/0504.htm
    printf("\n\n\n/////////// Указательные выражения\n");
    /*
    В общем случае выражения с указателями подчиняются тем же правилам, что и обычные выражения. В этом разделе 
    рассматривается применение указательных выражений в операциях присваивания, преобразования типов, а также в 
    операциях "указательной" арифметики.
    
    
    
    
    
    ///////////Присваивание указателей
    Указатель можно использовать в правой части оператора присваивания для присваивания его значения другому указателю. 
    Если оба указателя имеют один и тот же тип, то выполняется простое присваивание, без преобразования типа. // !!!!!!!!!!!!!!!!!!!!!!
    В следующем примере
    #include <stdio.h>

    int main(void)
    {
      int x = 99;
      int *p1, *p2;

      p1 = &x;
      p2 = p1;  //выполняется простое присваивание

        //печать значение x дважды
        printf("Значение по адресу p1 и p2: %d %d\n", *p1, *p2);

        //печать адреса x дважды
        printf("Значение указателей p1 и p2: %p %p", p1, p2);

        return 0;
    }

    после присваивания
    p1 = &x;
    p2 = p1;

    оба указателя(p1 и р2) ссылаются на х. То есть, оба указателя ссылаются на один и тот же объект. Программа выводит
    на экран следующее:
    Значения по адресу p1 и р2 : 99 99
    Значения указателей p1 и р2 : 0063FDF0 0063FDF0

    // !!!!!!!!!!!!!!!!!!!!!!
    Обратите внимание, для вывода значений указателей в функции printf() используется спецификатор формата %р, который 
    выводит адреса в формате, используемом компилятором. А значениями указателей, являются присвоенные им адреса в памяти!!
    Допускается присваивание указателя одного типа указателю другого типа. Однако для этого необходимо выполнить явное
    преобразование типа указателя(операция приведения типов), которая рассматривается в следующем разделе.
    
    
    
    

    
    ///////////Преобразование типа указателя  
    (мой коммент - если указатель интовый, то и ссылаться должен на инты, а не на даблы, потому что, переменная int занимает
    в памяти 4 байта, а double — 8 байтов!)

    // !!!!!!!!!!!!!!!!!!!!!!
    Указатель можно преобразовать к другому типу. Эти преобразования бывают двух видов: с использованием указателя типа
    void * и без его использования.

    // !!!!!!!!!!!!!!!!!!!!!!
    В языке С допускается присваивание указателя типа void * указателю любого другого типа(и наоборот) без явного 
    преобразования типа указателя. Тип указателя void * используется, если тип объекта неизвестен. Например, использование
    типа void * в качестве параметра функции позволяет передавать в функцию указатель на объект любого типа, при этом
    сообщение об ошибке не генерируется. Также он полезен для ссылки на произвольный участок памяти, независимо от 
    размещенных там объектов. Например, функция размещения mallocO (рассматривается далее в этой главе) возвращает 
    значение типа void *, что позволяет использовать ее для размещения в памяти объектов любого типа.

    В отличие от void*, преобразования всех остальных типов указателей должны быть всегда явными(т.е.должна быть указана
    операция приведения типов). Однако следует учитывать, что преобразование одного типа указателя к другому может 
    вызвать непредсказуемое поведение программы. Например, в следующей программе делается попытка присвоить значение 
    х переменной у посредством указателя р. При компиляции программы сообщение об ошибке не генерируется, однако 
    результат работы программы неверен.

    Короче, ниже попытка дотянуться до значения типа дабл, через интовый указатель!!!
    #include <stdio.h>
    int main(void)
    {
        double x = 100.1, y;
        int* p;

        //В следующем операторе указателю на целое p, присваивается значение, ссылающееся на double.
        p = (int*)&x;

        //Следующий оператор работает не так, как ожидается.
        y = *p; //attempt to assign y the value x through p

        //Следующий оператор не выведет число  100.1.
        printf("Значение x равно: %f (Это не так!)", y);

        return 0;
    }
    // !!!!!!!!!!!!!!!!!!!!!!
    Обратите внимание на то, что операция приведения типов применяется в операторе присваивания адреса 
    переменной х(он имеет тип double*) указателю p, тип которого int*. Преобразование типа выполнено корректно, однако
    программа работает не так, как ожидается(по крайней мере, в большинстве оболочек). Для разъяснения проблемы 
    предположим, что переменная int занимает в памяти 4 байта, а double — 8 байтов. Указатель p объявлен как указатель 
    на целую переменную(т.е.типа int), поэтому оператор присваивания
    y = *р;
    // !!!!!!!!!!!!!!!!!!!!!!
    передаст переменной y только 4 байта информации, а не 8 байтов, необходимых для double!!!!!!!!!!!!!!!!!!!!!!
    Несмотря на то, что p ссылается на объект double, оператор присваивания выполнит действие с объектом типа int, 
    потому что p объявлен как указатель на int. Поэтому такое использование указателя p неправильное.

    Приведенный пример подтверждает то, что операции с указателями выполняются в зависимости от базового типа указателей.
    Синтаксически допускается ссылка на объект с типом, отличным от типа указателя, однако при этом указатель будет 
    "думать", что он ссылается на объект своего типа. Таким образом, операции с указателями управляются типом указателя, 
    а не типом объекта, на который он ссылается!!!!!!!   // !!!!!!!!!!!!!!!!!!!!!!

    Разрешен еще один тип преобразований: преобразование целого в указатель и наоборот. В этом случае необходимо 
    применить операцию приведения типов(явное преобразование типа). Однако пользоваться этим средством нужно очень 
    осторожно, потому что при этом легко получить непредсказуемое поведение программы. Явное преобразование типа не 
    обязательно, если преобразуется нуль, то есть нулевой указатель.

    На заметку: В языке C++ требуется явно указывать преобразование типа указателей, в том числе указателей типа void* .
    Поэтому многие программисты используют в языке С явное преобразование для совместимости с C++!!!
    
    
    
    
    
    
    ///////////Адресная арифметика          // !!!!!!!!!!!!!!!!!!!!!!
    В языке С допустимы только две арифметические операции над указателями: суммирование и вычитание. Предположим, 
    текущее значение указателя p1 типа int* равно 2000. Предположим также, что переменная типа int занимает в памяти 
    2 байта. Тогда после операции увеличения
    p1++;   //смещение будет происходить на колитчество байт того типа на который он указывает, и если это тип инт, то 
            //смещение на 2-4 байта, если указатель на указатель то на 8 байт, если структура то на 10 байт.    // !!!!!!!!!!!!!!!!!!!!!!
    указатель p1 принимает значение 2002, а не 2001. То есть, при увеличении на 1, указатель p1 будет ссылаться на 
    следующее целое число. Это же справедливо и для операции уменьшения. Например, если p1 равно 2000, то после 
    выполнения оператора
    p1--;
    значение p1 будет равно 1998.  

    // !!!!!!!!!!!!!!!!!!!!!!
    Операции адресной арифметики подчиняются следующим правилам. После выполнения операции увеличения над указателем, 
    данный указатель будет ссылаться на следующий объект своего базового типа. После выполнения операции уменьшения — на 
    предыдущий объект. Применительно к указателям на char, операций адресной арифметики выполняются как обычные 
    арифметические операции, потому что длина объекта char всегда равна 1. Для всех указателей адрес увеличивается или 
    уменьшается на величину, равную размеру объекта того типа, на который они указывают. Поэтому указатель всегда 
    ссылается на объект с типом, тождественным базовому типу указателя. Эта концепция иллюстрируется с помощью рис. 5.2.

    Рис. 5.2.Пример размещения в памяти переменных char(слева) и int(справа)

    char* ch = (char*)3000;  //занимает 1 байт
    int* i = (int*)3000;     //занимает 2 байта

              +------+
    ch -----> | 3000 | --.
              +------+   | < -i
    ch + 1 -> | 3001 | --'
              +------+
    ch + 2 -> | 3002 | --.
              +------+   | < -i + 1
    ch + 3 -> | 3003 | --'
              +------+
    ch + 4 -> | 3004 | --.
              +------+   | < -i + 2
    ch + 5 -> | 3005 | --'
              +------+
               Память

    Операции адресной арифметики не ограничены увеличением(инкрементом) и уменьшением(декрементом). Например, к 
    указателям можно добавлять целые числа или вычитать из них целые числа. Выполнение оператора
    p1 = p1 + 12; //тут еденица измерения тоесть 12 = кол-ву байт типа на который ссылаемся как писли выше! Тоесть если
                  //4 байта тип, то 12 * 4 = 48 байт и на столько сместим указатель.
    "передвигает" указатель p1 на 12 объектов в сторону увеличения адресов. //ЖЕНЯ - а как мы уверены что далее в памяти
            //будут теже типы данных а не другие?? - Ответ - если ты смещаешся, то ты должен понимать куда смещаешься, 
            //если вылез за массив то ты дубалом!
    Кроме суммирования и вычитания указателя и целого, разрешена еще только одна операция адресной арифметики: можно 
    вычитать два указателя. Благодаря этому можно определить количество объектов, расположенных между адресами, на 
    которые указывают данные два указателя; правда, при этом считается, что тип объектов совпадает с базовым типом 
    указателей. Все остальные арифметические операции запрещены. А именно: нельзя делить и умножать указатели, 
    суммировать два указателя, выполнять над указателями побитовые операции, суммировать указатель со значениями, 
    имеющими тип float или double и т.д.
    
    

    
    
    
    ///////////Сравнение указателей (ЖЕНЯ)
    Стандартом С допускается сравнение двух указателей. Например, если объявлены два указателя р и q, то следующий 
    оператор является правильным:
    if (p < q) printf("p ссылается на меньший адрес, чем q\n");

    Как правило, сравнение указателей может оказаться полезным, только тогда, когда два указателя ссылаются на общий 
    объект, например, на массив. В качестве примера рассмотрим программу с двумя стековыми функциями, предназначенными 
    для записи и считывания целых чисел. Стек — это список, использующий систему доступа "первым вошел — последним вышел".
    Иногда стек сравнивают со стопкой тарелок на столе: первая, поставленная на стол, будет взята последней. Стеки 
    часто используются в компиляторах, интерпретаторах, программах обработки крупноформатных таблиц и в других системных
    программах. Для создания стека необходимы две функции: push() и pop(). Функция push() заносит числа в стек, 
    a pop() — извлекает их. В данном примере эти функции используются в main(). При вводе числа с клавиатуры, программа
    помещает его в стек. Если ввести 0, то число извлекается из стека. Программа завершает работу при вводе -1.

    #include <stdio.h>
    #include <stdlib.h>

    #define SIZE 50

    void push(int i);
    int pop(void);

    int *tos, *p1, stack[SIZE];

    int main(void)
    {
        int value;

        tos = stack; //tos ссылается на основание стека
        p1 = stack;  //инициализация p1

        do {
            printf("Введите значение: ");
            scanf_s("%d", &value);

            if (value != 0) push(value);
            else printf("значение на вершине равно %d\n", pop());

        } while (value != -1);

        return 0;
    }

    void push(int i)
    {
        p1++;
        if (p1 == (tos + SIZE)) {
            printf("Переполнение стека.\n");
            exit(1);
        }
        *p1 = i;
    }

    int pop(void)
    {
        if (p1 == tos) {
            printf("Стек пуст.\n");
            exit(1);
        }
        p1--;
        return *(p1 + 1);
    }
    Стек хранится в массиве stack. Сначала указатели p1 и tos устанавливаются на первый элемент массива stack. В 
    дальнейшем p1 ссылается на верхний элемент стека, a tos продолжает хранить адрес основания стека. После инициализации
    стека используются функции push() и pop() .Они выполняют запись в стек и считывание из него, проверяя каждый раз 
    соблюдение границы стека. В функции push() проверяется, что указатель p1 не превышает верхней границы 
    стека tos + SIZE. Это предотвращает переполнение стека. В функции pop() проверяется, что указатель p1 не выходит за
    нижнюю границу стека.

    В операторе return функции pop() скобки необходимы потому, что без них оператор
    return *p1 + 1;
    вернул бы значение, расположенное по адресу p1, увеличенное на 1, а не значение по адресу p1 + 1.
    */




    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/05/0505.htm
    printf("\n\n\n/////////// Указатели и массивы\n");
    /*
    Понятия указателей и массивов тесно связаны. Рассмотрим следующий фрагмент программы:
    char str[80], *p1;
    p1 = str;

    Здесь p1 указывает на первый элемент массива str. Обратиться к пятому элементу массива str можно с помощью любого
    из двух выражений:
    str[4]  //метод обращения - индексация массива          // !!!!!!!!!!!!!!!!!!!!!!
    *(p1+4) //метод обращения - адресная арифметика         // !!!!!!!!!!!!!!!!!!!!!!

    Массив начинается с нуля. Поэтому для пятого элемента массива str нужно использовать индекс 4. Можно также увеличить
    p1 на 4, тогда он будет указывать на пятый элемент. (Напомним, что имя массива без индекса возвращает адрес первого
    элемента массива.)

    В языке С существуют два метода обращения к элементу массива: адресная арифметика и индексация массива. Стандартная
    запись массивов с индексами наглядна и удобна в использовании, однако с помощью адресной арифметики иногда удается 
    сократить время доступа к элементам массива. Поэтому адресная арифметика часто используется в программах, где 
    существенную роль играет быстродействие.

    В следующем фрагменте программы приведены две версии функции putstr(), выводящей строку на экран. В первой версии
    используется индексация массива, а во второй — адресная арифметика:

    //Индексация указателя s как массива
    void putstr(char* s)    //тут в функцию мы передаем не массив, а строку - тоесть массив чаров.
    {
        register int t;

        for (t = 0; s[t]; ++t) putchar(s[t]);
    }

    //Использование адресной арифметики
    void putstr(char* s)
    {
        while (*s) putchar(*s++);
    }
    Большинство профессиональных программистов сочтут вторую версию более наглядной и удобной. Для большинства 
    компиляторов она также более быстродействующая. Поэтому в процедурах такого типа приемы адресной арифметики
    используются довольно часто.






    ///////////Массивы указателей
    Как и объекты любых других типов, указатели могут быть собраны в массив. В следующем операторе объявлен массив из 
    10 указателей на объекты типа int:
    int* x[10];             // !!!!!!!!!!!!!!!!!!!!!!

    Для присвоения адреса переменной var третьему элементу массива указателей, необходимо написать:
    x[2] = &var;

    В результате этой операции, следующее выражение принимает то же значение, что и var:
    *x[2]   //тоесть тут он разименовал данный указатель в массиве под индексом 2, в котором лежит адрес на переменную
            //var. Тоесть тут мы получаем значение переменной var, тк разименовали третий элемент массива.

    Для передачи массива указателей в функцию используется тот же метод, что и для любого другого массива: имя массива
    без индекса записывается как формальный параметр функции. Например, следующая функция может принять массив x в 
    качестве аргумента:

    void display_array(int* q[])    //ТУТ НУЖНА ПРАКТИКА !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    {   
        int t;

        for (t = 0; t < 10; t++)
            printf("%d ", *q[t]);
    }
    Необходимо помнить, что q — это не указатель на целые, а указатель на массив указателей на целые. Поэтому параметр q
    нужно объявить как массив указателей на целые. Нельзя объявить q просто как указатель на целые, потому что он 
    представляет собой указатель на указатель.

    Массивы указателей часто используются при работе со строками. Например, можно написать функцию, выводящую нужную 
    строку с сообщением об ошибке по индексу num:

    void syntax_error(int num)
    {
        static char* err[] = {
          "Нельзя открыть файл\n",
          "Ошибка при чтении\n",
          "Ошибка при записи\n",
          "Некачественный носитель\n"
        };

        printf("%s", err[num]);
    }
    Массив err содержит указатели на строки с сообщениями об ошибках. Здесь строковые константы в выражении инициализации 
    создают указатели на строки. Аргументом функции printf() служит один из указателей массива err, который в 
    соответствии с индексом num указывает на нужную строку с сообщением об ошибке. Например, если в функцию 
    syntax_error() передается num со значением 2, то выводится сообщение Ошибка при записи.

    Отметим, что аргумент командной строки argv(см.главу 6) также является массивом указателей на строковые константы.
    */





    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/05/0506.htm
    printf("\n\n\n/////////// Многоуровневая адресация\n");
    /*
    Иногда указатель может ссылаться на указатель, который ссылается на число. Это называется многоуровневой адресацией. 
    Иногда применение таких указателей существенно усложняет программу, делает ее плохо читаемой и подверженной ошибкам. 
    Рис. 5.3 иллюстрирует концепцию многоуровневой адресации. На рисунке видно, что значением "нормального" указателя 
    является адрес объекта, содержащего нужное значение. В случае двухуровневой адресации первый указатель содержит 
    адрес второго указателя, который содержит адрес объекта с нужным значением.

    Многоуровневая адресация может иметь сколько угодно уровней, однако уровни глубже второго, т.е. указатели более 
    глубокие, чем "указатели на указатели" применяются крайне редко. Дело в том, что при использовании таких указателей
    часто встречаются концептуальные ошибки из-за того, что смысл таких указателей представить трудно.

    На заметку: Не следует путать многоуровневую адресацию с многоуровневыми структурами данных, использующими 
    указатели, такими, например, как связные списки. Это фундаментально различные концепции.

    Переменная, являющаяся указателем на указатель, должна быть соответствующим образом объявлена. Это делается с 
    помощью двух звездочек перед именем переменной. Например, в следующем операторе newbalance объявлена как указатель
    на указатель на переменную типа float:
    float **newbalance;

    Следует хорошо понимать, что newbalance — это не указатель на число типа float, а указатель на указатель на число
    типа float.

    Рис. 5.3. Одноуровневая и многоуровневая адресация

           Указатель         Переменная
           +--------+        +--------+
           | Адрес  |------->|Значение|
           +--------+        +--------+
              Одноуровневая адресация

    Указатель       Указатель       Переменная
    +--------+      +--------+      +--------+
    | Адрес  |----->| Адрес  |----->|Значение|
    +--------+      +--------+      +--------+
              Многоуровневая адресация

    При двухуровневой адресации для доступа к значению объекта нужно поставить перед идентификатором две звездочки:
    #include <stdio.h>

    int main(void)
    {
      int x, *p, **q;

      x = 10;
      p = &x;
      q = &p;

      printf("%d", **q); //печать значения x    // !!!!!!!!!!!!!!!!!!!!!!!!!!

        return 0;
    }
    Здесь p объявлена как указатель на целое, a q — как указатель на указатель на целое. Функция printf() выводит на 
    экран число 10.
    */
    /*МОИ ТЕСТЫ
    int x, *h, **g;

    x = 10;
    h = &x;
    g = &h;

    printf("%d", **g); //печать значения x
    */





    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/05/0507.htm
    printf("\n\n\n/////////// Инициализация указателей\n");
    /*
    // !!!!!!!!!!!!!!!!!!!!!!!!!!
    После объявления нестатического локального указателя до первого присвоения он содержит неопределенное значение. 
    (Глобальные и статические локальные указатели при объявлении неявно инициализируются нулем.) Если попытаться 
    использовать указатель перед присвоением ему нужного значения, то скорее всего он мгновенно разрушит программу 
    или всю операционную систему. Это очень досадная ошибка.

    // !!!!!!!!!!!!!!!!!!!!!!!!!!
    При работе с указателями большинство программистов придерживаются следующего важного соглашения: указатель, не 
    ссылающийся в текущий момент времени должным образом на конкретный объект, должен содержать нулевое значение!!!!
    Нуль используется потому, что С гарантирует отсутствие чего-либо по нулевому адресу. Следовательно, если указатель
    равен нулю, то это значит, во-первых, что он ни на что не ссылается, а во-вторых — что его сейчас нельзя использовать!!!

    Указателю можно задать нулевое значение, присвоив ему 0. Например, следующий оператор инициализирует р нулем:
    char *p = 0;

    Дополнительно к этому во многих заголовочных файлах языка С, например, в <stdio.h> определен макрос NULL, являющийся
    нулевой указательной константой. Поэтому в программах на С часто можно увидеть следующее присваивание:
    p = NULL;

    Однако равенство указателя нулю не делает его абсолютно "безопасным". Использование нуля в качестве признака 
    неподготовленности указателя — это только соглашение программистов, но не правило языка С. В следующем примере 
    компиляция пройдет без ошибки, а результат, тем не менее, будет неправильным:
    int *p = 0;
    *p = 10; //ошибка! Тут операция разименовывания - тоесть я пытаюсь изменить переменную на которую указывает указатель, 
             //а указатель указывает на несуществующий адрес 0.
    
    *p = 10; //в данном случае я пытаюсь присвоить значение 10 в переменную на которую указывает указатель, а
    указывает он на адрес 0, тут будет ошибка потому что во первых 0 адреса не существует и во вторых мы ранее не
    присвоили указателю адрес какой-либо переменной до его исползования.    // !!!!!!!!!!!!!!!!!!!!!!!!!!
    p = 10; //а, в данном случае я перезаписал значение указателя с 0 на 10, тоесть он смотрит на адрес в памяти 10.

    Во многих процедурах для повышения эффективности программы можно использовать то, что нулевой указатель заведомо
    считается неподготовленным для использования. Например, можно использовать нулевой указатель как признак конца 
    массива указателей(по аналогии с нулевым терминатором строки). Процедура, использующая массив указателей, таким 
    образом узнает о конце массива. Такой подход иллюстрируется в таком примере. Просматривая список имен, функция 
    search() определяет, есть ли в этом списке заданное имя.

    #include <stdio.h>
    #include <string.h>

    int search(char* p[], char* name);

    char* names[] = {
      "Сергей",
      "Юрий",
      "Ольга",
      "Игорь",
      NULL };   //Нулевая константа кончает список

    int main(void)
    {
        if (search(names, "Ольга") != -1)
            printf("Ольга есть в списке.\n");

        if (search(names, "Павел") == -1)
            printf("Павел в списке не найден.\n");

        return 0;
    }

    int search(char* p[], char* name) //Просмотр имен
    {
        register int t;

        for (t = 0; p[t]; ++t)
            if (!strcmp(p[t], name)) return t;

        return -1; //имя не найдено
    }
    В функцию search() передаются два параметра. Первый из них, p — массив указателей на строки, представляющие собой 
    имена из списка. Второй параметр name является указателем на строку с заданным именем. Функция search() просматривает
    массив указателей, пока не найдет строку, совпадающую со строкой, на которую указывает name. Итерации цикла for 
    повторяются до тех пор, пока не произойдет совпадение имен, или не встретится нулевой указатель. Конец массива 
    отмечен нулевым указателем, поэтому при достижении конца массива управляющее условие цикла примет значение ЛОЖЬ.
    Иными словами, p[t] имеет значение ЛОЖЬ, когда p[t] является нулевым указателем. В рассмотренном примере именно это
    и происходит, когда идет поиск имени "Павел", которого в списке нет.

    // !!!!!!!!!!!!!!!!!!!!!!!!!
    В программах на С указатель типа char* часто инициализируют строковой константой(как в предыдущем примере). 
    Рассмотрим следующий пример:
    char* p = "тестовая строка";

    Переменная р является указателем, а не массивом. Поэтому возникает логичный вопрос: где хранится строковая 
    константа "тестовая строка"? Так как p не является массивом, она не может храниться в p, тем не менее, она 
    где-то записана. Чтобы ответить на этот вопрос, нужно знать, что происходит, когда компилятор встречает строковую 
    константу. Компилятор создает так называемую таблицу строк, в ней он сохраняет строковые константы, которые 
    встречаются ему по ходу чтения текста программы. Следовательно, когда встречается объявление с инициализацией, 
    компилятор сохраняет строку "тестовая строка" в таблице строк, а в указатель p записывает ее адрес. Дальше в 
    программе указатель p может быть использован как любая другая строка. Это иллюстрируется следующим примером:
    #include <stdio.h>
    #include <string.h>

    char* p = "тестовая строка";

    int main(void)
    {
        register int t;

        //печать строки слева направо и справа налево
        printf(p);
        for (t = strlen(p) - 1; t > -1; t--) printf("%c", p[t]);

        return 0;
    }
    */
    /*МОИ ТЕСТЫ
    int* p = 0;
    p = 10; //
    *p = 10; //ошибка!

    printf("%d\n", *p);
    printf("%p\n", p);
    */

    
    




    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/05/0508.htm
    printf("\n\n\n/////////// Указатели на функции\n");
    /*
    Указатели на функции[1] — очень мощное средство языка С. Хотя нельзя не отметить, что это весьма трудный для 
    понимания термин. Функция располагается в памяти по определенному адресу, который можно присвоить указателю в
    качестве его значения. Адресом функции является ее точка входа. Именно этот адрес используется при вызове функции.
    Так как указатель хранит адрес функции, то она может быть вызвана с помощью этого указателя. Он позволяет также
    передавать ее другим функциям в качестве аргумента.

    // !!!!!!!!!!!!!!!!!!!!!!!!!
    В программе на С адресом функции служит ее имя без скобок и аргументов (это похоже на адрес массива, который 
    равен имени массива без индексов). Рассмотрим следующую программу, в которой сравниваются две строки, введенные 
    пользователем. Обратите внимание на объявление функции check() и указатель p внутри main(). Указатель p, как вы
    увидите, является указателем на функцию.
    #include <stdio.h>
    #include <string.h>

    void check(char* a, char* b,
               int (*cmp)(const char *, const char *));

    int main(void)
    {
        char s1[80], s2[80];                  //это 2 строки
        int (*p)(const char*, const char*);   //это указатель на функцию

        p = strcmp; //присваиваем адрес функции strcmp указателю p

        printf("Введите две строки.\n");
        gets(s1);
        gets(s2);

        check(s1, s2, p); //передает адрес функции strcmp посредством указателя p в функцию check

        return 0;
    }

    void check(char* a, char* b,
        int (*cmp)(const char*, const char*))
    {
        printf("Проверка на совпадение.\n");
        if (!(*cmp)(a, b)) printf("Равны");
        else printf("Не равны");
    }

    Проанализируем эту программу подробно. В первую очередь рассмотрим объявление указателя p в main():
    int (*p)(const char*, const char*);

    // !!!!!!!!!!!!!!!!!!!!!!!!!
    Это объявление сообщает компилятору, что p — это указатель на функцию, имеющую два параметра типа const char* и 
    возвращающее значение типа int. Скобки вокруг p необходимы для правильной интерпретации объявления компилятором.
    Подобная форма объявления используется также для указателей на любые другие функции, нужно лишь внести изменения 
    в зависимости от возвращаемого типа и параметров функции!!!!!

    Теперь рассмотрим функцию check(). В ней объявлены три параметра: два указателя на символьный тип(a и b) и 
    указатель на функцию cmp. Обратите внимание на то, что указатель функции cmp объявлен в том же формате, что и p.
    Поэтому в cmp можно хранить значение указателя на функцию, имеющую два параметра типа const char* и возвращающую
    значение int. Как и в объявлении p, круглые скобки вокруг *cmp необходимы для правильной интерпретации этого 
    объявления компилятором.

    Вначале в программы указателю p присваивается адрес стандартной библиотечной функции strcmp(), которая сравнивает
    строки. Потом программа просит пользователя ввести две строки и передает указатели на них функции check(), которая
    их сравнивает. Внутри check() выражение
    (*cmp)(a, b)
    вызывает функцию strcmp(), на которую указывает cmp, с аргументами a и b. Скобки вокруг *cmp обязательны.
    Существует и другой, более простой, способ вызова функции с помощью указателя:
    cmp(a, b);

    Однако первый способ используется чаще(и мы рекомендуем использовать именно его), потому что при втором способе 
    вызова указатель cmp очень похож на имя функции, что может сбить с толку читающего программу. В то же время у 
    первого способа записи есть свои преимущества, например, хорошо видно, что функция вызывается с помощью указателя
    на функцию, а не имени функции. Следует отметить, что первоначально в С был определен именно первый способ вызова.

    Вызов функции check() можно записать, используя непосредственно имя strcmp():
        check(s1, s2, strcmp);
    В этом случае вводить в программу дополнительный указатель p нет необходимости.
    У читателя может возникнуть вопрос: какая польза от вызова функции с помощью указателя на функцию? Ведь в 
    данном случае никаких преимуществ не достигнуто, этим мы только усложнили программу. Тем не менее, во многих 
    случаях оказывается более выгодным передать имя функции как параметр или даже создать массив функций. Например,
    в программе интерпретатора синтаксический анализатор(программа, анализирующая выражения) часто вызывает различные
    вспомогательные функции, такие как вычисление математических функций, процедуры ввода - вывода и т.п. В таких 
    случаях чаще всего создают список функций и вызывают их с помощью индексов.

    Альтернативный подход — использование оператора switch с длинным списком меток case — делает программу более 
    громоздкой и подверженной ошибкам.

    В следующем примере рассматривается расширенная версия предыдущей программы. В этой версии функция check() 
    устроена так, что может выполнять разные операции над строками s1 и s2(например, сравнивать каждый символ с 
    соответствующим символом другой строки или сравнивать числа, записанные в строках) в зависимости от того, какая
    функция указана в списке аргументов. Например, строки "0123" и "123" отличаются, однако представляют одно и то 
    же числовое значение.
    #include <stdio.h>
    #include <ctype.h>
    #include <stdlib.h>
    #include <string.h>

    void check(char* a, char* b,
                int (*cmp)(const char*, const char*));
    int compvalues(const char* a, const char* b);

    int main(void)
    {
        char s1[80], s2[80];

        printf("Введите два значения или две строки.\n");
        gets(s1);
        gets(s2);
        //ЖЕНЯ
        if (isdigit(*s1)) {
            printf("Проверка значений на равенство.\n");
            check(s1, s2, compvalues);
        }
        else {
            printf("Проверка строк на равенство.\n");
            check(s1, s2, strcmp);
        }
        return 0;
    }

    void check(char* a, char* b,  int (*cmp)(const char*, const char*))
    {
        if (!(*cmp)(a, b)) printf("Равны");
        else printf("Не равны");
    }

    int compvalues(const char* a, const char* b)
    {
        if (atoi(a) == atoi(b)) return 0;
        else return 1;
    }

    Если в этом примере ввести первый символ первой строки как цифру, то check() использует compvalues(), в противном
    случае — strcmp(). Функция check() вызывает ту функцию, имя которой указано в списке аргументов при вызове check(),
    поэтому она в разных ситуациях может вызывать разные функции. Ниже приведены результаты работы этой программы в 
    двух случаях:

    Введите два значения или две строки.
    тест
    тест
    Проверка строк на равенство.
    Равны

    Введите два значения или две строки.
    0123
    123
    Проверка значений на равенство.
    Равны

    Сравнение строк 0123[2] и 123 показывает равенство их значений.
    ----------

    [1]Иногда их называют просто указателями функций. Но следует помнить, что в языках программирования под этим 
    термином подразумевается также средство обращения к подпрограмме - функции или встроенной функции, имеющее 
    конструкцию <имя - функции>(<список - аргументов>).
    [2]Обратите внимание, что в языке С нулем начинаются восьмеричные константы.Если бы эта запись была в выражении, 
    то 0123 не было бы равно 123. Однако здесь функция atoi() обрабатывает это число как десятичное.
    
    */






    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/05/0509.htm
    printf("\n\n\n/////////// Функции динамического распределения  //ЖЕНЯ\n");
    /*
    // !!!!!!!!!!!!!!!!!!!!!!!!!
    Указатели используются для динамического выделения памяти компьютера для хранения данных. Динамическое 
    распределение означает, что программа выделяет память для данных во время своего выполнения. Память для 
    глобальных переменных выделяется во время компиляции, а для нестатических локальных переменных — в стеке. 
    Во время выполнения программы ни глобальным, ни локальным переменным не может быть выделена дополнительная 
    память. Но довольно часто такая необходимость возникает, причем объем требуемой памяти заранее неизвестен.
    Такое случается, например, при использовании динамических структур данных, таких как связные списки или двоичные
    деревья. Такие структуры данных при выполнении программы расширяются или сокращаются по мере необходимости. 
    Для реализации таких структур в программе нужны средства, способные по мере необходимости выделять и освобождать
    для них память.

    // !!!!!!!!!!!!!!!!!!!!!!!!!
    Память, выделяемая в С функциями динамического распределения данных, находится в т.н. динамически распределяемой
    области памяти (heap)[1]. Динамически распределяемая область памяти — это свободная область памяти, не 
    используемая программой, операционной системой или другими программами. Размер динамически распределяемой 
    области памяти заранее неизвестен, но как правило в ней достаточно памяти для размещения данных программы. 
    Большинство компиляторов поддерживают библиотечные функции, позволяющие получить текущий размер динамически 
    распределяемой области памяти, однако эти функции не определены в Стандарте С. Хотя размер динамически 
    распределяемой области памяти очень большой, все же она конечна и может быть исчерпана.

    Основу системы динамического распределения в С составляют функции malloc() и free(). Эти функции работают 
    совместно. Функция malloc() выделяет память, а free() — освобождает ее. Это значит, что при каждом запросе 
    функция malloc() выделяет требуемый участок свободной памяти, a free() освобождает его, то есть возвращает 
    системе. В программу, использующую эти функции, должен быть включен заголовочный файл <stdlib.h>.

    Прототип функции malloc() следующий:
    void *malloc(size_t количество_байтов);  //маалок возвращает указатель любого типа данных на выделяемую их 
                                             //область в памяти, на первый байт естественно.

    Здесь количество_байтов — размер памяти, необходимой для размещения данных. (Тип size_t определен в <stdlib.h> 
    как некоторый целый без знака.) Функция malloc() возвращает указатель типа void *, поэтому его можно присвоить 
    указателю любого типа!! При успешном выполнении malloc() возвращает указатель на первый байт непрерывного участка
    памяти, выделенного в динамически распределяемой области памяти. Если в динамически распределяемой области 
    памяти недостаточно свободной памяти для выполнения запроса, то память не выделяется и malloc() возвращает нуль.

    При выполнении следующего фрагмента программы выделяется непрерывный участок памяти объемом 1000 байтов:
    char *p;
    p = malloc(1000); //выделение 1000 байтов           // !!!!!!!!!!!!!!!!!!!!!!!!!

    После присвоения указатель p ссылается на первый из 1000 байтов выделенного участка памяти типа char.

    В следующем примере выделяется память для 50 целых. Для повышения мобильности(переносимости программы с одной 
    машины на другую) используется оператор sizeof.
    int* p;
    p = malloc(50 * sizeof(int));

    Поскольку динамически распределяемая область памяти не бесконечна, при каждом размещении данных необходимо 
    проверять, состоялось ли оно. Если malloc() не смогла по какой-либо причине выделить требуемый участок памяти,
    то она возвращает нуль. В следующем примере показано, как выполняется проверка успешности размещения:
    p = malloc(100);
    if (!p) {
        printf("Нехватка памяти.\n");
        exit(1);
    }
    Конечно, вместо выхода из программы exit() можно поставить какой-либо обработчик ошибки. Обязательным здесь 
    можно назвать лишь требование не использовать указатель р, если он равен нулю.

    Функция free() противоположна функции malloc() в том смысле, что она возвращает системе участок памяти, выделенный
    ранее с помощью функции malloc(). Иными словами, она освобождает участок памяти, который может быть вновь
    использован функцией malloc(). Функция free() имеет следующий прототип:
    void free(void* p)

    Здесь р — указатель на участок памяти, выделенный перед этим функцией malloc(). Функцию free() ни в коем случае 
    нельзя вызывать с неправильным аргументом, это мгновенно разрушит всю систему распределения памяти.

    Подсистема динамического распределения в С используется совместно с указателями для создания различных программных
    конструкций, таких как связные списки и двоичные деревья. Несколько примеров использования таких конструкций 
    приведены в части IV. Здесь рассматривается другое важное применение динамического размещения: размещение массивов.
    
    
    

    
    
    ///////////Динамическое выделение памяти для массивов //ЖЕНЯ
    Довольно часто возникает необходимость выделить память динамически, используя malloc(), но работать с этой 
    памятью удобнее так, будто это массив, который можно индексировать. В этом случае нужно создать динамический 
    массив. Сделать это несложно, потому что каждый указатель можно индексировать как массив. В следующем примере 
    одномерный динамический массив содержит строку:

    //Динамическое распределение строки, строка вводится пользователем, а затем распечатывается справа налево.
    #include <stdlib.h>
    #include <stdio.h>
    #include <string.h>

    int main(void)
    {
        char* s;
        register int t;

        s = malloc(80);

        if (!s) {
            printf("Требуемая память не выделена.\n");
            exit(1);
        }

        gets(s);
        for (t = strlen(s) - 1; t >= 0; t--) putchar(s[t]);
        free(s);

        return 0;
    }
    Перед первым использованием s программа проверяет, успешно ли прошло выделение памяти. Эта проверка необходима для
    предотвращения случайного использования нулевого указателя. Обратите внимание на то, что указатель s 
    используется в функции gets(), а также при выводе на экран(но на этот раз уже как обыкновенный массив).

    Можно также динамически выделить память для многомерного массива. Для этого нужно объявить указатель, определяющий
    все, кроме самого левого измерения массива. В следующем примере[2] двухмерный динамический массив содержит 
    таблицу чисел от 1 до 10 в степенях 1, 2, 3 и 4.

    #include <stdio.h>
    #include <stdlib.h>

    int pwr(int a, int b);

    int main(void)
    {
        //Объявление указателя на массив из 10 строк в которых хранятся целые числа (int).
        int(*p)[10];
        register int i, j;

        //выделение памяти для массива 4 x 10
        p = malloc(40 * sizeof(int));

        if (!p) {
            printf("Требуемая память не выделена.\n");
            exit(1);
        }

        for (j = 1; j < 11; j++)
            for (i = 1; i < 5; i++) p[i - 1][j - 1] = pwr(j, i);

        for (j = 1; j < 11; j++) {
            for (i = 1; i < 5; i++) printf("%10d ", p[i - 1][j - 1]);
            printf("\n");
        }

        return 0;
    }

    //Возведение чисел в степень
    pwr(int a, int b)
    {
        register int  t = 1;

        for (; b; b--) t = t * a;
        return t;
    }

    Программа выводит на экран следующее:
         1         1         1         1
         2         4         8        16
         3         9        27        81
         4        16        64       256
         5        25       125       625
         6        36       216      1296
         7        49       343      2401
         8        64       512      4096
         9        81       729      6561
        10       100      1000     10000

    Указатель р в главной программе(main()) объявлен как
    int(*p)[10]

    Следует отметить, что скобки вокруг *р обязательны. Такое объявление означает, что р указывает на массив из 10 
    целых. Если увеличить указатель р на 1, то он будет указывать на следующие 10 целых чисел. Таким образом, 
    р — это указатель на двухмерный массив с 10 числами в каждой строке. Поэтому р можно индексировать как обычный
    двухмерный массив. Разница только в том, что здесь память выделена с помощью malloc(), а для обыкновенного 
    массива память выделяет компилятор.

    Как упоминалось ранее, в C++ нужно преобразовывать типы указателей явно. Поэтому чтобы данная программа была 
    правильной и в С, и в C++, необходимо выполнить явное приведение типа значения, возвращаемого функцией 
    malloc(). Для этого строчку, в которой указателю р присваивается это значение, нужно переписать следующим образом:
    p = (int(*)[10]) malloc(40 * sizeof(int));

    Многие программисты используют явное преобразование типов указателей для обеспечения совместимости с C++.
    ----------

    [1]Применяются и другие названия : динамическая область, динамически распределяемая область, куча, 
    неупорядоченный массив(данных).
    [2]В примере динамически размещается только левое измерение массива.Однако это нетрудно сделать и для всех 
    измерений, объявив указатель** р и разместив каждое измерение отдельно.Такой прием особенно удобен при 
    написании функции, один из аргументов которой — двухмерный массив с неизвестными заранее размерами измерений.
    */







    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/05/0510.htm
    printf("\n\n\n/////////// Указатели с квалификатором restrict\n");
    /*
    Стандарт С99 дополнительно вводит новый квалификатор типа restrict, применимый только для указателей. Подробно 
    этот спецификатор обсуждается в части II, здесь приведено только его краткое описание.

    // !!!!!!!!!!!!!!!!!!!!!!!!!
    Если указатель объявлен с квалификатором restrict, то к объекту, на который он ссылается, можно обратиться только
    с помощью этого указателя. Обращение к объекту с помощью другого указателя возможно только в том случае, если 
    другой указатель основан на первом. Таким образом, доступ к объекту можно получить только с помощью выражений,
    основанных на указателе с квалификатором restrict. Указатели restrict используются главным образом как параметры
    функции или совместно с malloc(). Если указатель объявлен с квалификатором restrict, компилятор способен лучше 
    оптимизировать некоторые процедуры. Например, если два параметра функции определены как указатели с квалификатором
    restrict, то это сообщает компилятору о том, что они указывают на два разных (не пересекающихся) объекта. 
    Квалификатор restrict не изменяет семантику программы.
    */






    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/05/0511.htm
    printf("\n\n\n/////////// Трудности при работе с указателями\n");
    /*
    Ничто не может доставить больше неприятностей, чем "дикий" указатель! Указатели похожи на обоюдоострое оружие: 
    их возможности огромны, однако обезвредить ошибки в них особенно трудно.

    Ошибочный указатель трудно найти потому, что ошибка в самом указателе никак себя не проявляет. Проблемы возникают
    при попытке обратиться к объекту с помощью этого указателя. Если значение указателя неправильное, то программа
    с его помощью обращается к произвольной ячейке памяти. При чтении в программу попадают неправильные данные, а 
    при записи искажаются другие данные, хранящиеся в памяти, или портится участок программы, не имеющий никакого 
    отношения к ошибочному указателю. В обоих случаях ошибка может не проявиться вовсе или проявиться позже в форме,
    никак не указывающей на ее причину.

    Поскольку ошибки, связанные с указателями, особенно трудно обезвредить, при работе с указателями следует соблюдать
    особую осторожность. Рассмотрим некоторые ошибки, наиболее часто возникающие при работе с указателями. 
    Классический пример — неинициализированный указатель:

    //Это программа содержит ошибку.
    int main(void)
    {
        int x, *p;

        x = 10;
        p = &x; //это я дописал, эта срока инициализации отсутствовала
        *p = x; //ошибка, p не инициализирован (тут присваение значения 10 некоторой неизвестной области памяти).
                //тоесть тут пытались записать значение, туда, куда указывает указатель p, а он никуда не указывает, тк
                //ему ранее адрес никто не присваивал.

        return 0;
    }
    // !!!!!!!!!!!!!!!!!!!!!!!!!
    Эта программа присваивает значение 10 некоторой неизвестной области памяти. Рассмотрим, почему это происходит. 
    Хотя указателю р не было присвоено никакого значения, но в момент выполнения операции *р = х он имел 
    некоторое(совершенно произвольное!) значение. Поэтому здесь имела место попытка выполнить операцию записи в 
    область памяти, на которую указывал данный указатель. В небольших программах такая ошибка часто остается 
    незамеченной, потому что если программа и данные занимают немного места, то "выстрел наугад" скорее всего будет
    "промахом". С увеличением размера программы вероятность "попасть" в нее возрастает.

    В таком простом случае большинство компиляторов выводят предупреждение о том, что используется 
    неинициализированный указатель. Однако подобная ошибка может произойти и в более завуалированном виде, тогда 
    компилятор не сможет распознать ее.

    Вторая распространенная ошибка заключается в простом недоразумении при использовании указателя:
    //Это программа содержит ошибку.
    #include <stdio.h>

    int main(void)
    {
        int x, *p;

        x = 10;
        p = x;

        printf("%d", *p);

        return 0;
    }
    Вызов printf() не выводит на экран значение х, равное 10. Выводится произвольная величина, потому что оператор
    p = x;
    записан неправильно. Он присваивает значение 10 указателю, однако указатель должен содержать адрес, а не значение.
    Правильный оператор выглядит так:
    p = &x;
    Большинство компиляторов при попытке присвоить указателю р значение х выведут предупреждающее сообщение, но, как 
    и в предыдущем примере, компилятор не сможет распознать эту ошибку в более завуалированном виде.

    Еще одна типичная ошибка происходит иногда при неправильном понимании принципов расположения переменных в памяти.
    Программисту ничего не известно о том, как используемые им данные располагаются в памяти, будут ли они 
    расположены так же при следующем выполнении программы или как их расположат другие компиляторы. Поэтому 
    сравнивать одни указатели с другими недопустимо. Например, программа
    char s[80], y[80];
    char *p1, *p2;

    p1 = s;
    p2 = y;
    if (p1 < p2) . . .
    в общем случае неправильна. (В некоторых необычных ситуациях иногда определяют относительное положение переменных,
    но это делают очень редко.)

    Похожая ошибка возникает, когда делается необоснованное предположение о расположении массивов. Иногда, предполагая,
    что массивы расположены рядом, пытаются обращаться к ним с помощью одного и того же указателя, например:
    int first[10], second[10];
    int *p, t;

    p = first;
    for (t = 0; t < 20; ++t)  *p++ = t;

    Так присваивать значения массивам first и second нельзя. Если компилятор разместит массивы рядом, это может и не
    привести к неправильному результату. Однако подобная ошибка особенно неприятна тем, что при проверке она может 
    остаться незамеченной, а потом компилятор будет размещать массивы по-другому и программа выполнится неправильно.

    В следующей программе приведен пример очень опасной ошибки. Постарайтесь сами найти ее, не подсматривая в 
    последующее объяснение.
    //Это программа с ошибкой
    #include <string.h>
    #include <stdio.h>

    int main(void)
    {
        char *p1;
        char s[80];

        p1 = s;
        do {
            gets(s);  //чтение строки

            //печать десятичного эквивалента каждого символа
            while (*p1) printf(" %d", *p1++);

        } while (strcmp(s, "выполнено"));

        return 0;
    }
    Программа печатает значения символов ASCII, находящихся в строке s. Печать осуществляется с помощью p1, 
    указывающего на s. Ошибка состоит в том, что указателю p1 присвоено значение s только один раз, перед циклом.
    В первой итерации p1 правильно проходит по символам строки s, однако в следующей итерации он начинает не с 
    первого символа, а с того, которым закончил в предыдущей итерации. Так что во второй итерации p1 может указывать
    на середину второй строки, если она длиннее первой, или же вообще на конец остатка первой строки. Исправленная 
    версия программы записывается так:
    //Это правильная программа
    #include <string.h>
    #include <stdio.h> 

    int main(void)
    {
        char* p1;
        char s[80];
        //ЖЕНЯ
        do {
            p1 = s;   //установка p1 в начало строки s
            gets(s);  //чтение строки

            //печать десятичного эквивалента каждого символа
            while (*p1) printf(" %d", *p1++);

        } while (strcmp(s, "выполнено"));

        return 0;
    }
    При такой записи указатель p1 в начале каждой итерации устанавливается на первый символ строки s. Об этом 
    необходимо всегда помнить при повторном использовании указателей.
    То, что неправильные указатели могут быть очень "коварными", не может служить причиной отказа от их использования.
    Следует лишь быть осторожным и внимательно проанализировать каждое применение указателя в программе.
    */
    //МОИ ТЕСТЫ









    return 0;
}
