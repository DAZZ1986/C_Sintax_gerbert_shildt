#include <locale.h>
#include <stdio.h>



int main(void)
{
	char* locale = setlocale(LC_ALL, "");


	// http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/II.htm
	printf("\n\n\n/////////// Часть II. Стандарт C99\n");
	/*
	Как известно, языки программирования непрерывно развиваются, реагируя на изменения в методологии, приложениях, 
	общепринятой практике и используемом оборудовании. Не является исключением в этом отношении и язык C. Его эволюция 
	пошла двумя путями. Первый - это продолжение разработки самого языка C. Второй путь - это язык C++, для которого C 
	послужил отправной точкой. И хотя последние несколько лет внимание специалистов приковано к C++, но никогда не ослабевал
	их интерес к развитию языка С. Например, в ответ на интернационализацию вычислительной среды, в 1995 году в 
	первоначальный Стандарт C89 были введены различные двух- и многобайтовые функции. После завершения согласования 
	поправок в 1995 году началось общее обновление языка. Конечным результатом этого обновления, конечно же, является С99.

	При создании стандарта 1999 года были тщательно перепроверены все элементы языка С, проанализированы типичные способы 
	его использования и сделаны попытки предугадать будущие потребности. Как и ожидалось, фоном для всего творческого 
	процесса послужили "взаимоотношения" С и C++. Получившийся в результате Стандарт С99 является доказательством мощи
	своего первоисточника. Было изменено очень малое число ключевых элементов С. Говоря кратко, изменения заключаются в
	том, что было тщательно отобрано небольшое количество дополнений к языку, а также было добавлено несколько новых
	библиотечных функций. Так что язык С все еще остается языком С!

	В части I этой книги рассказывалось о тех возможностях С, которые были определены в Стандарте С89. В этой части мы
	обсудим возможности, которые появились в С99, а также немногочисленные отличия между С99 и С89.
	*/






	// http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/11/11.htm
	printf("\n\n\n/////////// Глава 11. C99\n");
	/*
	Возможно, самая большая причина для беспокойства, связанного с появлением нового языкового стандарта, — это вопрос о
	совместимости со своим предшественником. Устареют ли уже написанные программы после выхода новой спецификации? Были ли 
	изменены важные конструкции? Надо ли менять методологию или технологию программирования? Ответы на эти вопросы часто 
	определяют, в какой степени будет принят новый стандарт и, в дальней перспективе, жизнеспособность самого языка. К 
	счастью, создание С99 было управляемым, беспристрастным процессом — благодаря опытным "диспетчерам" этого процесса. 
	Попросту говоря, если вам нравился С таким, каким он был, то понравится и версия С, определяемая Стандартом С99. То,
	что многие программисты думали о языке С как о самом элегантном в мире языке программирования, не устарело и сейчас!

	В этой главе мы изучим изменения в С и дополнения к С, сделанные Стандартом 1999 года. Многие из этих изменений были
	вскользь упомянуты еще в части I. Здесь же они будут рассмотрены более подробно. Однако не забывайте, что во время 
	написания этой книги компиляторы, которые поддерживали бы многие новые возможности С99, еще не были широко распространены.
	Возможно, вам придется немного подождать перед тем, как провести "испытательные полеты" с такими новыми восхитительными
	конструкциями, которыми являются массивы переменной длины, restricted-квалифицированные указатели и тип данных long long.

	Содержание:
		Сравнение С99 с С89. Общее впечатление
		Указатели, определенные с квалификаторами типа restrict
		Ключевое слово inline
		Новые встроенные типы данных
		Расширение массивов
		Однострочные комментарии
		Распределение кода и объявлений
		Изменения препроцессора
		Объявление переменных внутри цикла for
		Составные литералы
		Массивы с переменными границами в качестве членов структур
		Назначенные инициализаторы
		Новые возможности семейства функций printf() и scanf()	//ДО ЭТОГО МОМЕНТА ПОВТОРИТЬ ЭТИ ПУНКТЫ В Глава 08. Ввод / вывод на консоль
		Новые библиотеки С99
		Зарезервированный идентификатор __func__
		Расширение граничных значений трансляции
		Неявный int больше не поддерживается
		Удалены неявные объявления функций
		Ограничения на return
		Расширенные целые типы
		Изменения в правилах продвижения целых типов
	*/






	// http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/11/1101.htm
	printf("\n\n\n/////////// Сравнение С99 с С89. Общее впечатление\n");
	/*
	Отличия между С99 и С89 можно разбить на три общие категории:
	- новые возможности, добавленные к С89
	- возможности, удаленные из С89
	- возможности, которые были изменены или расширены
	Многие из отличий между С89 и С99 достаточно незначительны и относятся лишь к нюансам языка. А в этой книге основное 
	внимание уделяется достаточно заметным изменениям — заметным настолько, чтобы влиять на способ написания программ.
	
	
	
	
	///////////Новые возможности
	Скорее всего, самыми заметными из новых средств, которых не было в С89, являются те, которые связаны с использованием 
	новых ключевых слов:
	inline
	restrict
	_Bool
	_Complex
	_Imaginary

	К другим важным новинкам относятся:
		массивы переменной длины
		поддержка арифметических операций с комплексными числами
		тип данных long long int
		комментарий //
		возможность распределять код и данные
		добавления к препроцессору
		объявления переменных внутри оператора for
		составные литералы
		массивы с переменными границами в качестве членов структур
		назначенные инициализаторы
		изменения в семействе функций printf() и scanf()
		зарезервированный идентификатор __func__
		новые библиотеки и заголовки

	Большинство возможностей были созданы комитетом по стандартизации, причем многие из этих возможностей созданы с учетом 
	расширений языка, имеющихся в разных реализациях языка С. Впрочем, в некоторых случаях возможности были позаимствованы 
	у C++, как, например, ключевое слово inline и комментарии вида //. Важно понять, что при создании С99 не были добавлены
	классы в стиле C++, наследование и функции-члены. В том, что С должен остаться С — в этом комитет по стандартизации был
	единодушен.






	///////////Удаленные средства
	Самым заметным "излишеством", удаленным при создании С99, было правило "неявного int". В С89 во многих случаях, когда 
	не было явного указания типа данных, подразумевался тип int. А в С99 такое не допускается. Также удалено неявное 
	объявление функций. В С89, если функция перед использованием не объявлялась, то подразумевалось неявное объявление. 
	А в С99 такое не поддерживается. Если программа должна быть совместима с С99, то из-за двух этих изменений, возможно, 
	придется немного подправить код.






	///////////Измененные средства
	При создании С99 было сделано несколько изменений имевшихся средств. По большей части, эти изменения расширяют возможности
	или вносят определенную ясность в их значение. И только в небольшом количестве случаев изменения ограничивают или сужают
	применение средства. Многие изменения небольшие, однако некоторые из них являются достаточно важными, в том числе:
		- уменьшение ограничений транслятора
		- новые целые типы
		- расширение правил продвижения целых типов
		- более строгие правила употребления оператора return

	Что касается влияния этих изменений на уже написанные программы, то самое значительный эффект имеет изменение правил
	употребления оператора return, из-за чего код, возможно, придется немного подправить.
	В оставшейся части этой главы мы изучим основные различия между С89 и С99.
	*/








	// http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/11/1102.htm
	printf("\n\n\n/////////// Указатели, определенные с квалификаторами типа restrict\n");
	/*
	Одной из самых важных новинок, введенных Стандартом С99, является квалификатор типа restrict (ограниченный). Этот 
	квалификатор применяется только к указателям. Указатель, определенный с квалификатором типа restrict[1], изначально 
	является единственным средством, с помощью которого можно получить доступ к указываемому объекту. Доступ к объекту с 
	помощью другого указателя возможен лишь тогда, когда этот второй указатель основан на первом. Таким образом, доступ к 
	объекту возможен только для выражений, составленных на основе указателя с квалификатором типа restrict. Такие
	указатели в основном используются как параметры функций или для указания памяти, распределенной с помощью malloc(). 
	Квалификатор типа restrict семантики программы не меняет.

	Если указатель квалифицирован с помощью квалификатора типа restrict, то компилятор может лучше оптимизировать некоторые 
	программы, зная, что указатель с квалификатором типа restrict является единственным средством доступа к объекту. 
	Например, если функция имеет два параметра в виде указателей с квалификатором типа restrict, то компилятор может 
	допустить, что указатели указывают на разные (причем неперекрывающиеся!) объекты. Проанализируем, например, то, что
	стало классическим примером применения restrict — определение функции memcpy(). В С89 у нее имеется следующий прототип:
	void *memcpy(void *cmp1, const void *cmp2, size_t размер);

	В описании memcpy() сказано, что если объекты, на которые указывают cmp1 и cmp2, перекрываются, то поведение этой 
	функции непредсказуемое. Таким образом. memcpy() гарантированно будет работать только с неперекрывающимися объектами.

	В С99 можно использовать restrict, чтобы в прототипе memcpy() явно указать то, что в С89 приходится дополнительно 
	объяснять словами. Вот прототип memcpy() в С99:
	void *memcpy(void * restrict cmp1, const void * restrict cmp2, size_t размер);

	Квалифицируя cmp1 и cmp2 с помощью квалификатора типа restrict, в прототипе явно утверждается, что они указывают на 
	неперекрывающиеся объекты.
	Из-за преимуществ, которые может принести использование квалификатора типа restrict, в С99 он был добавлен в прототипы
	многих библиотечных функций, определенных еще в С89.

	----------
	[1]Указатель, определенный с квалификатором типа restrict, называется также restrict-квалифицированным указателем или
	указателем, квалифицированным как restrict.
	*/







	// http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/11/1103.htm
	printf("\n\n\n/////////// Ключевое слово inline\n");
	/*
	При разработке С99 было добавлено ключевое слово inline, которое применяется к функциям. Ставя inline в начале 
	объявления функции, вы предлагаете компилятору оптимизировать вызовы к этой функции. Обычно это означает, что при
	компиляции код этой функции будет вставляться на месте вызовов. Однако ключевое слово inline является всего лишь
	запросом к компилятору и может быть проигнорировано. В С99 особо отмечено, что использование inline "предполагает, 
	что вызовы функции должны быть максимально быстрыми". Спецификатор inline также поддерживается в языке C++, и
	синтаксис С99 для этого ключевого слова совместим с C++.

	Чтобы создать встраиваемую функцию[1], перед ее определением поставьте ключевое слово inline. Например, в следующей
	программе оптимизируются вызовы функции max():
	#include <stdio.h>

	inline int max(int a, int b)
	{
	  return a > b ? a : b;
	}

	int main(void)
	{
	  int x=5, y=10;

	  printf("Наибольшим из чисел %d и %d является: %d\n", x, y, max(x, y));

	  return 0;
	}
	При типичной реализации inline предшествующая программа эквивалентна следующей:
	#include <stdio.h>

	int main(void)
	{
	  int x=5, y=10;

	  printf("Наибольшим из чисел %d и %d является: %d\n", x, y, (x>y ? x : y));

	  return 0;
	}

	Причина, по которой встраиваемым функциям придается такое большое значение, состоит в том, что они помогают создавать
	более эффективный код, поддерживая при этом структурированный, функционально-ориентированный подход. Как вы знаете, 
	каждый раз при вызове функции механизм ее вызова и возврата требует значительного количества ресурсов. Обычно при вызове
	функции ее аргументы заталкиваются в стек, содержимое различных регистров заносится в память, а затем при возврате 
	функции содержимое этих регистров восстанавливается. Беда в том, что на эти операции требуется время. Однако, если код
	функции подставляется вместо вызова, такие операции уже не нужны. Впрочем, хотя такие подстановки функции и способствуют
	ускорению выполнения, но они приводят к увеличению размера кода из-за дублирования кода функции. По этой причине лучше
	всего использовать inline только с очень небольшими функциями, т.е. подставлять код только маленьких функций. Кроме 
	того, хорошо было бы применять это ключевое слово только к тем функциям, которые существенно влияют на производительность
	программы.

	Помните: хотя inline обычно приводит к подстановке кода функции на месте ее вызова, компилятор может проигнорировать 
	этот запрос или использовать некоторые другие средства оптимизации вызовов функции.

	----------
	[1]Называется также подставляемой функцией.
	*/







	// http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/11/1104.htm
	printf("\n\n\n/////////// Новые встроенные типы данных\n");
	/*
	В стандарте С99 появились новые для С встроенные типы данных. Здесь подробно рассказывается о каждом из них.
	
	
	
	
	///////////_Вооl
	Один из новых типов данных, появившихся в С99, — это _Bool, в котором можно хранить значения 1 и 0 (истина (true) и 
	ложь (false)). _Bool представляет собой целый тип данных. Как известно многим читателям, в языке C++ определяется 
	ключевое слово bool, которое, несмотря на сходство, все же отличается от _Bool. Таким образом, в написании этого типа 
	С99 и C++ несовместимы. Кроме того, в C++ определяются встроенные логические константы true и false, а в С99 этого не 
	делается. Однако в С99 имеется заголовок <stdbool.h>, в котором определены имена макросов bool, true и false. Таким 
	образом, можно легко создавать код, совместимый с C/C++.

	Причина того, что в качестве ключевого слова указывается _Bool, а не bool, состоит в том, что во многих уже имеющихся 
	С-программах определены их собственные варианты bool. Определяя логический тип как _Bool, C99 дает возможность не
	менять уже написанный код. Однако в новые программы лучше всего вставлять <stdbool.h>, а затем использовать имя макроса
	bool.





	///////////_Complex и _Imaginary
	Стандарт С99 появился вместе с новой для С поддержкой арифметических операций с комплексными числами; эта поддержка
	включает в себя ключевые слова _Complex и _Imaginary, дополнительные заголовки и несколько новых библиотечных функций.
	Однако никаких реализаций не требуется, чтобы реализовать типы мнимых чисел (imaginary types), а автономные приложения
	(которые обходятся без операционной системы) не обязаны поддерживать комплексные типы. Арифметические операции с
	комплексными числами появились в С99 для упрощения программирования численных методов.

	Определены следующие комплексные типы:
	float_Complex
	float_Imaginary
	double_Complex
	double_Imaginary
	long double_Complex
	long double_Imaginary

	Причина того, что в качестве ключевых слов определены _Complex и _Imaginary, а не complex и imaginary, состоит в том, 
	что во многих имеющихся С-программах уже определены их собственные типы комплексных данных, использующие имена complex 
	и imaginary. Определяя ключевые слова _Complex и _Imaginary, C99 позволяет не менять уже написанный код.
	Заголовок <complex.h> определяет (кроме всего прочего) макросы complex и imaginary, которые в результате макроподстановки
	превращаются в _Complex и _Imaginary. Таким образом, в новые программы лучше всего вставлять <complex.h>, а затем
	использовать макросы complex и imaginary.





	///////////Типы целых данных long long
	В стандарте С99 появились новые для С типы данных long long int и unsigned long long int. Диапазон значений типа данных
	long long int не уже, чем интервал от -(263-1) до (263-1). А диапазон значений типа данных unsigned long long int обязан
	содержать интервал от 0 до 264-1. Типы long long позволяют поддерживать 64-разрядные целые значения с помощью
	встроенного типа.
	*/







	// http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/11/1105.htm
	printf("\n\n\n/////////// Расширение массивов\n");
	/*
	В Стандарте С99 появились два новых для С и достаточно важных свойства массивов: переменная длина и возможность включать 
	в объявлениях массивов квалификаторы типа.





	///////////Массивы переменной длины
	В С89 размерности массивов необходимо объявлять при помощи выражений из целых констант, причем размер массива фиксируется
	во время компиляции. В силу определенных обстоятельств, в С99 это правило было изменено. В С99 можно объявить массив, 
	размерности которого определяются любыми допустимыми целыми выражениями, в том числе и такими, значения которых 
	становятся известны только во время выполнения. Такой массив называется массивом переменной длины (variable-length 
	array, VLA). Однако такими массивами могут быть только локальные массивы (то есть те, у которых область видимости —
	прототип или блок). Вот пример массива переменной длины:

	void f(int diml, int dim2)
	{
	  int matrix[diml][dim2]; /* двумерный массив переменной длины
	  // ... //
	}

	В данном случае размер matrix определяется значениями, передаваемыми функции f() через переменные dim1 и dim2. Таким 
	образом, в результате каждого вызова f() может получиться массив matrix с самыми разными измерениями.
	Важно понять, что массивы переменной длины за время "своей жизни" не меняют своих размеров. (Иными словами, они не
	являются динамическими.) На самом деле массив переменной длины создается с другим размером каждый раз, когда встречается
	его объявление.
	Можно указать массив переменной длины неуказанного размера, используя в качестве размера звездочку, * .

	Появление массивов переменной длины вызвало небольшое изменение в операторе sizeof. Вообще говоря, sizeof — это оператор,
	который вычисляется во время компиляции.То есть во время компиляции он обычно превращается в целую константу, значение 
	которой равно размеру типа или объекта.Однако если sizeof применяется к массиву переменной длины, то свое значение он 
	получает только во время выполнения.Это изменение было необходимо потому, что размер массива переменной длины нельзя
	узнать до времени выполнения.

	Одной из главных причин появления массивов переменной длины является желание упростить программирование численных методов.
	Конечно, это средство применяется довольно широко.Но помните — массивы переменной длины не поддерживаются Стандартом
	С89(и в языке C++).
	
	
	
	
	
	///////////Использование квалификаторов типов в объявлении массива
	В С99 при объявлении массива в качестве параметра функции, внутри квадратных скобок этого объявления можно указать 
	ключевое слово static.Оно сообщает компилятору, что в массиве, на который указывает этот параметр, всегда будет 
	находиться как минимум названное количество элементов.Например:
	int f(char str[static 80])
	{
		// здесь str всегда является указателем на массив из 80 элементов
		//
	}
	Здесь дается гарантия, что str будет указывать на начало массива типа char, причем в нем будет не менее 80 элементов.
	Внутри квадратных скобок также допускаются ключевые слова restrict, volatile и const, но только для параметров функций.
	Использование restrict означает, что указатель изначально является единственным средством доступа к объекту.
	Применение const показывает, что указатель указывает на один и тот же массив(то есть указатель всегда указывает на
	один и тот же объект).Можно использовать и volatile (означает "асинхронно-изменяемый"), хотя и нет смысла это делать.
	*/







	// http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/11/1107.htm
	printf("\n\n\n/////////// Распределение кода и объявлений\n");
	/*
	В соответствии со Стандартом С89 все объявления, находящиеся внутри блока, должны предшествовать первому оператору кода. 
	Но к Стандарту С99 это правило не относится. Рассмотрим, например, программу
	#include <stdio.h>

	int main(void)
	{
	  int i;

	  i = 10;

	  int j; // неправильно для С89; допустимо для С99 и C++

	  j = i;

	  printf("%d %d", i, j);

	  return 0;
	}

	Здесь выражение
	i = 10
	находится между двумя объявлениями: переменной i и переменной j. Стандарт С89 такое не разрешает. Зато это вполне
	допускается в С99 (да и в C++ тоже). Возможность распределять объявления и код довольно широко используется в языке C++. 
	Появление этой возможности в языке С облегчает написание кода, который можно использовать в средах обоих языков.
	*/






	// http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/11/1108.htm
	printf("\n\n\n/////////// Изменения препроцессора\n");
	/*	//ЖЕНЯ
	Стандарт С99 внес небольшие изменения и в препроцессор.


	///////////Переменные списки аргументов
	Возможно, самым важным изменением препроцессора является возможность обрабатывать макросы с переменным количеством 
	аргументов. На переменное количество аргументов указывает многоточие (...), находящееся в определении макроса. 
	Встроенный препроцессорный идентификатор __VA_ARGS__ определяет, куда будут подставляться аргументы. Например, 
	после включения в программу определения
	#define MyMax(...) max(__VA_ARGS__)

	выражение
	MyMax(a, b);
	преобразуется в
	max(a, b);

	До обозначения переменного количества аргументов (...) макрос может иметь другие аргументы. Например, после определения
	#define compare(compfunc, ...) compfunc(__VA_ARGS__)

	оператор
	compare(strcmp, "один", "два");
	преобразуется в оператор
	strcmp("один", "два");
	Как видно из примера, встроенный идентификатор __VA_ARGS__ заменяется всеми остальными аргументами.
	
	
	
	
	
	///////////Оператор _Pragma
	С выходом С99 в языке С появился еще один способ определять прагму в программе: оператор _Pragma. В общем виде этот 
	оператор выглядит таким образом:
	_Pragma("директива")

	Здесь директива — это вызываемая прагма[1]. Появление оператора _Pragma дает прагмам возможность участвовать в макрозамене.
	
	
	
	
	
	
	///////////Встроенные прагмы
	Прагма									Что означает
	STDC FP_CONTRACT ON/OFF/DEFAULT			Во включенном состоянии (ON) выражения с плавающей точкой считаются неделимыми 
											структурами, которые обрабатываются с помощью аппаратуры. Состояние по умолчанию
											(DEFAULT) определяется реализацией.
	STDC FENV_ACCESS ON/OFF/DEFAULT			Сообщает компилятору, что доступна аппаратура для выполнения операций с плавающей
											точкой. Состояние по умолчанию определяется реализацией.
	STDC CX_LIMITED_RANGE ON/OFF/DEFAULT	Во включенном состоянии (ON)сообщает компилятору, что некоторые формулы с 
											составными значениями являются безопасными. Отключенное состояние (OFF) задается 
											по умолчанию.

	Подробные сведения об этих прагмах должны быть приведены в документации по компилятору.






	///////////Новые встроенные макросы
	К макросам, поддерживаемым С89, в С99 добавлены следующие:
	__STDC_HOSTED__				1, если имеется операционная система.
	__STDC_VERSION__			не меньше, чем 199901L; представляет версию языка С.
	__STDC_IЕС_559__			1, если поддерживаются арифметические операции с плавающей запятой IEC 60559.
	__STDC_IEC_559_COMPLEX__	1, если поддерживаются арифметические операции с комплексными числами IEC 60559.
	__STDC_ISO_10646__			Значение в виде гггглшЬ, которое указывает год и месяц выхода спецификации ISO/IEC 10646, 
								поддерживаемой компилятором.

	----------
	[1]Прагма называется также указанием транслятору, псевдокомментарием, директивой транслятора, указанием компилятору, 
	директивой компилятора.
	*/






	// http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/11/1109.htm
	printf("\n\n\n/////////// Объявление переменных внутри цикла for\n");
	/*
	С99 расширяет возможности цикла for, разрешая объявление одной или нескольких переменных в части инициализации цикла. 
	Область видимости переменной, объявленной таким способом, ограничена блоком программы, управляемым выражением for. 
	To есть переменная, объявленная внутри цикла for, будет локализована внутри этого цикла. Эта возможность появилась в
	языке С потому, что управляющая переменная цикла for часто необходима только внутри этого цикла. А так как эта 
	переменная локализована внутри цикла, то удается избежать ненужных побочных эффектов.

	Вот пример, в котором переменная объявляется в части инициализации цикла for:
	#include <stdio.h>

	int main(void)
	{
	  // объявить i внутри for
	  for(int i=0; i < 10; i++)
		printf("%d ", i);

	  return 0;
	}
	Здесь переменная i объявляется внутри цикла for, а не до начала его работы.
	Как уже говорилось, переменная, объявленная внутри цикла for, локализуется внутри этого цикла. Проанализируйте следующую
	программу. Обратите внимание, что переменная i объявляется дважды: в начале main() и внутри цикла for.
	#include <stdio.h>

	int main(void)
	{
	  int i = -99;

	  // объявить i внутри for
	  for(int i=0; i < 10; i++)
		printf("%d ", i);

	  printf("\n");

	  printf("Значение i равно: %d", i); // выводит -99

	  return 0;
	}

	Эта программа выводит следующее:
	0 1 2 3 4 5 6 7 8 9
	Значение i равно -99

	Как показывает вывод, как только заканчивается цикл for, заканчивается и область видимости переменной i, объявленной внутри
	этого цикла. Таким образом, последнее выражение printf() выводит -99, то есть значение i, объявленное в начале main().

	Возможность объявлять управляющие переменные внутри цикла for, уже довольнотаки долгое время имеется в языке C++, и теперь
	такая возможность используется достаточно широко. Есть надежда, что большинство С-программистов будут делать то же самое.
	*/






	// http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/11/1110.htm
	printf("\n\n\n/////////// Составные литералы\n");
	/*	//ЖЕНЯ
	С99 дает возможность определять составные литералы, которые являются выражениями, состоящими из массивов, структур или
	объединений; эти выражения и обозначают объекты данного типа. Составной литерал создается путем указания имени типа в 
	круглых скобках, за которым следует список инициализации, обязательно заключенный в фигурные скобки. Когда именем типа
	является массив, то размер указывать нельзя. Создается безымянный объект.

	Вот пример составного литерала:
	double *fp = (double[]) {1.0, 2.0, 3.0};

	В данном случае создается указатель на double, который называется fp и указывает на первый элемент массива, состоящего 
	из трех элементов типа double.

	Составной литерал, созданный в области видимости файла, существует все время жизни программы. А составной литерал, 
	созданный внутри блока, является локальным объектом, который разрушится, как только при выполнении программы произойдет
	выход из этого блока.
	*/






	// http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/11/1111.htm
	printf("\n\n\n/////////// Массивы с переменными границами в качестве членов структур\n");
	/*	//ЖЕНЯ - массив в структуре как последний член, и что такое malloc()?
	С99 дает возможность в качестве последнего члена структуры указывать массив без размера. (В структуре перед гибким
	массивом-членом должен стоять как минимум еше один член.) Он называется членом-массивом с переменными границами. 
	Таким образом, структура может иметь в качестве члена массив переменного размера. В размере такой структуры, 
	возвращаемом sizeof, память для гибкого массива не учитывается.

	Обычно память для структуры с членом-массивом с переменными границами распределяется автоматически, с помощью malloc(). 
	Кроме размера структуры, необходимо еше выделить дополнительную память, чтобы разместить член-массив с переменными
	границами нужного размера. Например, если имеется следующее определение структуры

	sturct mystruct {
	  int a;
	  int b;
	  float fa[]; //массив с переменными границами
	};
	то при выполнении следующего кода будет выделяться место для массива из 10 элементов:
	struct mystruct *p;
	p = (struct mystruct *) malloc(sizof(struct mystuct) + 10 *
	sizof(float);)

	Так как sizeof (struct mystruct) дает значение, в котором не учтен размер памяти для fa, то при вызове malloc() с 
	помощью выражения
	10 *sizof(float)
	дополнительно выделяется место для размещения массива из 10 элементов типа float.
	*/





	// http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/11/1112.htm
	printf("\n\n\n/////////// Назначенные инициализаторы\n");
	/*
	В С99 появилась новая для С возможность, которая будет особенно полезна для программистов, работающих с разреженными 
	массивами. Это назначенные инициализаторы. Такие инициализаторы бывают двух видов: одного вида — для массивов, а 
	другого — для структур и объединений. Для массивов используется назначенные инициализаторы такого вида:

	[индекс] = знач

	где индекс указывает элемент, инициализируемый с помощью значения знач (то есть тот элемент, которому присваивается 
	начальное значение знач). Например,
	int а[10] = { [0] = 100, [3] = 200};

	В данном случае инициализируются только элементы с индексами 0 и 3.
	Для членов структур или объединений используется назначенные инициализаторы такого вида:
	.имя-члена

	Применение к структуре назначенного инициализатора позволяет легко инициализировать только нужные члены структуры. 
	Например,
	struct mystruct {
	  int a;
	  int b;
	  int c;
	} ob = { .c = 30, .a = 10 };
	В данном случае, в переменной структуре ob, член b остается неинициализированным.

	Кроме того, применение назначенных инициализаторов дает возможность инициализировать структуру, даже не зная порядка 
	расположения ее членов. Это полезно для предопределенных структур, таких как div_t, или для структур, определенных 
	некоторыми независимыми производителями.
	*/





	// http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/11/1113.htm
	printf("\n\n\n/////////// Новые возможности семейства функций printf() и scanf()\n");
	/*
	В С99 для семейства функций printf() и scanf() предусмотрена новая возможность: они могут манипулировать с типами данных
	long long int и unsigned long long int. Модификатором формата для long long является ll. Например, в следующем фрагменте
	показано, как выводить значения типа long long int и unsigned long long int:

	long long int val;
	unsigned long long int u_val;
	printf("%lld %llu", val, u_val);

	Модификатор ll можно применять к спецификаторам формата: d, i, о, u и x — как для printf(), так и для scanf().
	В С99 добавлен модификатор hh, который применяется для указания char-аргумента вместе со спецификаторами формата: 
	d, i, о, u и x.

	Оба модификатора, ll и hh, можно использовать также вместе со спецификатором n.
	Спецификаторы формата a и A, которые были добавлены к printf(), заставляют выводить значение с плавающей точкой в 
	шестнадцатеричном формате. Формат значения получается следующий:
	[-]0xh.hhhhp+d

	Если используется А, то x и p будут выводиться на верхнем регистре. Спецификаторы формата a и A были также добавлены к 
	scanf() и они читают значение с плавающей точкой.
	В С99 разрешается при вызове printf() к спецификатору %f добавлять модификатор l (тогда получится %lf), но от этого 
	нет никакой пользы[1]. В С89 %lf для printf() не определяется.

	----------
	[1]Иногда есть: если строка формата используется и для других целей.
	*/






	// http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/11/1114.htm
	printf("\n\n\n/////////// Новые библиотеки С99\n");
	/*
	В С99 добавлены новые библиотеки и заголовки. Вот они:
	Заголовок	Назначение
	<complex.h>	Поддерживает арифметические операции с комплексными числами.
	<fenv.h>	Дает доступ к флажкам состояния вычислителя, выполняющего операции с плавающей точкой и другим сигналам 
				этого вычислителя.
	<inttypes.h>Определяет стандартный, переносимый набор имен целых типов. Также поддерживает функции, которые работают
				с целыми значениями наибольшей разрядности.
	<iso646.h>	Добавлен в 1995 году Поправкой 1. Определяет имена макросов,соответствующие разным операторам, таким как
				&& и ^.
	<stdbool.h>	Поддерживает логические типы данных. Определяет имена макросов bool, true и false, что помогает обеспечивать
				совместимость с C++.
	<stdint.h>	Определяет стандартный, переносимый набор имен целых типов. Этот заголовок входит в состав <inttypes.h>.
	<tgmath.h>	Определяет макросы для родового (абстрактного) типа чисел с плавающей точкой.
	<wchar.h>	Добавлен в 1995 году Поправкой 1. Поддерживает многобайтовые и двухбайтовые функции.
	<wctype.h>	Добавлен в 1995 году Поправкой 1. Поддерживает многобайтные и двухбайтовые функции классификации.

	О содержимом этих заголовков и поддерживаемых ими функциях рассказывается в части III.
	*/


	// http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/11/1115.htm
	printf("\n\n\n/////////// Зарезервированный идентификатор __func__\n");
	/*
	В С99 определен идентификатор __func__, который указывает (в виде строкового литерала) имя функции, в которой 
	встречается __func__. Например,

	void StrUpper(char *str)
	{
	  static int i = 0;

	  i++;
	  printf("Функция %s была вызвана %d раз(а).\n", __func__, i);

	  while(*str) {
		*str = toupper(*str);
		str++;
	  }
	}

	При первом вызове функции StrUpper() появится следующий вывод:
	Функция StrUpper была вызвана 1 раз(а).
	*/






	// http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/11/1116.htm
	printf("\n\n\n/////////// Расширение граничных значений трансляции\n");
	/*
	Термин "граничные значения трансляции" означает минимальное число разнообразных элементов, которые должен обрабатывать
	компилятор С. Сюда входит длина идентификаторов, количество уровней вложенности, количество выражений case и допустимое
	количество членов структуры или объединения. В С99 увеличены некоторые из предельных значений для количества этих 
	элементов несмотря на то, что они и так были достаточно щедро определены Стандартом С89. 

	Вот некоторые примеры:

	Граничное значение для количества				C89	C99
	уровней вложенности блоков						15	127
	уровней вложенности условных включений			8	63
	значащих символов во внутреннем идентификаторе	31	63
	значащих символов во внешнем идентификаторе		6	31
	членов структуры или объединения				127	1023
	аргументов при вызове функции					31	127
	*/






	// http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/11/1117.htm
	printf("\n\n\n/////////// Неявный int больше не поддерживается\n");
	/*
	Несколько лет назад язык C++ отменил правило неявного int, а с приходом С99 этому примеру последовал и язык С. В С89 
	правило неявного int гласит, что если явный спецификатор типа отсутствует, то подразумевается тип int. Больше всего
	это правило применялось к возвращаемому типу функций. В прошлом С-программисты часто пропускали int при объявлении 
	функций, которые возвращали значение такого типа. Например, в ранние времена языка С функцию main() часто писали 
	примерно так:

	main ()
	{
	  // ... //
	}

	При таком подходе возвращаемым типом по умолчанию просто считался int. В С99(да и в C++) такого правила присвоения типа
	по умолчанию больше нет, и int приходится указывать явно, что и делается во всех программах, приведенных в этой книге.

	А вот другой пример. В прошлом функция, такая как
	int isEven(int val)
	{
		return !(val % 2);
	}

	часто писалась примерно так:
	//по умолчанию используется целый тип
	isEven(int val)
	{
		return !(val % 2);
	}

	В первом экземпляре кода возвращаемый тип int указывается явно. Во втором — это подразумевается по умолчанию.
	Правило неявного int применялось не только к возвращаемым значениям функций(хотя здесь оно применялось чаще всего).
	Например, в С89 и более ранних версиях функцию isEven() можно было писать примерно еще и так:

	isEven(const val)
	{
		return !(val % 2);
	}

	Здесь параметр val также имеет по умолчанию тип int — в этом случае const int. И опять, это присвоение типа по умолчанию
	int не поддерживается в Стандарте С99.

	На заметку: В действительности компилятор, совместимый с С99, может принять код, содержащий неявные типы int, даже после 
	того, как выдаст предупреждение об ошибке. Так что иногда можно компилировать и старый код. Однако компилятор, совместимый
	с С99, не обязан принимать такой код.
	*/






	// http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/11/1118.htm
	printf("\n\n\n/////////// Удалены неявные объявления функций\n");
	/*
	Если в С89 встречался вызов функции до явного объявления, то создавалось неявное объявление этой функции. Это неявное 
	объявление имеет такой вид:
	extern int имя();
	В С99 неявные объявления функций не поддерживаются.

	На заметку: В действительности компилятор, совместимый с С99, может принять код содержащий неявные объявления функций, 
	даже после того, как выдаст предупреждение об ошибке. Так что можно компилировать и старый код. Однако компилятор, 
	совместимый с С99, не обязан принимать такой код.
	*/






	// http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/11/1119.htm
	printf("\n\n\n/////////// Ограничения на return\n");
	/*
	В С89 в функции, которая имеет возвращаемый тип, отличный от void (т.е. предполагается, что такая функция возвращает 
	значение), может встретиться оператор return без выражения. Хотя в результате этого теоретически поведение программы
	было неопределенным, технически в этом не было ничего "незаконного". Но в С99 в функции, тип которой отличен от void, 
	оператор return обязан иметь выражение. То есть в С99 внутри функции, которая согласно определению возвращает значение,
	любой оператор return обязан иметь ассоциированное с ним значение, которое и будет возвращено этой функцией. Таким 
	образом, следующая функция является синтаксически допустимой в С89, но недопустима в С99:

	int f(void)
	{
	  //   ...   //
		return;   // в С99 этот оператор должен возвращать значение
	}
	*/






	// http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/11/1120.htm
	printf("\n\n\n/////////// Расширенные целые типы\n");
	/*
	С99 в <stdint.h> определяет несколько расширенных целых типов. Расширенные типы включают в себя типы с точной 
	разрядностью, минимальной разрядностью, максимальной разрядностью и самый быстрый целый тип. 
	Вот подборка таких типов:
	Расширенный тип		Что означает
	int16_t				Тип 16-разрядных целых
	int_least16_t		Тип целых, содержащий не менее 16 разрядов
	int_fast32_t		Самый быстрый тип целых, содержащий не менее 32 разрядов
	intmax_t			Тип самых больших целых
	uintmax_t			Тип самых больших целых без знака

	Расширенные типы облегчают написание переносимого кода. Более подробно они описаны в части III. 
	*/






	// http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/11/1121.htm
	printf("\n\n\n/////////// Изменения в правилах продвижения целых типов\n");
	/*	//ЖЕНЯ
	В С99 расширены правила продвижения целых типов. В С89 значение типа char, short int или битового поля int можно было
	использовать в выражении вместо int или unsigned int. Если продвинутое значение помещалось в int, то продвижение 
	выполнялось до int; в противном же случае первоначальное значение продвигалось до unsigned int.

	В С99 каждому целому типу присвоен ранг. Например, ранг long long int выше, чем ранг int, который в свою очередь выше,
	чем ранг char и так далее. В выражении любой целый тип, ранг которого ниже, чем ранг int или unsigned int, может 
	использоваться вместо int или unsigned int.
	*/


	return 0;
}
