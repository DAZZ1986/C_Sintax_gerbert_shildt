#include <locale.h>
#include <stdio.h>



int main(void)
{
    char* locale = setlocale(LC_ALL, "");

    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/07/07.htm
    printf("\n\n\n/////////// Структуры, объединения, перечисления и декларации typedef\n");
    /*
    В языке С имеется пять способов создания пользовательских типов данных. Пользовательские типы данных можно создать
    с помощью:
    1. структуры — группы переменных, имеющей одно имя и называемой агрегатным типом данных. (Кроме того, еще известны
       термины соединение (compound) и конгломерат (conglomerate).);
    2. объединения - которое позволяет определять один и тот же участок памяти как два или более типов переменных;
    3. битового поля - которое является специальным типом элемента структуры или объединения, позволяющим легко получать
       доступ к отдельным битам;
    4. перечисления — списка поименованных целых констант;
    5. ключевого слова typedef - которое определяет новое имя для существующего типа.

    Все эти способы описаны в этой главе.

    Содержание:
        Структуры
        Массивы структур
        Передача структур функциям
        Указатели на структуры
        Массивы и структуры внутри структур
        Объединения
        Битовые поля
        Перечисления
        Важное различие между С и С++
        Использование sizof для обеспечения переносимости
        Средство typedef
    */





    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/07/0701.htm
    printf("\n\n\n/////////// Структуры\n");
    /*Структура — это совокупность переменных, объединенных под одним именем. С помощью структур удобно размещать в смежных
    полях связанные между собой элементы информации. Объявление структуры создает шаблон, который можно использовать для
    создания ее объектов (то есть экземпляров этой структуры). Переменные, из которых состоит структура, называются членами.
    (Члены структуры еще называются элементами или полями.)

    Как правило, члены структуры связаны друг с другом по смыслу. Например, элемент списка рассылки, состоящий из имени и
    адреса логично представить в виде структуры. В следующем фрагменте кода показано, как объявить структуру, в которой
    определены поля имени и адреса. Ключевое слово struct сообщает компилятору, что объявляется (еще говорят, "декларируется")
    структура.

    struct addr
    {
      char name[30];
      char street[40];
      char city[20];
      char state[3];
      unsigned long int zip;
    };
    Обратите внимание, что объявление завершается точкой с запятой, потому что объявление структуры является оператором.
    Тег структуры addr идентифицирует эту конкретную структуру данных и является спецификатором ее типа!

    В данном случае на самом деле никакая переменная не создается. Всего лишь определяется вид данных. Когда вы объявляете
    структуру, то определяете агрегатный тип, а не переменную. И пока вы не объявите переменную этого типа, то существовать
    она не будет. Чтобы объявить переменную (то есть физический объект) типа addr, напишите следующее:
    struct addr addr_info;

    В этом операторе объявлена переменная типа addr, которая называется addr_info. Таким образом, addr описывает вид структуры
    (ее тип), a addr_info является экземпляром (объектом) этой структуры.

    Когда объявляется переменная-структура, компилятор автоматически выделяет количество памяти, достаточное, чтобы разместить
    все ее члены. На рис. 7.1 показано, как addr_info размещена в памяти; в данном случае предполагается, что целые переменные
    типа long занимают по 4 байта.

    Рис. 7.1. Расположение в памяти структуры addr_info
    +------------------------------------------+
    |Name (имя) 30 байт                        |
    +------------------------------------------+

    +-------------------------------------------------+
    |Street (улица) 40 байт                           |
    +-------------------------------------------------+

    +-----------------------------------+
    |City (город) 20 байт               |
    +-----------------------------------+

    +---------------------+
    |State (штат) 3 байта |
    +---------------------+

    +----------------------------+
    |Zip (код) 4 байта           |
    +----------------------------+

    Одновременно с объявлением структуры можно объявить одну или несколько переменных. Например,
    struct addr {
      char name[30];
      char street[40];
      char city[20];
      char state[3];
      unsigned long int zip;
    } addr_info, binfo, cinfo;
    определяет тип структуры, называемый addr, и объявляет переменные этого типа addr_info, binfo и cinfo. Важно понимать,
    что каждая переменная-структура содержит собственные копии членов структуры. Например, поле zip в binfo отличается от
    поля zip в cinfo. Изменения в zip из binfo не повлияют на содержимое поля zip, находящегося в cinfo.

    Если нужна только одна переменная-структура, то тег структуры является лишним. В этом случае наш пример объявления можно
    переписать следующим образом:
    struct {
      char name[30];
      char street[40];
      char city[20];
      char state[3];
      unsigned long int zip;
    } addr_info;
    В этом случае объявляется одна переменная с именем addr_info, причем ее поля указаны в структуре, которая предшествует
    этому имени.

    Общий вид объявления структуры такой:
    struct тег {
      тип имя-члена;
      тип имя-члена;
      тип имя-члена;
      .
      .
      .
    } переменные-структуры;
    причем тег или переменные-структуры могут быть пропущены, но только не оба одновременно.






    ///////////Доступ к членам структуры
    Доступ к отдельным членам структуры осуществляется с помощью оператора "." (который обычно называют оператором точка или
    оператором доступа к члену структуры). Например, в следующем выражении полю zip в уже объявленной переменной-структуре
    addr_info присваивается значение ZIP-кода, равное 12345:
    addr_info.zip = 12345;

    Этот отдельный член определяется именем объекта (в данном случае addr_info), за которым следует точка, а затем именем
    самого этого члена (в данном случае zip). В общем виде использование оператора точка для доступа к члену структуры
    выглядит таким образом:
    имя-объекта.имя-члена

    Поэтому, чтобы вывести ZIP-код на экран, напишите следующее:
    printf("%d", addr_info.zip);
    Будет выведен ZIP-код, который находится в члене zip переменной-структуры addr_infо.

    Точно так же в вызове gets() можно использовать массив символов addr_infо.name:
    gets(addr_info.name);
    Таким образом, в начало name передается указатель на символьную строку.

    Так как name является массивом символов, то чтобы получить доступ к отдельным символам в массиве addr_info.name, можно
    использовать индексы вместе с name. Например, с помощью следующего кода можно посимвольно вывести на экран содержимое
    addr_info.name:
    for(t=0; addr_info.name[t]; ++t)
      putchar(addr_info.name[t]);

    Обратите внимание, что индексируется именно name (а не addr_info). Помните, что addr_info — это имя всего
    объекта-структуры, a name — имя элемента этой структуры. Таким образом, если требуется индексировать элемент структуры,
    то индекс необходимо указывать после имени этого элемента.






    ///////////Присваивание структур
    Информация, которая находится в одной структуре, может быть присвоена другой структуре того же типа при помощи
    единственного оператора присваивания. Нет необходимости присваивать значения каждого члена в отдельности. Как выполняется
    присваивание структур, показывает следующая программа:
    #include <stdio.h>

    int main(void)
    {
      struct {
        int a;
        int b;
      } x, y;

      x.a = 10;

      y = x;  //присваение одной структуры другой

        printf("%d", y.a);

        return 0;
    }
    После присвоения в y.a будет храниться значение 10.
    */
    /*МОИ ТЕСТЫ
    struct Soccer   //объявление структуры в шапке файла (тут просто для наглядности)
    {
        char name[80];
        char lastName[80];
        int age;
        int skill;
        char teamName[80];
    };

    struct Soccer player; //определение структуры

    strcpy_s(player.name, sizeof(player.name), "Di maria"); //инициализация члена/поля name, в структуре player.
    printf("Name: %s \n", player.name);

    player.age = 33; //инициализация члена/поля age, в структуре player.
    printf("Age: %d \n", player.age);
    */







    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/07/0702.htm
    printf("\n\n\n/////////// Массивы структур\n");
    /*
    Структуры часто образуют массивы. Чтобы объявить массив структур, вначале необходимо определить структуру (то есть 
    определить агрегатный тип данных), а затем объявить переменную массива этого же типа. Например, чтобы объявить 
    100-элементный массив структур типа addr, который был определен ранее, напишите следующее:
    struct addr addr_list[100];

    Это выражение создаст 100 наборов переменных, каждый из которых организован так, как определено в структуре addr.

    Чтобы получить доступ к определенной структуре, указывайте имя массива с индексом. Например, чтобы вывести ZIP-код 
    из третьей структуры, напишите следующее:
    printf("%d", addr_list[2].zip);
    Как и в других массивах, к примеру с переменными, в массивах структур индексирование начинается с 0.

    Для справки: 
    - Чтобы указать определенную структуру, находящуюся в массиве структур, необходимо указать имя массива структур
      с определенным индексом. 
    - А если нужно указать индекс определенного элемента в структуре, то необходимо указать индекс этого элемента. 
    Таким образом, в результате выполнения следующего выражения первому символу члена name, находящегося в третьей 
    структуре из addr_list, присваивается значение 'X'.
    addr_list[2].name[0] = 'X';

    
    struct addr {   //наша структура
      char name[30];
      char street[40];
      char city[20];
      char state[3];
      unsigned long int zip;
    } addr_info, binfo, cinfo;

    struct addr addr_list[100];  //объявили массив из 100 структур.

    addr_list[2].name[0] = 'X';  //определили в массиве, в третьей структуре первый элемент.

    Мой коммент:
    Все структуры в массиве являются безимянными, если нужно сделать имя то можно создать структуру с именем и пробросить
    через указатель из массива. И структуры с одинаковыми именем создавать нельзя.




    Пример со списком рассылки
    Чтобы показать, как используются структуры и массивы структур, в этом разделе создается простая программа работы со 
    списком рассылки, и в ее массиве структур будут храниться адреса и связанная с ними информация. Эта информация 
    записывается в следующие поля: name (имя), street (улица), city (город), state (штат) и zip (почтовый код, индекс).

    Вся эта информация, как показано ниже, находится в массиве структур типа addr:
    struct addr {
      char name[30];
      char street[40];
      char city[20];
      char state[3];
      unsigned long int zip;
    } addr_list[MAX];

    Обратите внимание, что поле zip имеет целый тип unsigned long. Правда, чаще можно встретить хранение почтовых кодов, 
    в которых используются строки символов, потому что этот способ подходит для почтовых кодов, в которых вместе с цифрами 
    используются и буквы (как, например, в Канаде и других странах). Однако в нашем примере почтовый индекс хранится в виде
    целого числа; это делается для того, чтобы показать использование числового элемента в структуре.

    Вот main() — первая функция, которая нужна программе:
    int main(void)
    {
      char choice;

      init_list(); //инициализация массива структур

        for (;;) {
            choice = menu_select();
            switch (choice) {
            case 1: enter();
                break;
            case 2: delete();
                break;
            case 3: list();
                break;
            case 4: exit(0);
            }
        }

        return 0;
    }
    Функция начинает выполнение с инициализации массива структур, а затем реагирует на выбранный пользователем пункт меню.
    Функция init_list() готовит массив структур к использованию, обнуляя первый байт поля name каждой структуры массива.
    (В программе предполагается, что если поле name пустое, то элемент массива не используется.) А вот сама 
    функция init_list():

    //Инициализация списка.
    void init_list(void)
    {
        register int t;

        for (t = 0; t < MAX; ++t) addr_list[t].name[0] = '\0';
    }

    Функция menu_select() выводит меню на экран и возвращает то, что выбрал пользователь.
    //Получения значения, выбранного в меню
    int menu_select(void)
    {
        char s[80];
        int c;

        printf("1. Введите имя\n");
        printf("2. Удалите имя\n");
        printf("3. Выведите список\n");
        printf("4. Выход\n");

        do {
            printf("\nВведите номер нужного пункта: ");
            gets(s);
            c = atoi(s);
        } while (c < 0 || c>4);

        return c;
    }

    Функция enter() подсказывает пользователю, что именно требуется ввести, и сохраняет введенную информацию в следующей 
    свободной структуре. Если массив заполнен, то выводится сообщение "Список заполнен". Функция find_free() ищет в массиве 
    структур свободный элемент.
    //Ввод адреса в список
    void enter(void)
    {
        int slot;
        char s[80];

        slot = find_free();
        if (slot == -1) {
            printf("\nСписок заполнен");
            return;
        }

        printf("Введите имя: ");
        gets(addr_list[slot].name);

        printf("Введите улицу: ");
        gets(addr_list[slot].street);

        printf("Введите город: ");
        gets(addr_list[slot].city);

        printf("Введите штат: ");
        gets(addr_list[slot].state);

        printf("Введите почтовый код: ");
        gets(s);
        addr_list[slot].zip = strtoul(s, '\0', 10);
    }

    //Поиск свободной структуры
    int find_free(void)
    {
        register int t;

        for (t = 0; addr_list[t].name[0] && t < MAX; ++t);

        if (t == MAX) return -1; //свободных структур нет
        return t;
    }
    Обратите внимание, что если все элементы массива структур заняты, то find_free() возвращает - 1. Это удобное число, 
    потому что в массиве нет - 1-го элемента.

    Функция delete() предлагает пользователю указать индекс той записи с адресом, которую требуется удалить. Затем функция
    обнуляет первый байт поля name.
    //Удаление адреса
    void delete(void)
    {
        register int slot;
        char s[80];

        printf("Введите № записи: ");
        gets(s);
        slot = atoi(s);
        if (slot >= 0 && slot < MAX)
            addr_list[slot].name[0] = '\0';
    }

    И последняя функция, которая требуется программе, — это list(), которая выводит на экран весь список рассылки. Из-за 
    большого разнообразия компьютерных сред язык С не определяет стандартную функцию, которая бы отправляла вывод на принтер.
    Однако все нужные для этого средства имеются во всех компиляторах С.Возможно, вам самим захочется сделать так, чтобы 
    программа работы со списками могла еще и распечатывать список рассылки.
    //Вывод списка на экран
    void list(void)
    {
        register int t;

        for (t = 0; t < MAX; ++t) {
            if (addr_list[t].name[0]) {
                printf("%s\n", addr_list[t].name);
                printf("%s\n", addr_list[t].street);
                printf("%s\n", addr_list[t].city);
                printf("%s\n", addr_list[t].state);
                printf("%lu\n\n", addr_list[t].zip);
            }
        }
        printf("\n\n");
    }

    Ниже программа обработки списка рассылки приведена полностью. Если у вас остались какие-либо сомнения относительно ее 
    компонентов, введите программу в компьютер и проверьте ее работу, делая в программе изменения и получая соответствующие
    результаты.

    //Простой пример программы обработки списка, в которой используется массив структур
    #include <stdio.h>
    #include <stdlib.h>

    #define MAX 100

    struct addr {
        char name[30];
        char street[40];
        char city[20];
        char state[3];
        unsigned long int zip;
    } addr_list[MAX];

    void init_list(void), enter(void);
    void delete(void), list(void);
    int menu_select(void), find_free(void);

    int main(void)
    {
        char choice;

        init_list(); //инициализация массива структур
        for (;;) {
            choice = menu_select();
            switch (choice) {
            case 1: enter();
                break;
            case 2: delete();
                break;
            case 3: list();
                break;
            case 4: exit(0);
            }
        }

        return 0;
    }

    //Инициализация списка
    void init_list(void)
    {
        register int t;

        for (t = 0; t < MAX; ++t) addr_list[t].name[0] = '\0';
    }

    //Получения значения, выбранного меню
    int menu_select(void)
    {
        char s[80];
        int c;

        printf("1. Введите имя\n");
        printf("2. Удалите имя\n");
        printf("3. Выведите список\n");
        printf("4. Выход\n");
        do {
            printf("\nВведите номер нужного пункта: ");
            gets(s);
            c = atoi(s);
        } while (c < 0 || c>4);
        return c;
    }

    //Ввод адреса в список
    void enter(void)
    {
        int slot;
        char s[80];

        slot = find_free();

        if (slot == -1) {
            printf("\nСписо заполнен");
            return;
        }

        printf("Введите имя: ");
        gets(addr_list[slot].name);

        printf("Введите улицу: ");
        gets(addr_list[slot].street);

        printf("Введите город: ");
        gets(addr_list[slot].city);

        printf("Введите штат: ");
        gets(addr_list[slot].state);

        printf("Введите почтовый индекс: ");
        gets(s);
        addr_list[slot].zip = strtoul(s, '\0', 10);
    }

    //Поиск свободной структуры
    int find_free(void)
    {
        register int t;

        for (t = 0; addr_list[t].name[0] && t < MAX; ++t);

        if (t == MAX) return -1; //свободных структур нет
        return t;
    }

    //Удаление адреса
    void delete(void)
    {
        register int slot;
        char s[80];

        printf("Введите № записи: ");
        gets(s);
        slot = atoi(s);

        if (slot >= 0 && slot < MAX)
            addr_list[slot].name[0] = '\0';
    }

    //Вывод списка на экран
    void list(void)
    {
        register int t;

        for (t = 0; t < MAX; ++t) {
            if (addr_list[t].name[0]) {
                printf("%s\n", addr_list[t].name);
                printf("%s\n", addr_list[t].street);
                printf("%s\n", addr_list[t].city);
                printf("%s\n", addr_list[t].state);
                printf("%lu\n\n", addr_list[t].zip);
            }
        }
        printf("\n\n");
    }
    */







    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/07/0703.htm
    printf("\n\n\n/////////// Передача структур функциям\n");
    /*
    В этом разделе рассказывается о передаче структур и их членов функциям.
    
    
    
    
    ///////////Передача членов структур функциям
    При передаче функции члена структуры передается его значение, притом не играет роли то, что значение берется из члена 
    структуры. Проанализируйте, например, следующую структуру:
    struct fred
    {
      char x;
      int y;
      float z;
      char s[10];
    } mike;

    Например, обратите внимание, каким образом каждый член этой структуры передается функции:
    func(mike.x);    //передается символьное значение x
    func2(mike.y);   //передается целое значение y
    func3(mike.z);   //передается значение с плавающей точкой z
    func4(mike.s);   //передается адрес строки s
    func(mike.s[2]); //передается символьное значение s[2]

    В каждом из этих случаев функции передается значение определенного элемента, и здесь не имеет значения то, что этот 
    элемент является частью какой-либо большей совокупности.

    Если же нужно передать адрес отдельного члена структуры, то перед именем структуры должен находиться оператор&. Например,
    чтобы передать адреса членов структуры mike, можно написать следующее:
    func(&mike.x);    //передается адрес символа x
    func2(&mike.y);   //передается адрес целого y
    func3(&mike.z);   //передается адрес члена z с плавающей точкой
    func4(mike.s);    //передается адрес строки s
    func(&mike.s[2]); //передается адрес символа в s[2]

    Обратите внимание, что оператор& стоит непосредственно перед именем структуры, а не перед именем отдельного члена. И еще 
    заметьте, что s уже обозначает адрес, поэтому& не требуется.
    
    
    
    
    
    ///////////Передача целых структур функциям
    Когда в качестве аргумента функции используется структура, то для передачи целой структуры используется обычный способ 
    вызова по значению. Это, конечно, означает, что любые изменения в содержимом параметра внутри функции не отразятся на 
    той структуре, которая передана в качестве аргумента.

    При использовании структуры в качестве аргумента надо помнить, что тип аргумента должен соответствовать типу параметра.
    Например, в следующей программе и аргумент arg, и параметр parm объявляются с одним и тем же типом структуры.

    #include <stdio.h>

    //Определение типа структуры
    struct struct_type {
        int a, b;
        char ch;
    };

    void f1(struct struct_type parm);

    int main(void)
    {
        struct struct_type arg; //объявление структуры

        arg.a = 1000;   //определение структуры

        f1(arg);

        return 0;
    }

    void f1(struct struct_type parm)
    {
        printf("%d", parm.a);
    }
    Как видно из этой программы, при объявлении параметров, являющихся структурами, объявление типа структуры должно быть 
    глобальным, чтобы структурный тип можно было использовать во всей программе. Например, если бы struct_type был бы объявлен
    внутри main(), то этот тип не был бы виден в f1().

    Как уже говорилось, при передаче структуры тип аргумента должен совпадать с типом параметра. Для аргумента и параметра 
    недостаточно просто быть физически похожими; должны совпадать даже имена их типов. Например, следующая версия предыдущей
    программы неправильная и компилироваться не будет. Дело в том, что имя типа для аргумента, используемого при вызове
    функции f1(), отличается от имени типа ее параметра.

    //Эта программа неправильная и при компиляции будут обнаружены ошибки.
    #include <stdio.h>

    //Определение типа структур.
    struct struct_type {
        int a, b;
        char ch;
    };

    //Определение структуры, похожей на struct_type, но сдругими именами.
    struct struct_type2 {
        int a, b;
        char ch;
    };

    void f1(struct struct_type2 parm);

    int main(void)
    {
        struct struct_type arg; //тут тип struct_type

        arg.a = 1000;

        f1(arg); //несовпадение типов

        return 0;
    }

    void f1(struct struct_type2 parm)   //а тут передаем тип struct_type2, это не соответствие, имя типа должно совпадать!!
    {
        printf("%d", parm.a);
    }
    */







    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/07/0704.htm
    printf("\n\n\n/////////// Указатели на структуры\n");
    /*
    В языке С указатели на структуры также официально признаны, как и указатели на любой другой вид объектов. Однако 
    указатели на структуры имеют некоторые особенности, о которых и пойдет речь.



    ///////////Объявление указателя на структуру
    Как и другие указатели, указатель на структуру объявляется с помощью звездочки *, которую помещают перед именем 
    переменной структуры. Например, для ранее определенной структуры addr следующее выражение объявляет addr_pointer 
    указателем на данные этого типа (то есть на данные типа addr):
    struct addr* addr_pointer;  //тут создали указатель addr_pointer на структуру addr.




    ///////////Использование указателей на структуры
    Указатели на структуры используются главным образом в двух случаях: когда структура передается функции с помощью вызова 
    по ссылке, и когда создаются связанные друг с другом списки и другие структуры с динамическими данными, работающие на 
    основе динамического размещения. В этой главе рассматривается первый случай.

    У такого способа, как передача любых (кроме самых простых) структур функциям, имеется один большой недостаток: при 
    выполнении вызова функции, чтобы поместить структуру в стек, необходимы существенные ресурсы. (Вспомните, что аргументы
    передаются функциям через стек.) Впрочем, для простых структур с несколькими членами эти ресурсы являются не такими уж 
    большими. Но если в структуре имеется большое количество членов или некоторые члены сами являются массивами, то при 
    передаче структур функциям производительность может упасть до недопустимо низкого уровня. Как же решить эту проблему? 
    Надо передавать не саму структуру, а указатель на нее.

    Когда функции передается указатель на структуру, то в стек попадает только адрес структуры. В результате вызовы функции
    выполняются очень быстро. В некоторых случаях этот способ имеет еще и второе преимущество: передача указателя позволяет
    функции модифицировать содержимое структуры, используемой в качестве аргумента.

    Чтобы получить адрес переменной-структуры, необходимо перед ее именем поместить оператор &. Например, в следующем 
    фрагменте кода

    struct bal {
      float balance;
      char name[80];
    } person;

    struct bal *p;  //объявление указателя на структуру

    адрес структуры person можно присвоить указателю p:
    p = &person;    //определение указателя на структуру

    Чтобы с помощью указателя на структуру получить доступ к ее членам, необходимо использовать оператор стрелка ->. 
    Вот, например, как можно сослаться на поле balance:
    p->balance

    Оператор ->, который обычно называют оператором стрелки, состоит из знака "минус", за которым следует знак "больше".
    Стрелка применяется вместо оператора точки тогда, когда для доступа к члену структуры используется указатель на структуру.

    Чтобы увидеть, как можно использовать указатель на структуру, проанализируйте следующую простую программу, которая 
    имитирует таймер, выводящий значения часов, минут и секунд:
    //Программа-имитатор таймера
    #include <stdio.h>

    #define DELAY 128000

    struct my_time {    //стркутура
        int hours;
        int minutes;
        int seconds;
    };

    //прототипы функций
    void display(struct my_time* t);
    void update(struct my_time* t);
    void delay(void);

    int main(void)
    {
        struct my_time systime;   //объявление структуры

        systime.hours = 0;
        systime.minutes = 0;
        systime.seconds = 0;

        for (;;) {
            update(&systime);   //передали в функцию адрес структуры
            display(&systime);  //передали в функцию адрес структуры
        }

        return 0;
    }

    void update(struct my_time* t)  //тут указатель на структуру "t" содержит адрес структуры systime
    {
        t->seconds++;               //и тут через оператор стрелка -> получаем доступ к членам структуры systime
        if (t->seconds == 60) {
            t->seconds = 0;
            t->minutes++;
        }

        if (t->minutes == 60) {     //и тут через оператор стрелка -> получаем доступ к членам структуры systime
            t->minutes = 0;
            t->hours++;
        }

        if (t->hours == 24) t->hours = 0;  //и тут через оператор стрелка -> получаем доступ к членам структуры systime
        delay();
    }

    void display(struct my_time* t)
    {
        printf("%02d:", t->hours);
        printf("%02d:", t->minutes);
        printf("%02d\n", t->seconds);
    }

    void delay(void)
    {
        long int t;

        //если надо, можно изменять константу DELAY (задержка)
        for (t = 1; t < DELAY; ++t);
    }
    Эту программу можно настраивать, меняя определение DELAY.

    В этой программе объявлена глобальная структура my_time, но при этом не объявлены никакие другие переменные программы.
    Внутри же main() объявлена структура systime и она инициализируется значением 00:00:00. Это значит, что systime 
    непосредственно видна только в функции main().

    Функциям update() (которая изменяет значения времени) и display() (которая выводит эти значения) передается адрес
    структуры systime. Аргументы в обеих функциях объявляются как указатель на структуру my_time.

    Внутри update() и display() доступ к каждому члену systime осуществляется с помощью указателя. Так как функция update() 
    принимает указатель на структуру systime, то она в состоянии обновлять значение этой структуры. Например, необходимо 
    "в полночь", когда значение переменной, в которой хранится количество часов, станет равным 24, сбросить отсчет и снова
    сделать значение этой переменной равным 0. Для этого в update() имеется следующая строка:
    if (t->hours == 24) t->hours = 0;

    Таким образом, компилятору дается указание взять адрес t(этот адрес указывает на переменную systime из main()) и сбросить
    значение hours в нуль.
    Помните, что оператор точка используется для доступа к элементам структуры при работе с самой структурой. А когда 
    используется указатель на структуру, то надо применять оператор стрелка.
    */






    
    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/07/0705.htm
    printf("\n\n\n/////////// Массивы и структуры внутри структур\n");
    /*
    Членом структуры может быть или простая переменная, например, типа int или double, или составной (не скалярный) тип. 
    В языке С составными типами являются массивы и структуры. Один составной тип вы уже видели — это символьные массивы, 
    которые использовались в addr.

    Члены структуры, которые являются массивами, можно считать такими же членами структуры, как и те, что нам известны из
    предыдущих примеров. Например, проанализируйте следующую структуру:

    struct x {
        int a[10][10]; //массив 10 x 10 из целых значений
        float b;
    } y;
    Целый элемент с индексами 3, 7 из массива a, находящегося в структуре y, обозначается таким образом:
    y.a[3][7]


    Когда структура является членом другой структуры, то она называется вложенной. Например, в следующем примере структура 
    address вложена в emp:
    struct emp {
        struct addr address; //вложенная структура
        float wage;
    } worker;

    Здесь структура emp была определена как имеющая два члена. Первым является структура типа addr, в которой находится адрес 
    работника. Второй член — это wage, где находятся данные по его зарплате. В следующем фрагменте кода элементу zip из address
    присваивается значение 93456.

    worker.address.zip = 93456;

    Как вы видите, в каждой структуре любой член обозначают с помощью тех структур, в которые он вложен — начиная от самых 
    общих и заканчивая той, непосредственно в которой он находится. В соответствии со стандартом С89 структуры могут быть 
    вложенными вплоть до 15-го уровня. А стандарт С99 допускает уровень вложенности до 63-го включительно.
    */






    
    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/07/0706.htm
    printf("\n\n\n/////////// Объединения (union) \n");
    /*
    Объединение — это место в памяти, которое используется для хранения переменных, разных типов. Объединение дает возможность
    интерпретировать один и тот же набор битов не менее, чем двумя разными способами. Объявление объединения (начинается с
    ключевого слова union) похоже на объявление структуры и в общем виде выглядит так:
    union тег {
      тип имя-члена;
      тип имя-члена;
      тип имя-члена;
      .
      .
      .
    } переменные-этого-объединения;

    Например:
    union u_type {
      int i;
      char ch;
    };
    Это объявление не создает никаких переменных. Чтобы объявить переменную, ее имя можно поместить в конце объявления или 
    написать отдельный оператор объявления. Чтобы с помощью только что написанного кода объявить переменную-объединение, 
    которая называется cnvt и имеет тип u_type, можно написать следующий оператор:
    union u_type cnvt;

    В cnvt одну и ту же область памяти занимают целая переменная i и символьная переменная ch. Конечно, i занимает 2 байта
    (при условии, что целые значения занимают по 2 байта), a ch — только 1. На рис. 7.2 показано, каким образом i и ch
    пользуются одним и тем же адресом. В любом месте программы хранящиеся в cnvt данные можно обрабатывать как целые или
    символьные.

    Рис. 7.2. Как i, так и ch, хранятся в объединении cnvt (подразумевается, что целые значения занимают по 2 байта)
    |<------ i ------>|
    |                 |
    +--------+--------+
    | Байт 0 | Байт 1 |
    +--------+--------+
    |        |
    |<- ch ->|
    ЖЕНЯ -  в итоге не понял как в памяти лежат, как массив друг за другом?
    Когда переменная объявляется с ключевым словом union, компилятор автоматически выделяет столько памяти, чтобы в ней
    поместился самый большой член нового объединения. Например, при условии, что целые значения занимают по 2 байта, для 
    размещения i в cnvt необходимо, чтобы длина этого объединения составляла 2 байта, даже если для ch требуется только 1 байт.

    Для получения доступа к члену объединения используйте тот же синтаксис, что и для структур: операторы точки и стрелки. 
    При работе непосредственно с объединением следует пользоваться точкой. А при получении доступа к объединению с помощью
    указателя нужен оператор стрелка. Например, чтобы присвоить целое значение 10 элементу i из cnvt, напишите
    cnvt.i = 10;

    В следующем примере функции func1 передается указатель на cnvt:
    func1(&cnvt);   //тут сделал для наглядности как выглядит вызов этой функции
    void func1(union u_type *un)
    {
      un->i = 10; //присвоение cnvt значение 10 с помощью указателя
    }
    Объединения часто используются тогда, когда нужно выполнить специфическое преобразование типов, потому что хранящиеся в 
    объединениях данные можно обозначать совершенно разными способами. Например, используя объединения, можно манипулировать 
    байтами, составляющими значение типа double, и делать так, чтобы менять его точность или выполнять какое-либо 
    необычное округление.


    Пример использования объединений (union)
    Чтобы получить представление о полезности объединений в случаях, когда нужны нестандартные преобразования типа, подумайте
    над проблемой записи целых значений типа short в файл, который находится на диске.
    В стандартной библиотеке языка С не определено никакой функции, специально предназначенной для выполнения этой записи.

    Хотя данные любого типа можно записывать в файл, пользуясь функцией fwrite(), но было бы нерационально применять этот
    способ для такой простой операции, как запись на диск целых значений типа short, так как получится чрезмерный перерасход
    ресурсов. А вот, используя объединение, можно легко создать функцию putw(), которая по одному байту будет записывать в
    файл двоичное представление целого значения типа short. (В этом примере предполагается, что такие значения имеют длину
    2 байта каждое.) Чтобы увидеть, как это делается, вначале создадим объединение, состоящее из целой переменной типа 
    short и массива 2-байтовых символов:

    union pw {
        short int i;
        char ch[2];//ЖЕНЯ почему тут двухбайтовые символы подразумеваются? если в час 1 байт и там массив из 3 эл. по 1 байту!?
    };

    Теперь с помощью pw можно написать вариант putw(), приведенный в следующей программе.
    #include <stdio.h>
    #include <stdlib.h>

    union pw {
        short int i;
        char ch[2];
    };

    int putw(short int num, FILE* fp);

    int main(void)
    {
        FILE* fp;

        fp = fopen("test.tmp", "wb+");
        if (fp == NULL) {
            printf("Файл не открыт.\n");
            exit(1);
        }

        putw(1025, fp);  //запись значения 1025
        fclose(fp);

        return 0;
    }

    int putw(short int num, FILE* fp)
    {
        union pw word;

        word.i = num;

        putc(word.ch[0], fp); //записать первую половину
        return putc(word.ch[1], fp); //записать вторую половину
    }
    Хотя функция putw() и вызывается с целым аргументом типа short, ей для выполнения побайтовой записи в файл на диске все
    равно приходится использовать стандартную функцию putc().
    */








    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/07/0707.htm
    printf("\n\n\n/////////// Битовые поля (ЖЕНЯ)\n");
    /*
    В отличие от некоторых других компьютерных языков, в языке С имеется встроенная поддержка битовых полей[1], которая дает
    возможность получать доступ к единичному биту. Битовые поля могут быть полезны по разным причинам, а именно:
     - Если память ограничена, то в одном байте можно хранить несколько булевых переменных (принимающих значения ИСТИНА и ЛОЖЬ);
     - Некоторые устройства передают информацию о состоянии, закодированную в байте в одном или нескольких битах;
     - Для некоторых процедур шифрования требуется доступ к отдельным битам внутри байта.

    Хотя для решения этих задач можно успешно применять побитовые операции, битовые поля могут придать вашему коду больше
    упорядоченности (и, возможно, с их помощью удастся достичь большей эффективности).

    Битовое поле может быть членом структуры или объединения. Оно определяет длину поля в битах. Общий вид определения 
    битового поля такой:
    тип имя : длина;

    Здесь тип означает тип битового поля, а длина — количество бит, которые занимает это поле. Тип битового поля может быть
    int, signed или unsigned. (Кроме того, в соответствии со стандартом С99, у битового поля еще может быть тип _Вооl.)

    Битовые поля часто используются при анализе данных, поступающих в программу с аппаратуры. Например, в результате опроса
    состояния адаптера последовательной связи может возвращаться байт состояния, организованный следующим образом:
    Бит	    Что означает, если установлен
    0	    Изменение в линии сигнала разрешения на передачу (change in clear-to-send line)
    1	    Изменение состояния готовности устройства сопряжения (change in data-set-ready)
    2	    Обнаружена концевая запись (trailing edge detected)
    3	    Изменение в приемной линии (change in receive line)
    4	    Разрешение на передачу. Сигналом CTS (clear-to-send) модем разрешает подключенному терминалу передавать данные
    5	    Модем готов (data-set-ready)
    6	    Телефонный вызов (telephone ringing)
    7	    Сигнал принят (received signal)

    Информацию в байте состояния можно представить с помощью следующего битового поля:
    struct status_type {            //ЖЕНЯ - это реальные имена каждого бита в байте как у регистров???
      unsigned delta_cts: 1;        //непонятно по поводу длины, какая она вообще может быть? чем она ограничена? по логике в
      unsigned delta_dsr: 1;        //1 байте 8 бит и если тут по 1 байту то длина 1 байт или нет?)))
      unsigned tr_edge:   1;        //тоесть в структуре мы можем определить только 8 бит тк их в байте 8 или сколько угодно?
      unsigned delta_rec: 1;
      unsigned cts:       1;
      unsigned dsr:       1;
      unsigned ring:      1;
      unsigned rec_line:  1;
    } status;

    Для того чтобы программа могла определить, когда можно отправлять или принимать данные, можно использовать такие операторы:
    status = get_port_status();
    if(status.cts) printf("Разрешение на передачу");
    if(status.dsr) printf("Данные готовы");

    Для присвоения битовому полю значения используйте тот же способ, что и для элемента, находящегося в структуре любого 
    другого типа. Вот, например, фрагмент кода, выполняющий сброс поля ring:
    status.ring = 0;

    Как видно из этого примера, каждое битовое поле доступно с помощью оператора точка. Однако если структура передана с 
    помощью указателя, то следует использовать оператор стрелка ->.
    Нет необходимости давать имя каждому битовому полю. Таким образом можно легко получать доступ к нужному биту, обходя
    неиспользуемые. Например, если вас интересуют только биты cts и dsr, то структуру status_type можно объявить таким образом:

    struct status_type {
      unsigned :    4;
      unsigned cts: 1;
      unsigned dsr: 1;
    } status;

    Кроме того, обратите внимание, что если биты, расположенные после dsr, не используются, то определять их не надо.
    В структурах можно сочетать обычные члены с битовыми полями. Например, в структуре
    struct emp {
        struct addr address;
        float pay;
        unsigned lay_off:    1;  //временно уволенный или работающий
        unsigned hourly:     1;  //почасовая оплата или оклад
        unsigned deductions: 3;  //налоговые (IRS) удержания
    };
    определены данные о работнике, для которых выделяется только один байт, содержащий информацию трех видов: статус
    работника, на окладе ли он, а также количество удержаний из его зарплаты. Без битового поля эта информация занимала
    бы 3 байта.

    Использование битовых полей имеет определенные ограничения. Нельзя получить адрес битового поля. Нет массивов битовых 
    данных. При переносе кода на другую машину неизвестно, будут ли поля обрабатываться справа налево или слева направо; 
    это значит, что выполнение любого кода, в котором используются битовые поля, в определенной степени может зависеть 
    от машины, на которой он выполняется. Другие ограничения будут зависеть от конкретных реализаций.

    ----------
    [1]Называются также полями битов.
    */







    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/07/0708.htm
    printf("\n\n\n/////////// Перечисления (enum) \n");
    /*
    Перечисление — это набор именованных целых констант. Перечисления довольно часто встречаются в повседневной жизни. Вот,
    например, перечисление, в котором приведены названия монет, используемых в Соединенных Штатах:
    penny (пенни, монета в один цент), nickel (никель, монета в пять центов), dime (монета в 10 центов), 
    quarter (25 центов, четверть доллара), half-dollar (полдоллара, 50 центов), dollar (доллар)

    Перечисления определяются во многом так же, как и структуры; началом объявления перечислимого типа[1] служит ключевое 
    слово enum. Перечисление в общем виде выглядит так:

    enum тег {список перечисления} список переменных;   //синтаксис !!!

    Здесь тег и список переменных не являются обязательными. (Но хотя бы что-то одно из них должно присутствовать.) 
    Следующий фрагмент кода определяет перечисление с именем coin (монета):
    enum coin { penny, nickel, dime, quarter,
                half_dollar, dollar};

    Тег перечисления можно использовать для объявления переменных данного перечислимого типа. Вот код, в котором money
    (деньги) объявляется в качестве переменной типа coin:

    enum coin money;    //объявили переменную перечисления !!!

    С учетом этих объявлений совершенно верными являются следующие операторы:
    money = dime;   //ЖЕНЯ ???
    if(money==quarter) printf("Денег всего четверть доллара.\n");

    Главное, что нужно знать для понимания перечислений — каждый их элемент[2] представляет целое число. В таком виде 
    элементы перечислений можно применять везде, где используются целые числа. Каждому элементу дается значение, на единицу
    большее, чем у его предшественника. Первый элемент перечисления имеет значение 0. Поэтому, при выполнении кода
    printf("%d %d", penny, dime);   //ЖЕНЯ тоесть чары в перечисления записывать нельзя?
    на экран будет выведено 0 2.

    Однако для одного или более элементов можно указать значение, используемое как инициализатор. Для этого после 
    перечислителя надо поставить знак равенства, а затем — целое значение. Перечислителям, которые идут после инициализатора,
    присваиваются значения, большие предшествующего. Например, следующий код присваивает quarter значение 100:
    enum coin { penny, nickel, dime, quarter=100,
                half_dollar, dollar};

    вот какие значения появились у этих элементов:
    penny           0
    nickel          1
    dime            2
    quarter         100
    half_dollar     101
    dollar          102

    Относительно перечислений есть одно распространенное, но ошибочное мнение. Оно состоит в том, что их элементы можно
    непосредственно вводить и выводить. Это не так. Например, следующий фрагмент кода не будет выполняться так, как того
    ожидают многие неопытные программисты:
    //этот код работать не будет
    money = dollar;
    printf("%s", money);

    Здесь dollar — это имя для значения целого типа; это не строка. Таким образом, попытка вывести money в виде строки по 
    существу обречена. По той же причине для достижения нужных результатов не годится и такой код:
    //этот код не правильный 
    strcpy(money, "dime");
    То есть строка, содержащая имя элемента, автоматически в этот перечислитель не превратится.

    На самом же деле создавать код для ввода и вывода элементов перечислений — это довольно - таки скучное занятие(но его
    можно избежать лишь тогда, когда будет достаточно именно целых значений этих перечислителей). Например, чтобы выводить
    название монеты, вид которой находится в money, потребуется следующий код:

    switch (money) {
        case penny: printf("пенни");
            break;
        case nickel: printf("никель");
            break;
        case dime: printf("монета в 10 центов");
            break;
        case quarter: printf("четверть доллара");
            break;
        case half_dollar: printf("полдоллара");
            break;
        case dollar: printf("доллар");
    }

    Иногда можно объявить строчный массив и использовать значение перечисления как индекс при переводе этого значения в 
    соответствующую строку. Например, следующий код также выводит нужную строку:
    char name[][12] = {     //ЖЕНЯ - что это за массив, двумерный??
      "пенни",
      "никель",
      "монета в 10 центов",
      "четверть доллара",
      "полдоллара",
      "доллар"
    };
    printf("%s", name[money]);

    Конечно, он будет работать только тогда, когда не инициализирован ни один из элементов перечисления, так как строчный
    массив должен иметь индекс, который начинается с 0 и возрастает каждый раз на 1.

    Так как при операциях ввода / вывода необходимо специально заботиться о преобразовании перечислений в их строчный 
    эквивалент, который можно легко прочитать, то перечисления полезнее всего именно в тех процедурах, где такие 
    преобразования не нужны. Например, перечисления часто применяются, чтобы определить таблицы соответствия символов в
    компиляторах.

    ----------
    [1]	Иногда используется термин перечисляемый тип.
    [2]Элементы списка перечисления называются также перечислителями и идентификаторами.
    */






    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/07/0709.htm
    printf("\n\n\n/////////// Важное различие между С и С++\n");
    /*
    Что касается имен типов структур, объединений и перечислений, то между языками С и C++ имеется важное различие. 
    Чтобы понять эту разницу, проанализируйте следующее объявление структуры:
    struct MyStruct {
      int a;
      int b;
    };

    В языке С имя MyStruct называется тегом. Чтобы объявить объект типа MyStruct, необходимо использовать выражение,
    аналогичное следующему:
    struct MyStruct obj;

    Как можно заметить, перед именем MyStruct находится ключевое слово struct. Однако в C++ для этой операции достаточно
    использовать объявление покороче:
    MyStruct obj; //Нормально для C++, неправильно для C

    В C++ не требуется ключевое слово struct. В C++, как только структура объявлена, можно объявлять переменные ее типа,
    используя только ее тег и не ставя перед ним ключевого слова struct. Дело здесь в том, что в С имя структуры не определяет
    полное имя типа. Вот почему в С это имя называется не полным именем, а тегом. Однако в C++ имя структуры является полным
    именем типа, и оно может использоваться для определения переменных. Не надо, впрочем, забывать, что до сих пор можно
    на вполне законных основаниях в программе на языке C++ использовать и объявление в стиле С.

    Все сказанное выше можно обобщить для объединений и перечислений. Таким образом, в С при объявлении объектов 
    непосредственно перед тегом имени должно находиться одно из ключевых слов : struct, union или enum (в зависимости 
    от конкретного случая). А в C++ ключевое слово не требуется.

    Так как для C++ подходят объявления в стиле С, то во время переноса программ из С в C++ по этому поводу беспокоиться
    нечего. Но при переносе из C++ в С соответствующие изменения сделать придется.
    */







    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/07/0710.htm
    printf("\n\n\n/////////// Использование sizof для обеспечения переносимости\n");
    /*
    Вы имели возможность убедиться, что структуры и объединения можно использовать для создания переменных разных размеров,
    а также в том, что настоящий размер этих переменных в разных машинах может быть разным. Оператор sizeof подсчитывает
    размер любой переменной или любого типа и может быть полезен, если в программах требуется свести к минимуму 
    машинно-зависимый код. Этот оператор особенно полезен там, где приходится иметь дело со структурами или объединениями.

    Перед тем как переходить к дальнейшему изложению, предположим, что определенные типы данных имеют следующие размеры:
    Тип        Размер в байтах
    char       1
    int        4
    double     8

    Поэтому при выполнении следующего кода на экран будут выведены числа 1, 4 и 8:
    char ch;
    int i;
    double f;

    printf("%d", sizeof(ch));
    printf("%d", sizeof(i));
    printf("%d", sizeof(f));

    Размер структуры равен сумме размеров ее членов или, возможно, даже больше этой суммы. Рассмотрим пример:
    struct s {
      char ch;
      int i;
      double f;
    } s_var;

    Здесь sizeof(s_var) равняется как минимум 13 (=8+4+1). Однако размер s_var может быть и больше, потому что компилятору 
    иногда необходимо специально увеличить размер структуры, выровнять некоторые ее члены на границу слова или параграфа.
    (Параграф занимает 16 байтов.) Так как размер структуры может быть больше, чем сумма размеров ее членов, то всегда, 
    когда нужно знать размер структуры, следует использовать sizeof. Например, если требуется динамически выделять память 
    для объекта типа s, необходимо использовать последовательность операторов, аналогичную той, что показана здесь 
    (а не вставлять вручную значения длины его членов):
    struct s *p;
    p = malloc(sizeof(struct s));   //ЖЕНЯ - тут мы в указатель положили не адрес в памяти, а размер структуры???

    Так как sizeof — это оператор времени компиляции, то вся информация, необходимая для вычисления размера любой
    переменной, становится известной как раз во время компиляции. Это особенно важно для объединений, потому что размер
    каждого из них всегда равен размеру наибольшего члена. Например, проанализируйте следующее объединение:
    union u {
      char ch;
      int i;
      double f;
    } u_var;

    Для него sizeof(u_var) равняется 8. Впрочем, во время выполнения не имеет значения, какой размер на самом деле 
    имеет u_var. Важен размер его наибольшего члена, так как любое объединение должно быть такого же размера, как и 
    его самый большой элемент.
    */
    /*МОЙ коммент
    для структур размер байтов суммируется и это будет размер структуры!
    для объединенний берется размер наибольшиго члена объединения! но непонятно как они там все помещаются?
    */





    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/07/0711.htm
    printf("\n\n\n/////////// Средство typedef\n");
    /*
    Новые имена типов данных можно определять, используя ключевое слово typedef. На самом деле таким способом новый тип 
    данных не создается, а всего лишь определяется новое имя для уже существующего типа. Этот процесс может помочь сделать
    машинно-зависимые программы более переносимыми. Если вы для каждого машинно-зависимого типа данных, используемого в 
    вашей программе, определяете данное вами имя, то при компиляции для новой среды придется менять только операторы typedef.
    Такие выражения могут помочь в самодокументировании кода, позволяя давать понятные имена стандартным типам данных. 
    Общий вид декларации typedef (оператора typedef) такой:
    typedef тип новое_имя;
    где тип — это любой тип данных языка С, а новое_имя — новое имя этого типа. Новое имя является дополнением к уже 
    существующему, а не его заменой.

    Например, для float можно создать новое имя с помощью
    typedef float balance;

    Это выражение дает компилятору указание считать balance еще одним именем float. Затем, используя balance, можно создать
    переменную типа float:
    balance over_due;

    Теперь имеется переменная с плавающей точкой over_due типа balance, a balance является еще одним именем типа float.

    Теперь, когда имя balance определено, его можно использовать и в другом операторе typedef. Например, выражение
    typedef balance overdraft;
    дает компилятору указание признавать overdraft в качестве еще одного имени balance, которое в свою очередь является
    еще одним именем float.

    Использование операторов typedef может облегчить чтение кода и его перенос на новую машину. Однако новый физический 
    тип данных таким способом вы не создадите.
    */


    /*

    */

    return 0;
}
