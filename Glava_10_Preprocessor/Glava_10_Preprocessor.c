#include <locale.h>
#include <stdio.h>



int main(void)
{
    char* locale = setlocale(LC_ALL, "");



    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/10/10.htm
    printf("\n\n\n/////////// Препроцессор и комментарии\n");
    /*
    В исходный код программы на языке С можно вставлять различные инструкции компилятору. Они называются директивами 
    препроцессора и расширяют возможности среды программирования. Кроме них, в этой главе еще рассказывается о комментариях.
    
    Содержание:
        Препроцессор
        Директива #define
        Директива #error
        Директива #include
        Директивы условной компиляции
        Директива #undef
        Использование defined
        Директива #line
        Директива #pragma
        Операторы препроцессора # и ##
        Имена предопределенных макрокоманд
        Комментарии
    */





    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/10/1001.htm
    printf("\n\n\n/////////// Препроцессор\n");
    /*
    Имеются следующие директивы препроцессора:
    #define     #endif     #ifdef       #line
    #elif       #error     #ifndef      #pragma
    #else       #if        #include     #undef

    Как легко заметить, все они начинаются со знака #. Кроме того, каждая директива препроцессора должна занимать отдельную
    строку. Например, строка
    #include <stdio.h>   #include <stdlib.h>
    рассматривается как недопустимая.
    */






    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/10/1002.htm
    printf("\n\n\n/////////// Директива #define\n");
    /*
    Директива #define определяет идентификатор и последовательность символов, которая будет подставляться вместо 
    идентификатора каждый раз, когда он встретится в исходном файле. Идентификатор называется именем макроса, а сам процесс
    замены — макрозаменой[1]. В общем виде директива выглядит таким образом:

    #define имя_макроса последовательность_символов

    Обратите внимание, что в этом выражении нет точки с запятой. Между идентификатором и последовательностью символов 
    последовательность_символов может быть любое количество пробелов, но признаком конца последовательности символов может
    быть только разделитель строк.

    Предположим, например, что вместо значения 1 нужно использовать слово LEFT (левый), а вместо значения 0 — слово RIGHT
    (правый). Тогда можно сделать следующие объявления с помощью директивы #define:
    #define LEFT 1
    #define RIGHT 0

    В результате компилятор будет подставлять 1 или 0 каждый раз, когда в вашем файле исходного кода встречается идентификатор
    соответственно LEFT или RIGHT. Например, следующий код выводит на экран 0 1 2:
    printf("%d %d %d", RIGHT, LEFT, LEFT+1);

    После определения имя макроса можно использовать в определениях других имен макросов. Вот, например, код, определяющий
    значения ONE (один), TWO (два) и three (три):
    #define ONE    1
    #define TWO    ONE+ONE
    #define THREE  ONE+TWO

    Макроподстановка — это просто замена какого-либо идентификатора связанной с ним последовательностью символов. Поэтому 
    если требуется определить стандартное сообщение об ошибке, то можно написать примерно следующее:

    #define E_MS "стандартная ошибка при вводе\n"
    // ... //
    printf(E_MS);

    Теперь каждый раз, когда встретится идентификатор E_MS, компилятор будет его заменять строкой "стандартная ошибка при
    вводе\n".Для компилятора выражение printf() на самом деле будет выглядеть таким образом:

    printf("стандартная ошибка при вводе\n");

    Если идентификатор находится внутри строки, заключенной в кавычки, то замены не будет.Например, при выполнении кода:
    #define XYZ это проверка
    printf("XYZ");
    вместо сообщения "это проверка" будет выводиться последовательность символов XYZ.

    Если последовательность_символов не помещается в одной строке, то эту последовательность можно продолжить на следующей
    строке, поместив в конце предыдущей, как показано ниже, обратную косую черту:
    #define LONG_STRING "это очень длинная \
    строка, используемая в качестве примера"

    Программисты, пишущие программы на языке С, в именах определяемых идентификаторов часто используют буквы верхнего
    регистра. Если разработчики программ следуют этому правилу, то тот, кто будет читать их программу, с первого взгляда 
    поймет, что будет происходить макрозамена.Кроме того, все директивы #define обычно лучше всего помещать в самом начале
    файла или в отдельном заголовочном файле, а не разбрасывать по всей программе.

    Имена макросов часто используются для определения имен так называемых "магических чисел" (встречающихся в программе).
    Например, имеется программа, в которой определяется массив и несколько процедур, получающих доступ к этому массиву.
    Вместо того чтобы размер массива "зашивать в код" в виде константы, этот размер можно определить с помощью оператора
    #define, а затем использовать это имя макроса везде, где требуется размер массива.Таким образом, если требуется 
    изменить этот размер, то потребуется изменить только соответствующий оператор #define, a затем перекомпилировать 
    программу. Рассмотрим, например, фрагмент программы

    #define MAX_SIZE 100
    // ... //
    float balance[MAX_SIZE];
    // ... //
    for (i = 0; i < MAX_SIZE; i++) printf("%f", balance[i]);
    // ... //
    for (i = 0; i < MAX_SIZE; i++) x = +balance[i];

    Размер массива balance определяется именем макроса MAX_SIZE, и поэтому если этот размер потребуется в будущем изменить, 
    то надо будет изменить только определение MAX_SIZE.В результате при перекомпиляции программы все обращения к этому 
    имени макроса, находящиеся после измененного определения, будут автоматически изменены.
    
    
    
    
    
    
    
    ///////////Определение макросов с формальными параметрами
    У директивы #define имеется еще одно большое достоинство: имя макроса может определяться с формальными параметрами.
    Тогда каждый раз, когда в программе встречается имя макроса, то используемые в его определении формальные параметры
    заменяются теми аргументами, которые встретились в программе.Такого рода макросы называются макросами с формальными
    параметрами[2]. Например,
    #include <stdio.h>

    #define ABS(a)  (a) < 0 ? -(a) : (a)

    //ЖЕНЯ
    int main(void)
    {
        printf("модули чисел -1 и 1 равны соответственно %d и %d", ABS(-1), ABS(1));

        return 0;
    }

    Во время компиляции этой программы вместо формального параметра "а" из определения макроса будут подставляться 
    значения -1 и 1. Скобки, в которых находится "а", позволяют в любом случае сделать правильную замену. Например, если 
    скобки, стоящие вокруг "а", удалить, то выражение
    ABS(10 - 20)
    после макрозамены будет преобразовано в
    10 - 20 < 0 ? -10 - 20 : 10 - 20
    и может привести к неправильному результату.

    Использование вместо настоящих функций макросов с формальными параметрами дает одно существенное преимущество: 
    увеличивается скорость выполнения кода, потому что в таких случаях не надо тратить ресурсы на вызов функций. Однако 
    если у макроса с формальными параметрами очень большие размеры, то тогда из-за дублирования кода увеличение скорости
    достигается за счет увеличения размеров программы.

    И вот еще что: хотя макросы с формальными параметрами являются полезным средством, но в С99(и в C++) есть еще более 
    эффективный способ создания машинной программы — с использованием ключевого слово inline.
    На заметку: В С99 можно определить макрос с переменным количеством формальных параметров; об этом рассказывается в
    части II этой книги.

    ----------
    [1]А также макрорасширением, макрогенерацией и макроподстановкой.Определение макроса часто называют макроопределением, 
    а обращение к макросу — макровызовом или макрокомандой.Впрочем, иногда макроопределение также называется макрокомандой.
    [2]А также макроопределениями с параметрами и макросами, напоминающими функции.
    */






    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/10/1003.htm
    printf("\n\n\n/////////// Директива #error\n");
    /*
    Директива #error заставляет компилятор прекратить компиляцию. Эта директива используется в основном для отладки. В 
    общем виде директива #error выглядит таким образом:
    #еrrоr сообщение-об-ошибке
    сообщение-об-ошибке в двойные кавычки не заключается. Когда встречается директива #error, то выводится сообщение об 
    ошибке — возможно, вместе с другой информацией, определяемой компилятором.
    */






    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/10/1004.htm
    printf("\n\n\n/////////// Директива #include\n");
    /*
    Директива #include дает указание компилятору читать еще один исходный файл — в дополнение к тому файлу, в котором 
    находится сама эта директива. Имя исходного файла должно быть заключено в двойные кавычки или в угловые скобки. 
    Например, обе директивы
    #include "stdio.h"
    #include <stdio.h>
    дают компилятору указание читать и компилировать заголовок для библиотечных функций системы ввода/вывода.

    Файлы, имена которых находятся в директивах #include, могут в свою очередь содержать другие директивы #include. Они 
    называются вложенными директивами #include. Количество допустимых уровней вложенности у разных компиляторов может быть 
    разным. Однако в стандарте С89 предусмотрено, что компиляторы должны допускать не менее 8 таких уровней. А в стандарте 
    С99 предусмотрена поддержка не менее 15 уровней вложенности.

    Способ поиска файла зависит от того, заключено ли его имя в двойные кавычки или же в угловые скобки. Если имя заключено 
    в угловые скобки, то поиск файла проводится тем способом, который определен в компиляторе. Часто это означает поиск 
    определенного каталога, специально предназначенного для хранения таких файлов. Если имя заключено в кавычки, то поиск
    файла проводится другим способом. Во многих компиляторах это означает поиск файла в текущем рабочем каталоге. Если же 
    файл не найден, то поиск повторяется уже так, как будто имя файла заключено в угловые скобки.

    Обычно большинство программистов имена стандартных заголовочных файлов заключают в угловые скобки. А использование 
    кавычек обычно приберегается для имен специальных файлов, относящихся к конкретной программе. Впрочем, твердого и 
    простого правила, по которому кавычки требуется использовать именно таким образом, не существует.

    В С-программе директиву #include можно использовать не только для указания имени файла, содержащего обычный исходный 
    текст программы, но и для указания заголовка. В языке С определен набор стандартных заголовков, содержащих необходимую
    информацию о различных библиотеках этого языка. Заголовок — это стандартный идентификатор, который может соответствовать
    имени файла, а может и не соответствовать ему. Таким образом, заголовок является просто абстракцией, которая гарантирует
    наличие некоторой информации. Однако на практике в языке С заголовки почти всегда являются именами файлов.
    */






    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/10/1005.htm
    printf("\n\n\n/////////// Директивы условной компиляции\n");
    /*
    Имеется несколько директив, которые дают возможность выборочно компилировать части исходного кода вашей программы. 
    Этот процесс называется условной компиляцией и широко используется фирмами, живущими за счет коммерческого программного
    обеспечения — теми, которые поставляют и поддерживают многие специальные версии одной программы.
    
    
    
    
    
    ///////////Директивы #if, #else, #elif и #endif
    Возможно, самыми распространенными директивами условной компиляции являются #if, #else, #elif и #endif. Они дают 
    возможность в зависимости от значения константного выражения включать или исключать те или иные части кода.

    В общем виде директива #if выглядит таким образом:
    #if константное выражение
        последовательность операторов
    #endif

    Если находящееся за #if константное выражение истинно, то компилируется код, который находится между этим выражением 
    и #endif. В противном случае этот промежуточный код пропускается. Директива #endif обозначает конец блока #if. Например,

    //Простой пример #if
    #include <stdio.h>

    #define MAX 100

    int main(void)
    {
    #if MAX>99
            printf("Компилирует для массива, размер которого больше 99.\n");
    #endif

        return 0;
    }

    Это программа выводит сообщение на экран, потому что МАХ больше 99. В этом примере показано нечто очень важное.
    Значение выражения, находящегося за директивой #if, должно быть вычислено во время компиляции. Поэтому в этом выражении 
    могут находиться только ранее определенные идентификаторы и константы, — но не переменные.

    Директива #else работает в основном так, как else — ключевое слово языка С: задает альтернативу на тот случай, если не
    выполнено условие #if. Предыдущий пример можно дополнить следующим образом:

    //Простой пример #if/#else
    #include <stdio.h>

    #define MAX 10

    int main(void)
    {
    #if MAX>99
            printf("Компилирует для массива, размер которого больше 99.\n");
    #else
            printf("Компилирует для небольшого массива.\n");
    #endif 

        return 0;
    }
    В этом случае выясняется, что МАХ меньше 99, поэтому часть кода, относящаяся к #if, не компилируется. Однако 
    компилируется альтернативный код, относящийся к #else, и откомпилированная программа будет отображать сообщение 
    Компилируется для небольшого массива.

    Обратите внимание, что директива #else используется для того, чтобы обозначить и конец блока #if, и начало блока #else.
    Это естественно, поскольку любой директиве #if может соответствовать только одна директива #endif.

    Директива #elif означает "else if" и устанавливает для множества вариантов компиляции цепочку if - else - if.
    После #elif находится константное выражение.Если это выражение истинно, то компилируется находящийся за ним блок кода,
    и больше не проверяются никакие другие выражения #elif.В противном же случае проверяется следующий блок этой 
    последовательности.В общем виде #elif выглядит таким образом:

    #if выражение
        последовательность операторов
    #elif выражение 1
        последовательность операторов
    #elif выражение 2
        последовательность операторов
    #elif выражение 3
        последовательность операторов
    #elif выражение 4
        .
            .
            .
    #elif выражение N
        последовательность операторов
    #endif

    Например, в следующем фрагменте для определения знака денежной единицы используется значение ACTIVE_COUNTRY(для 
    какой страны):

    #define US 0 
    #define ENGLAND 1
    #define FRANCE 2

    #define ACTIVE_COUNTRY US

    #if ACTIVE_COUNTRY == US
            char currency[] = "dollar";
    #elif ACTIVE_COUNTRY == ENGLAND
            char currency[] = "pound";
    #else
            char currency[] = "franc";
    #endif

    В соответствии со стандартом С89 у директив #if и #elif может быть не менее 8 уровней вложенности. А в соответствии 
    со стандартом С99 программистам разрешается использовать не менее 63 уровней вложенности. При вложенности каждая 
    директива #endif, #else или #elif относится к ближайшей директиве #if или #elif.Например, совершенно правильным 
    является следующий фрагмент кода:

    #if MAX>100
        #if SERIAL_VERSION
            int port = 198;
        #elif
            int port = 200;
        #endif
    #else
        char out_buffer[100];
    #endif






    ///////////Директивы #ifdef и #ifndef
    Другой способ условной компиляции — это использование директив #ifdef и #ifndef, которые соответственно означают 
    "if defined" (если определено) и "if not defined" (если не определено).В общем виде #ifdef выглядит таким образом:

    #ifdef имя_макроса
        последовательность операторов
    #endif

    Блок кода будет компилироваться, если имя макроса было определено ранее в операторе #define.

    В общем виде оператор #ifndef выглядит таким образом:
    #ifndef имя_макроса
        последовательность операторов
    #endif

    Блок кода будет компилироваться, если имя макроса еще не определено в операторе #define.
    И в #ifdef, и в #ifndef можно использовать оператор #else или #elif.Например,

    #include <stdio.h>

    #define TED 10

    int main(void)
    {

    #ifdef TED
            printf("Привет, Тед\n");
    #else
            printf("Привет, кто-нибудь\n");
    #endif

    #ifndef RALPH
            printf("А RALPH не определен, т.ч. Ральфу не повезло.\n");
    #endif

        return 0;
    }
    выведет Привет, Тед, а также A RALPH не определен, т.ч.Ральфу не повезло.

    В соответствии со стандартом С89 допускается не менее 8 уровней #ifdef и #ifndef.А стандарт С99 устанавливает, что
    должно поддерживаться не менее 63 уровней вложенности.
    */






    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/10/1006.htm
    printf("\n\n\n/////////// Директива #undef\n");
    /*
    Директива #undef удаляет ранее заданное определение имени макроса, то есть "аннулирует" его определение; само имя
    макроса должно находиться после директивы. В общем виде директива #undef выглядит таким образом:

    #undef имя_макроса

    Вот как, например, можно использовать эту директиву:
    #define LEN 100
    #define WIDTH 100

    char array[LEN][WIDTH];

    #undef LEN
    #undef WIDTH
    //а здесь и LEN и WIDTH уже не определены

    И LEN, и WIDTH определены, пока не встретился оператор #undef.
    Директива #undef используется в основном для того, чтобы локализовать имена макросов в тех участках кода, где они нужны.
    */






    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/10/1007.htm
    printf("\n\n\n/////////// Использование defined\n");
    /*
    Кроме применения #ifdef, есть еще второй способ узнать, определено ли имя макроса. Можно использовать директиву #if в
    сочетании с оператором времени компиляции defined. В общем виде оператор defined выглядит таким образом:
    defined имя_макроса

    Если имя_макроса определено, то выражение считается истинным; в противном случае — ложным. Например, чтобы узнать, 
    определено ли имя макроса MYFILE, можно использовать одну из двух команд препроцессора:
    #if defined MYFILE
    или
    #ifdef MYFILE

    Можно также задать противоположное условие, поставив ! прямо перед defined. Например, следующий фрагмент компилируется 
    только тогда, когда имя макроса DEBUG не определено:
    #if !defined DEBUG
      printf("Окончательная версия!\n");
    #endif

    Единственная причина, по которой используется оператор defined, состоит в том, что с его помощью в #elif можно узнать, 
    определено ли имя макроса.
    */






    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/10/1008.htm
    printf("\n\n\n/////////// Директива #line\n");
    /*
    Директива #line изменяет содержимое __LINE__ и __FILE__, которые являются зарезервированными идентификаторами в 
    компиляторе. В первом из них содержится номер компилируемой в данный момент строки кода. А второй идентификатор — это 
    строка, содержащая имя компилируемого исходного файла. В общем виде директива #line выглядит таким образом:
    #line номер "имя_файла"
    где номер — это положительное целое число, которое становится новым значением __LINE__, а необязательное имя_файла — 
    это любой допустимый идентификатор файла, становящийся новым значением __FILE__. Директива #line в основном используется
    для отладки и специальных применений.

    Например, следующий код определяет, что счетчик строк будет начинаться с 100, а оператор printf() выводит номер 102, 
    потому что он расположен в третьей строке программы после оператора #line 100:
    #include <stdio.h>

    #line 100                  //установить счетчик строк
    int main(void)             //строка 100
    {                          //строка 101
        printf("%d\n", __LINE__); //строка 102

        return 0;
    }
    */







    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/10/1009.htm
    printf("\n\n\n/////////// Директива #pragma\n");
    /*
    Директива #pragma — это определяемая реализацией директива, которая позволяет передавать компилятору различные инструкции. 
    Например, компилятор может поддерживать трассировку выполнения программы. Тогда возможность трассировки можно указывать в
    операторе #pragma. Возможности этой директивы и относящиеся к ней подробности должны быть описаны в документации по 
    компилятору.

    На заметку: В стандарте С99 директиве #pragma есть альтернатива — оператор _Pragma. О нем рассказывается в части II этой
    книги.
    */






    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/10/1010.htm
    printf("\n\n\n/////////// Операторы препроцессора # и ##\n");
    /*
    Имеется два оператора препроцессора: # и ##. Они применяются в сочетании с оператором #define.
    Оператор #, который обычно называют оператором превращения в строку (stringize), превращает аргумент, перед которым 
    стоит, в строку, заключенную в кавычки. Рассмотрим, например, следующую программу:
    #include <stdio.h>

    #define mkstr(s)  # s

    int main(void)
    {
      printf(mkstr(Мне нравится C));

      return 0;
    }

    Препроцессор превращает строку
    printf(mkstr(Мне нравится C));
    в
    printf("Мне нравится C");


    Оператор ##, который называют оператором склеивания (pasting), или конкатенации конкатенирует две лексемы. Рассмотрим, 
    например, программу
    #include <stdio.h>

    #define concat(a, b)  a ## b

    int main(void)
    {
      int xy = 10;

      printf("%d", concat(x, y));

      return 0;
    }

    Препроцессор преобразует
    printf("%d", concat(x, y));
    в
    printf("%d", xy);

    Если эти операторы покажутся вам незнакомыми, то надо помнить вот о чем: они не являются необходимыми и не используются
    в большинстве программ. В общем-то, эти операторы предусмотрены для работы препроцессора в некоторых особых случаях.
    */






    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/10/1011.htm
    printf("\n\n\n/////////// Имена предопределенных макрокоманд\n");
    /*  //ЖЕНЯ
    В языке С определены пять встроенных, предопределенных имен макрокоманд. Вот они:
    __LINE__
    __FILE__
    __DATE__
    __TIME__
    __STDC__

    В такой же последовательности о них здесь и пойдет речь.
    Об именах макросов __LINE__ и __FILE__ рассказывалось, когда говорилось о директиве #line. Говоря кратко, они содержат 
    соответственно номер строки и имя файла компилируемой программы.

    В имени макроса __DATE__ содержится строка в виде месяц/день/год, то есть дата перевода исходного кода в объектный.
    В имени макроса __TIME__ содержится время компиляции программы. Это время представлено строкой, имеющей
    вид час:минута:cекунда.

    Если __STDC__ определено как 1, то тогда компилятор выполняет компиляцию в соответствии со стандартом С. А что 
    касается С99, то в этом стандарт определены еще два имени макросов:
    __STDC_HOSTED__
    __STDC_VERSION__

    __STDC_HOSTED__ равняется 1 для тех сред, в которых выполнение происходит под управлением операционной системы,
    и 0 — в противном случае. __STDC_VERSION__ будет равно как минимум 199901 и будет увеличиваться с каждой новой 
    версией языка С. (В С99 могут быть определены и другие имена макросов, о них рассказывается в части II.)
    */






    // http://paulfertser.info/polnyy_spravochnik_po_c_gerbert_shildt/10/1012.htm
    printf("\n\n\n/////////// Комментарии\n");
    /* */
    //


    return 0;
}
